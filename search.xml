<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>生产-消费模型组件实现 Producer Consumer Solution using BlockingQueue</title>
    <url>/2021/05/14/%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0-Producer-Consumer-Solution-using-BlockingQueue/</url>
    <content><![CDATA[<p>原来各个应用某些业务节点的日志通过<strong>filebeat+elk</strong>收集，供各个业务方使用，线上发现filebeat消耗非常大的硬件资源，而且应用集群较大，每次新增日志类型时需要新增filebeat配置并启动新的应用进程，较为繁琐和耗服务器资源；优化成通过kafka收集日志，consumer消费并写入es，考虑到频繁的写入es会造成应用资源、网络开销的浪费，设计上为批量写入es。该应用场景比较通用，考虑把该生产-消费模型抽成组件放入公共模块。</p>
<h5 id="组件设计细节"><a href="#组件设计细节" class="headerlink" title="组件设计细节"></a>组件设计细节</h5><ul>
<li>使用方自定义业务属性；</li>
<li>使用方自定义写入阈值</li>
<li>业务方实现具体消费接口，建议使用线程池消费</li>
<li>支持按业务隔离阻塞队列，不同业务属性使用不同队列</li>
<li>单线程轮询阻塞队列，线程池执行消费，加快执行速率</li>
<li>支持任务在队列中驻留时间自定义</li>
<li>程序退出最大保证任务不丢失(钩子函数)</li>
</ul>
<p>本着易用、可扩展性原则，使用方不关心内部实现，只需要关心消费策略和业务实现即可。该组件实现具体功能可以概括为：任务不断的被放入阻塞队列中，线程池会不断轮训队列，当任务数达到阈值时，会批量实现具体业务需求，并在程序退出时，最大化保证任务不丢失。</p>
<p>生产消费模型如下：</p>
<p><img src="无标题-2021-10-13-1059.png" alt="无标题-2021-10-13-1059.png"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>阻塞队列集合：</p>
<pre><code>public interface BlockQueue &#123;

    /**
     * taskName : BlockingQueue
     */
    Map&lt;String, LinkedBlockingQueue&lt;QueueTask&gt;&gt; BLOCK_MSG_QUEUE_TASK_MAP = Maps.newConcurrentMap();

&#125;
</code></pre><p>任务QueueTask：</p>
<pre><code>public interface QueueTask&#123;
&#125;

</code></pre><p>消费接口，使用方实现：</p>
<pre><code>public interface BlockQueueConsumer&lt;R&gt; &#123;
    void accept(R queueTasks);
&#125;
</code></pre><p>任务添加、处理类：</p>
<pre><code>@Slf4j
public class QueueTaskExecutor &#123;

    private static final AtomicBoolean SHUTDOWN_HOOK_FLAG = new AtomicBoolean(true);

    private static final AtomicInteger ATOMIC_INTEGER_COUNT = new AtomicInteger(0);

    private static final ExecutorService QUEUE_TASK_EXECUTOR = Executors.newSingleThreadExecutor();

    private static Integer MAX_IDLE_COUNT = 600;

    /**
     * max task count
     */
    private Integer maxElements;

    /**
     * consumer interface
     */
    private BlockQueueConsumer&lt;List&lt;QueueTask&gt;&gt; blockQueueConsumer;

    /**
     * task unique name
     */
    private String taskName;

    /**
     * the theoretical maximum time that the task stays in the blocking queue. the time Must be an integer multiple of
     * 100，if not the default is 60 * 1000
     */
    private int delayMilliSecond;

    @PostConstruct
    private void init() &#123;
        // create block queue
        BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.putIfAbsent(taskName, new LinkedBlockingQueue&lt;QueueTask&gt;());
        // shutdown hook
        addShutdownHook(QUEUE_TASK_EXECUTOR);
        int idleCount = delayMilliSecond / 100;
        MAX_IDLE_COUNT = idleCount &gt; 0 ? idleCount : MAX_IDLE_COUNT;
        QUEUE_TASK_EXECUTOR.execute(() -&gt; &#123;
            while (true) &#123;
                try &#123;
                    if (!SHUTDOWN_HOOK_FLAG.get()) &#123; // task exit
                        if (BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.get(taskName).size() &lt;= 0) &#123;
                            log.warn(
                                &quot;QueueExecutor shutdown executing,but the BLOCK_MSG_QUEUE empty. The task exit now.&quot;);
                            Thread.sleep(100);
                            // double check
                            if (BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.get(taskName).size() &lt;= 0) &#123;
                                return;
                            &#125;
                        &#125;
                    &#125; else &#123;
                        if (BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.get(taskName).size() &lt; maxElements) &#123;
                            // when idle times over #MAX_IDLE_TIME then do consumer
                            if (ATOMIC_INTEGER_COUNT.incrementAndGet() &gt; MAX_IDLE_COUNT) &#123;
                                try &#123;
                                    doConsumer();
                                &#125; finally &#123;
                                    ATOMIC_INTEGER_COUNT.set(0);
                                &#125;
                            &#125;
                            Thread.sleep(100);
                            continue;
                        &#125;
                    &#125;
                    doConsumer();
                &#125; catch (Exception e) &#123;
                    log.warn(&quot;QueueExecutor execute error.&quot;, e);
                &#125;
            &#125;
        &#125;);
    &#125;

    private void doConsumer() &#123;

        List&lt;QueueTask&gt; queueTasks = Lists.newArrayList();
        // get tasks in batch
        BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.get(taskName).drainTo(queueTasks, maxElements);
        if (CollectionUtils.isEmpty(queueTasks)) &#123;
            log.warn(&quot;QueueExecutor BLOCK_MSG_QUEUE empty.&quot;);
            return;
        &#125;
        Task&lt;List&lt;QueueTask&gt;&gt; task = Task.&lt;List&lt;QueueTask&gt;&gt;builder().t(queueTasks).build();
        blockQueueConsumer.accept(task);
    &#125;

    /**
     * add task to Queue
     *
     * @param taskName unique task name
     * @param t        element
     * @param &lt;T&gt;
     */
    public static &lt;T extends QueueTask&gt; void add2Queue(String taskName, T t) &#123;

        LinkedBlockingQueue&lt;QueueTask&gt; blockingQueue = BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.get(taskName);
        Assert.notNull(blockingQueue, &quot;QueueTaskExecutor blockingQueue taskName not exist！&quot;);
        blockingQueue.add(t);
    &#125;

    public static void addShutdownHook(ExecutorService executorService) &#123;

        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;
            try &#123;
                SHUTDOWN_HOOK_FLAG.set(false);
                Shutdown.shutdown(executorService, 100);
            &#125; catch (Exception e) &#123;
                log.error(&quot;QueueTaskExecutor shutdown fail.&quot;, e);
            &#125;
        &#125;));
    &#125;

    private QueueTaskExecutor() &#123;

    &#125;

    public QueueTaskExecutor(String taskName, Integer maxElements, int delayMilliSecond,
        BlockQueueConsumer blockQueueConsumer) &#123;

        this.taskName = taskName;
        this.maxElements = maxElements;
        this.delayMilliSecond = delayMilliSecond;
        this.blockQueueConsumer = blockQueueConsumer;
    &#125;
&#125;
</code></pre><p>具体代码实现也不复杂，有个细节的点，可能队列中任务一直没达到阈值，会导致任务一直驻留在队列中，所以在设计时，考虑到了不能让任务一直驻留，所以设计了超过驻留最大时间，会自动执行任务。使用无界阻塞队列<code>LinkedBlockingQueue</code>，保证高并发下放任务、批量获取任务的线程安全，具体不作多述。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><pre><code>@Slf4j
@Configuration
public class QueueTaskConfig &#123;

    @Value(&quot;$&#123;bulkSize&#125;&quot;)
    private Integer bulkSize;

    @Bean
    public QueueTaskExecutor queueTaskExecutor() &#123;

        return new QueueTaskExecutor(QUEUE_TASK_NAME, bulkSize, 60 * 1000,
            blockQueueConsumer());

    &#125;

    @Bean(name = &quot;XXXXBlockQueueConsumer&quot;)
    public BlockQueueConsumer blockQueueConsumer() &#123;

        return new XXXXBlockQueueConsumer();
    &#125;

    // 监控队列大小
    static &#123;
        TRACE_SCHEDULE.scheduleAtFixedRate(() -&gt; &#123;
            log.info(&quot;trace BlockQueue size: &#123;&#125;&quot;,
                Option.of(BlockQueue.BLOCK_MSG_QUEUE_TASK_MAP.get(QUEUE_TASK_NAME))
                    .getOrElse(LinkedBlockingQueue::new)
                    .size()
            );
        &#125;, 0, 1, TimeUnit.SECONDS);
    &#125;
&#125;

</code></pre><p>BlockQueueConsumer实现类：</p>
<pre><code>public class XXXXBlockQueueConsumer implements BlockQueueConsumer&lt;List&lt;EsMsgDto&gt;&gt; &#123;

    @Override
    public void accept(List&lt;EsMsgDto&gt; task) &#123;
        // 线程池处理消费
        ES_EXECUTOR.execute(() -&gt; &#123;
            writer2Es(task.getT());
        &#125;);
    &#125;

    private void writer2Es(List&lt;EsMsgDto&gt; queueTasks) &#123;
        // 构建BulkRequest
        BulkRequest bulkRequest = new BulkRequest();
        Option.of(queueTasks)
                .getOrElse(ArrayList::new)
                .stream()
                .map(EsCommand::buildIndexRequest)
                .collect(Collectors.toList())
                .forEach(bulkRequest::add);
        // 批量写入es
        EsCommand.addBulk(client, bulkRequest, new ActionListener&lt;BulkResponse&gt;() &#123;
            @Override
            public void onResponse(BulkResponse bulkItemResponses) &#123;

            &#125;

            @Override
            public void onFailure(Exception e) &#123;
                log.error(&quot;XXXXBlockQueueConsumer bulk onFailure.&quot;, e);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre><p>业务上使用比较简单，也较为灵活，支持多业务的生产消费，使用方可指定具体的消费阈值，实现具体的业务需求。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>组件</tag>
        <tag>生产-消费</tag>
      </tags>
  </entry>
  <entry>
    <title>队列机组件实现</title>
    <url>/2021/08/14/%E9%98%9F%E5%88%97%E6%9C%BA%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><a href="https://lioswong.github.io/2021/05/14/%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0-Producer-Consumer-Solution-using-BlockingQueue/">生产-消费模型组件实现 Producer Consumer Solution using BlockingQueue</a>该篇文章介绍了使用阻塞队列实现了生产-消费模型，细心的朋友可以发现，是在单应用内通过阻塞队列实现的，而实际的分布式系统中，如何实现生产-消费模型呢？由于该模型通过队列实现，该组件况且称作为队列机。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul>
<li>生产-消费模型<br><img src="无标题-2021-10-13-1059.png" alt="无标题-2021-10-13-1059.png"></li>
<li>线程池模型<br><img src="1.png" alt="1.png"></li>
</ul>
<p>对比单机环境下的模型来看，分布式环境的队列机更为复杂，阻塞队列当然不能再使用java提供的工具类，这里使用redis作为队列，使用redis哪种数据类型作为存储方式呢，这里选择zset，不仅仅是为了实现生产消费，结合zset数据结构，而且还可以实现延迟队列。下面介绍延迟队列机的组件实现方式。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="队列接口"><a href="#队列接口" class="headerlink" title="队列接口"></a>队列接口</h5><pre><code>public interface BatchDelayQueue&lt;V&gt; &#123;

    /**
     * 初始化延迟队列
     *
     * @param topic 主题
     */
    void init(String topic);

    /**
     * 初始化延迟队列
     *
     * @param topic 主题
     */
    void init(String topic, Integer batchSize);

    /**
     * 初始化延迟队列
     *
     * @param topic         主题
     * @param redisTemplate
     */
    void init(String topic, Integer batchSize, RedisTemplate redisTemplate);

    /**
     * 新增元素到队列中
     *
     * @param e   加入的元素
     * @param delay 延时时间，单位为毫秒
     * @return 添加结果
     */
    boolean add(V e, long delay);

    /**
     * 批量获取符合元素
     *
     * @param time 超时时间，单位为毫秒
     * @return 返回并删除符合时间要求的元素
     * @throws Exception 异常情况
     */
    List&lt;QueueTask&lt;V&gt;&gt; poll(long time) throws Exception;

    /**
     * 删除元素
     */
    Long remove(V e);
&#125;
</code></pre><h5 id="队列实现类"><a href="#队列实现类" class="headerlink" title="队列实现类"></a>队列实现类</h5><pre><code>@Slf4j
public class ExtBatchDelayQueue implements BatchDelayQueue&lt;String&gt; &#123;

    private String topic;

    private Lock redisLock;

    private RedisTemplate&lt;String, String&gt; redisTemplate;

    private Integer batchSize;

    public static final Integer DEFAULT_BATCH_SIZE = 50;

    public static final Integer DEFAULT_MAX_BATCH_SIZE = 100;

    @Override
    public void init(String topic) &#123;

        this.init(topic, DEFAULT_BATCH_SIZE);
    &#125;

    // 可以指定批量获取数目
    @Override
    public void init(String topic, Integer batchSize, RedisTemplate redisTemplate) &#123;
        this.topic = topic;
        this.redisTemplate = redisTemplate;
        this.batchSize = batchSize == null ? DEFAULT_BATCH_SIZE
            : (batchSize &gt; DEFAULT_MAX_BATCH_SIZE ? DEFAULT_MAX_BATCH_SIZE : batchSize);
        RedisLockRegistry redisLockRegistry = new RedisLockRegistry(redisTemplate.getConnectionFactory(), &quot;lock&quot;);
        this.redisLock = redisLockRegistry.obtain(topic);
    &#125;

    @Override
    public List&lt;QueueTask&lt;String&gt;&gt; poll(long timeout) throws Exception &#123;

        boolean lock = false;
        try &#123;
            // 加分布式锁，保证同一时间只有一台机器poll任务
            lock = redisLock.tryLock(timeout, TimeUnit.MILLISECONDS);
            if (lock) &#123;
                // 获取任务
                Set&lt;TypedTuple&lt;String&gt;&gt; sets = redisTemplate.opsForZSet()
                    .rangeByScoreWithScores(topic, 0, System.currentTimeMillis(), 0, batchSize);
                if (CollectionUtils.isEmpty(sets)) &#123;
                    return null;
                &#125;
                List&lt;QueueTask&lt;String&gt;&gt; tasks = sets.stream()
                    .map(p -&gt; QueueTask.&lt;String&gt;builder().score(p.getScore()).value(p.getValue()).build())
                    .collect(Collectors.toList());
                try &#123;
                    // 删除
                    redisTemplate.opsForZSet()
                        .remove(topic, sets.stream().map(TypedTuple::getValue).toArray());
                &#125; catch (Exception e) &#123;
                    log.error(&quot;ExtRedisBatchDelayQueue poll remove error.&quot;, e);
                &#125;
                return tasks;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;ExtRedisBatchDelayQueue poll error.&quot;, e);
            throw e;
        &#125; finally &#123;
            if (lock) &#123;
                redisLock.unlock();
            &#125;
        &#125;
        return null;
    &#125;

    @Override
    public boolean add(String e, long delay) &#123;

        return redisTemplate.opsForZSet().add(topic, e, System.currentTimeMillis() + delay);
    &#125;
&#125;
</code></pre><h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h5><pre><code>public class DelayQueueBatchBootstrap &#123;

    /**
     * 队列
     */
    private BatchDelayQueue delayQueue;

    /**
     * 批量拉取任务数,不大于100
     */
    private int batchSize;

    /**
     * 队列唯一名称
     */
    private String delayQueueKey;

    /**
     * redis
     */
    private RedisTemplate&lt;String, String&gt; redisTemplate;

    /**
     * 队列监控（消费速度、队列大小、延迟时间）
     */
    private DelayQueueMonitor delayQueueMonitor;

    /**
     * volatile关键字防止构造函数溢出
     */
    private volatile ExecutorService HANDLE_DELAY_TASK_EXECUTOR;

    private final AtomicBoolean RUNNING = new AtomicBoolean(true);

    private final ExecutorService DELAY_QUEUE_POLL_EXECUTOR = new ThreadPoolExecutor(1, 1,
        60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1),
        new ThreadFactoryBuilder().setNameFormat(&quot;delayQueuePollThread-%d&quot;).build());

    private DelayQueueBatchBootstrap() &#123;

    &#125;

    public DelayQueueBatchBootstrap(String delayQueueKey, BatchDelayQueue delayQueue,
        RedisTemplate&lt;String, String&gt; redisTemplate, boolean queueMonitor) &#123;

        this(delayQueueKey, delayQueue, redisTemplate, new DefaultDelayQueueMonitor(queueMonitor, queueMonitor),
            DEFAULT_BATCH_SIZE);
    &#125;

    public DelayQueueBatchBootstrap(String delayQueueKey, BatchDelayQueue delayQueue,
        RedisTemplate&lt;String, String&gt; redisTemplate, boolean queueMonitor, long delayThreshold) &#123;

        this(delayQueueKey, delayQueue, redisTemplate,
            new DefaultDelayQueueMonitor(queueMonitor, queueMonitor, delayThreshold),
            DEFAULT_BATCH_SIZE);
    &#125;

    public DelayQueueBatchBootstrap(String delayQueueKey, BatchDelayQueue delayQueue,
        RedisTemplate&lt;String, String&gt; redisTemplate, DelayQueueMonitor delayQueueMonitor) &#123;

        this(delayQueueKey, delayQueue, redisTemplate, delayQueueMonitor, DEFAULT_BATCH_SIZE);
    &#125;

    public DelayQueueBatchBootstrap(String delayQueueKey, BatchDelayQueue delayQueue,
        RedisTemplate&lt;String, String&gt; redisTemplate, DelayQueueMonitor delayQueueMonitor, Integer batchSize) &#123;

        this(delayQueueKey, delayQueue, redisTemplate, delayQueueMonitor, batchSize, null);
    &#125;

    public DelayQueueBatchBootstrap(String delayQueueKey,
        BatchDelayQueue delayQueue, RedisTemplate&lt;String, String&gt; redisTemplate,
        DelayQueueMonitor delayQueueMonitor, Integer batchSize,
        ExecutorService handleDelayTaskExecutorDefault) &#123;

        this.delayQueueKey = delayQueueKey;
        this.redisTemplate = redisTemplate;
        this.batchSize = batchSize;
        this.delayQueue = delayQueue;
        this.HANDLE_DELAY_TASK_EXECUTOR = handleDelayTaskExecutorDefault;
        this.delayQueueMonitor =
            delayQueueMonitor == null ? new DefaultDelayQueueMonitor(false, false) : delayQueueMonitor;
    &#125;

    /**
     * spring容器加载所有的bean之后触发事件时开始poll
     *
     * @see DelayQueueHandlerLoader 保证所有的Handler加载完成，避免任务丢失
     */
    @EventListener(value = ContextRefreshedEvent.class)
    public void init() &#123;

        delayQueue.init(delayQueueKey, batchSize, redisTemplate);
        delayQueueMonitor.schedule(delayQueueKey, redisTemplate);
        addShutDownHook();
        DELAY_QUEUE_POLL_EXECUTOR.execute(() -&gt; &#123;
            while (RUNNING.get()) &#123;
                List&lt;QueueTask&lt;String&gt;&gt; elementFromDelayQueue = null;
                try &#123;
                    elementFromDelayQueue = delayQueue.poll(1000);
                    if (CollectionUtils.isEmpty(elementFromDelayQueue)) &#123;
                        Thread.sleep(100);
                        continue;
                    &#125;
                    elementFromDelayQueue.iterator().forEachRemaining(p -&gt; &#123;
                        try &#123;
                            // 线程池执行
                            executorService
                                .submit(() -&gt; &#123;
                                ...
                                处理具体业务逻辑
                                ...
                                &#125;);
                                // 监控
                            // delayQueueMonitor
                        &#125; catch (Exception e) &#123;
                            log.error(&quot;delayQueueHandle exec task fail.[&#123;&#125;]&quot;, p, e);
                        &#125;
                    &#125;);
                &#125; catch (RejectedExecutionException rejectedExecutionException) &#123;
                    log.error(&quot;delayQueueHandle failed, reject execution! element.[&#123;&#125;]&quot;,
                        elementFromDelayQueue, rejectedExecutionException);
                &#125; catch (Exception e) &#123;
                    if (RUNNING.get()) &#123;
                        log.error(&quot;delayQueueHandle failed, element.[&#123;&#125;]&quot;, elementFromDelayQueue, e);
                    &#125; else &#123;
                        log.warn(&quot;delayQueueQueue not running.&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;);
    &#125;

    private void addShutDownHook() &#123;

        Runtime.getRuntime().addShutdownHook(
            new Thread(() -&gt; &#123;
              // 优雅关停
               ...
               ...
            &#125;));
    &#125;

    public boolean putElement(Object bizElement, long delay) &#123;

        try &#123;
            delayQueue.add(bizElement, delay &gt; 0 ? delay : 8000);
            log.info(&quot;put element into delay queue，element.[&#123;&#125;], delayMillis.[&#123;&#125;]&quot;,
                elementJson, delay);
            return true;
        &#125; catch (Exception e) &#123;
            log.error(&quot;put element into delay queue failed, element.[&#123;&#125;], delayMillis.[&#123;&#125;]&quot;,
                elementJson, delay, e);
            return false;
        &#125;
    &#125;
&#125;
</code></pre><h5 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h5><pre><code>@Configuration
public class DelayQueueConfig &#123;


    @Bean(name = &quot;delayQueue&quot;)
    public DelayQueueBatchBootstrap delayQueue() &#123;

        return new DelayQueueBatchBootstrap(&quot;xxxxx&quot;, new ExtBatchDelayQueue(),
            redisTemplate, delayQueueMonitor(), &quot;批量拉取大小&quot;, &quot;指定线程池)&quot;;
    &#125;


    private DelayQueueMonitor delayQueueMonitor() &#123;

        return new DelayQueueMonitor() &#123;

            @Override
            public boolean logSwitch() &#123;
                 return true;
            &#125;

            @Override
            public boolean taskCostSwitch() &#123;

              return true;
            &#125;
        &#125;;
    &#125;

&#125;

</code></pre><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ol>
<li>由于篇幅的原因，很多代码没有贴出来，有很多其他功能，上面有添加、拉取任务的方法，还有比如批量添加、批量删除、阻塞拉取任务、判断延迟任务队列大小、判断任务是否存在、以及获取任务延迟时间等等。</li>
<li>支持批量拉取，以及延迟队列监控，线程池消费，优雅关停等等。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面只是通过延迟队列去实现队列机，其实可以根据该思路，实现分布式环境下的生产-消费模型组件。</p>
<ol>
<li>使用时，注意任务较多时，应该队列隔离开来，不同业务使用单独的队列，否则会导致任务积压，任务延迟处理，影响实际业务。</li>
<li>消费时，使用线程池消费，可以提高消费速率，不过也要通过具体的业务量，计算线程池大小，否则会造成线程池资源耗尽。</li>
</ol>
<p>实际业务场景中，大量使用该模型解决业务需求。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>组件</tag>
        <tag>生产-消费</tag>
        <tag>队列机</tag>
      </tags>
  </entry>
  <entry>
    <title>强弱依赖&amp;监控&amp;预案&amp;演练</title>
    <url>/2023/11/23/%E5%BC%BA%E5%BC%B1%E4%BE%9D%E8%B5%96-%E7%9B%91%E6%8E%A7-%E9%A2%84%E6%A1%88-%E6%BC%94%E7%BB%83/</url>
    <content><![CDATA[<p>#SRE</p>
<ul>
<li style="list-style: none"><input type="checkbox"></input> 链路梳理<ul>
<li style="list-style: none"><input type="checkbox"></input> 工具(在线化)</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 强弱依赖<ul>
<li style="list-style: none"><input type="checkbox"></input> 强依赖<ul>
<li style="list-style: none"><input type="checkbox"></input> 容灾</li>
<li style="list-style: none"><input type="checkbox"></input> 业务布控</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 弱依赖<ul>
<li style="list-style: none"><input type="checkbox"></input> 自动降级</li>
<li style="list-style: none"><input type="checkbox"></input> 预案</li>
</ul>
</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 监控&amp;预案<ul>
<li style="list-style: none"><input type="checkbox"></input> 监控<ul>
<li style="list-style: none"><input type="checkbox"></input> 分类<ul>
<li style="list-style: none"><input type="checkbox"></input> 系统监控</li>
<li style="list-style: none"><input type="checkbox"></input> 业务监控 (对业务量监控, 例如正常的搜索为空, 可能代码改造, 导致bug, 告不出来)</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 监控指标<ul>
<li style="list-style: none"><input type="checkbox"></input> 总量</li>
<li style="list-style: none"><input type="checkbox"></input> 成功率</li>
<li style="list-style: none"><input type="checkbox"></input> rt</li>
<li style="list-style: none"><input type="checkbox"></input> 单机、集群 (避免单机抖动误告) 例如单机5分钟成功率持续小于xxx; 集群 10%的机器2分钟持续成功率小于xxx</li>
</ul>
</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 预案<ul>
<li style="list-style: none"><input type="checkbox"></input> 五要素<ul>
<li style="list-style: none"><input type="checkbox"></input> 执行时机</li>
<li style="list-style: none"><input type="checkbox"></input> 执行动作</li>
<li style="list-style: none"><input type="checkbox"></input> 执行影响</li>
<li style="list-style: none"><input type="checkbox"></input> 恢复时机</li>
<li style="list-style: none"><input type="checkbox"></input> 客服口径</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 保鲜</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"></input> 演练<ul>
<li style="list-style: none"><input type="checkbox"></input> 破坏</li>
<li style="list-style: none"><input type="checkbox"></input> 验证</li>
<li style="list-style: none"><input type="checkbox"></input> 恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>强弱依赖</tag>
        <tag>监控</tag>
        <tag>预案</tag>
        <tag>演练</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch API简单使用</title>
    <url>/2023/11/23/Elasticsearch-API%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>笔者喜欢做一些小工具，给PM或者组内同学使用，不仅仅可以提高工作效率，而且也可以学一些前端方面的知识。之前使用Elasticsearch API做过管理后台的小工具，一直没有总结，最近给PM哥们又做了一个小工具，而且也使用到了Elasticsearch API，正好做个简单分享。</p>
<blockquote>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4></blockquote>
<p>PM最近经常让我统计每家机构调用某个接口的失败记录信息，虽然接口调用记录已经打到日志了，但是没有关键字信息所以很难去统计，显然之前做过根据一个或多个关键字查询我们平台所有日志的后台管理小工具不适用了。</p>
<blockquote>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4></blockquote>
<ol>
<li>业务底层必须把三方返回信息返回到上层</li>
<li>业务上层统一处理,按照固定格式把信息打到日志里</li>
<li>管理后台根据条件筛选查找,通过es根据关键字查找</li>
</ol>
<blockquote>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4></blockquote>
<ol>
<li>业务代码日志打印<pre><code>JSONObject jsonObject = new JSONObject();
jsonObject.put(&quot;time&quot;, new Date());
jsonObject.put(&quot;companyId&quot;, companyId);
jsonObject.put(&quot;companyName&quot;, CompanyAppIdEnum.getCompanyAppIdEnum(companyId).getDesc());
jsonObject.put(&quot;orderNo&quot;, &quot;暂不展示敏感信息&quot;);
jsonObject.put(&quot;orderStatus&quot;, -1);
jsonObject.put(&quot;type&quot;,FilterFailEnum.FILTER.getName());
// 关键字
jsonObject.put(&quot;keyword&quot;, CompanyAppIdEnum.getCompanyAppIdEnum(companyId).getDesc() + FilterFailEnum.FILTER.getDesc());
jsonObject.put(&quot;fail&quot;, response.getErrorMsg());
thirdLogger.info(jsonObject.toJSONString());
</code></pre></li>
<li>Elasticsearch Client构建<br>因为是Java程序员，所以用的Java客户端<br>构建TransportClient<pre><code>/**
  * elasticsearch集群
  * TransportClient获取
  *
  * @return
  */
 protected TransportClient getTransportClient() &#123;
     if (transportClient == null) &#123;
         synchronized (ElkLogSearchServiceImpl.class) &#123;
             if (transportClient == null) &#123;
                 //ES集群地址
                 String[] ESHosts = configUtil.getEsClientHosts().split(&quot;,&quot;);
                 //设置es实例名称
                 Settings settings = Settings.builder().put(&quot;cluster.name&quot;, configUtil.getEsClusterName())
                         //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中、
                         .put(&quot;client.transport.sniff&quot;, true)
                         .put(&quot;xpack.security.user&quot;, configUtil.getEsClientUser())
                         .put(&quot;xpack.security.transport.ssl.verification_mode&quot;, &quot;certificate&quot;)
                         .put(&quot;xpack.security.transport.ssl.enabled&quot;, &quot;true&quot;)
                         .put(&quot;xpack.security.transport.ssl.keystore.path&quot;, configUtil.getEsCertificates())
                         .put(&quot;xpack.security.transport.ssl.truststore.path&quot;, configUtil.getEsCertificates()).build();
                 TransportClient preBuiltTransportClient = new PreBuiltXPackTransportClient(settings);
                 for (String esHost : ESHosts) &#123;
                     preBuiltTransportClient.addTransportAddress(new TransportAddress(new InetSocketAddress(esHost, 9300)));
                 &#125;
                 return preBuiltTransportClient;
             &#125;
         &#125;
     &#125;
     return transportClient;
 &#125;
</code></pre></li>
<li>根据时间获取索引、构建查询条件<pre><code>/**
* 根据时间范围获得索引
* @param startDate
* @param endDate
* @return
*/
protected String[] getIndices(long startDate, long endDate,String indiceName) &#123;
 int days = (int) (endDate - startDate) / 86400000 + 1;
 String[] indices = new String[days];
 for (int i = 0; i &lt; days; i++) &#123;
     String dayIndex = simpleDateFormat.format(new Date(startDate + i * 86400000));
     indices[i] = indiceName + dayIndex;
 &#125;
 return indices;
&#125;
</code></pre></li>
</ol>
<pre><code>protected QueryBuilder getFilterQueryBuilder(String keywords)&#123;
    BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();
    // 可以添加多个查询条件
    queryBuilder.must(QueryBuilders.matchPhraseQuery(&quot;message.params&quot;,keywords));
    return queryBuilder;
&#125;
</code></pre><ol start="4">
<li>查询<pre><code>public ResponseVo getFilterFailByES(Long companyId, int pageNo, FilterFailEnum filterFailEnum, long startDate, long endDate) &#123;
     ResponseVo vo = new ResponseVo();
     LinkedList linkedList = new LinkedList();
     transportClient = getTransportClient();
     String regexp = CompanyAppIdEnum.getCompanyAppIdEnum(companyId).getDesc() + filterFailEnum.getDesc();
     String[] indices = getIndices(startDate, endDate, IndiceTypeEnum.JKZJ_API_THIRD_SERVER_LOG.getIndiceName());
     QueryBuilder queryBuilder = getFilterQueryBuilder(regexp);
     try &#123;
         SearchResponse searchResponse = transportClient.prepareSearch(indices).setQuery(queryBuilder).addSort(&quot;logdate&quot;, SortOrder.DESC).setSize(10).setFrom((pageNo - 1) * 10).execute().actionGet();
         SearchHits searchHits = searchResponse.getHits();
         if (searchHits.getTotalHits() &gt; 0) &#123;
             for (SearchHit searchHit : searchHits) &#123;
                 JSONObject paramsDetailsJO = JSONObject.parseObject(searchHit.getSourceAsString());
                 JSONObject messapgeParam = paramsDetailsJO.getJSONObject(&quot;message&quot;).getJSONObject(&quot;params&quot;);
                 Long time = messapgeParam.getLong(&quot;time&quot;);
                 String companyIds = messapgeParam.getString(&quot;companyId&quot;);
                 String companyName = messapgeParam.getString(&quot;companyName&quot;);
                 String orderNo = messapgeParam.getString(&quot;orderNo&quot;);
                 String orderStatus = messapgeParam.getString(&quot;orderStatus&quot;);
                 String fail = messapgeParam.getString(&quot;fail&quot;);
                 String type = messapgeParam.getString(&quot;type&quot;);
                 Map map = new HashMap();
                 map.put(&quot;companyId&quot;, companyIds);
                 Date times = new Date(Long.valueOf(time));
                 map.put(&quot;time&quot;, DateUtils.getDate(times));
                 map.put(&quot;companyName&quot;, companyName);
                 map.put(&quot;orderNo&quot;, orderNo);
                 map.put(&quot;orderStatus&quot;, orderStatus);
                 map.put(&quot;fail&quot;, fail);
                 map.put(&quot;type&quot;, type);
                 linkedList.add(map);
             &#125;
         &#125;
         vo.setVoList(linkedList);
         //总条数
         vo.setMsg(searchHits.getTotalHits() + &quot;&quot;);
     &#125; catch (Exception e) &#123;
         logger.error(e.getMessage(), e);
         vo.setCode(204);
         vo.setMsg(&quot;查询失败&quot;);
     &#125;
     return vo;
 &#125;
</code></pre><blockquote>
<h4 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h4></blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEB8821157b1044b8b70dee777027aa7258?method=download&amp;shareKey=f47bc85a3780b5f5343ddddb75743be5" alt="https://note.youdao.com/yws/api/personal/file/WEB8821157b1044b8b70dee777027aa7258?method=download&amp;shareKey=f47bc85a3780b5f5343ddddb75743be5"><br>好啦，再也不用被PM老哥烦了。</li>
</ol>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>沟通技巧</title>
    <url>/2022/09/13/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>沟通</category>
      </categories>
      <tags>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>阳明心学</title>
    <url>/2022/09/13/%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>心学</category>
      </categories>
      <tags>
        <tag>心学</tag>
        <tag>阳明</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>财富自我认知</title>
    <url>/2022/09/05/%E8%B4%A2%E5%AF%8C%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
        <tag>财富</tag>
      </tags>
  </entry>
  <entry>
    <title>股票投资法则</title>
    <url>/2022/09/04/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<img  src=http://www.plantuml.com/plantuml/svg/9P3DJi9G48NtF0KRaojfmeyXRZJXLKXquG9ZbBLf4Q7o8w1Ke2qnDaqWKH05iI3OX_7EjFCMNdgNvzpvvimzkQjY_h9OE3i_AUGlOeaupWtG1ooJogIJsMJcS3-MICJXUOts6mqTXZKZ_2hpZSOzyq_L-Cytg1jf2adL9jXZ-Xs0kmXBBn7Bj_VGzkYrZpMBaUe8pLUpqBSK8QGDtQcCyMzGx5ormr5ffqajGUiT9qvWwIoTkavdzx2x3AmQDEVY8MAmeOaaD6RiwFX08Ql2lOauXgeT1Uqx6hG3ioorc1GEMWjmpPqPKOfSYBOAxWWQJ_9aRqA67wnz1aCJfYPe9lQMr5i83EqwjEeAw5Nm6-HqWfN6roxs7oEIUf_qy27xO38Mz0hTDdTVsOgPtAaeMfRz3m00>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>股票</tag>
        <tag>理财</tag>
        <tag>投资</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中注意事项</title>
    <url>/2022/08/21/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<img  src=http://www.plantuml.com/plantuml/svg/HLBBSjf04Bpp5JgxzWzoyQ-uAZdau5GgyO6Z158Go44uc638seI4XyeF2Go9zK3eOxApk_gBp6e9kQYqiztJFRrp-l7YxCF5-Tjthy_FtjTE37YPivpoJS1jdwLUEKrg9yUgQK6wOB49uHZsGndE19tyCIsvdSZjJoAB4R-9E3LXadBwA1SMNpSK6__WQS5sOw11QJQWvugn3JJ57nPxu5_9QI1Rz_2oHb6vj8YYqZPlRlXcG519iqlwBEsuihCpyIoBbWWy5ZyHewGcSaGsagR5RmkDv3H5535uT0sBXlBLwugi3wizCS2FM3Q7AD446Ms9KQ_N2Sgop6I9gplAwHmS1zt-3q7fB2D-Px4uWqv0e9NAzZE4bzpjQKJbs5qTEeSpr88lbwoOiYpx5mSDm7bakw5EGVww4_ikoxwoD7qbbjZQAsz_e3lyydOY8rlVLUpH68gcIYJvJdYdpt8V-x9ye4leLSzzK1BKGo_WFY0TxzZkHZGIeh6wALRBGG4pco0MpygU-maZngDgmjiOJth4ubBmfaDWjLPZEbUYkpeCh25wJW9PAXuy_QhgjVCrz3z3vriLPFMSB2_4TL0EG_3dgdhSAzvTWliRHKHsNwkTli7LrElv5m00>
]]></content>
      <categories>
        <category>工作经验</category>
      </categories>
      <tags>
        <tag>工作经验</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理</title>
    <url>/2022/08/21/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>做为项目PM,对于项目的管理要注意以下几点:<br><img  src=http://www.plantuml.com/plantuml/svg/NP7BJi9058RtF4MNGBhnjdB3gs3Kn0N6AEuBGg7bLWW42aK2Ma95GDHKABU7iMUcynQUeJKnRYPdvZ_p_USIkql6RvE9g-lpHFmc51LOVqaxKphjKqqEHQF2mRUKWfL3nuL0iHpM_1G4hXsYHbILs0fKLCY_qNO6b19ePJgUqOd238dCqwIeWDhp7ZOqlIG56V8ov1pIDSFqlGREqBDLkfBn17CJyR57t39lqVg8rbjKMK9dIyerOlH4WSEcZqpFkev3cYPYH7SZUyCKRUZ4K22RzUoFi_jBZZb639Q08bHUOIqHVUIkso9eHJ8nWsPM6VWotOtXxJemRq2jo9xAJBVGo53y43iZJTjTg4GrJuFfG7M4jrzsLHJ-CZdA6OP1oq2lvtDv8Sqf6xHuiAT6UBHFPxaY7HNeeCfBFk43DIGS1PbLuDaABBIgX-_TtN-RUGEj9qFi2bEmH7zhek3jT7Vn0jiyovNmVoXsWTlrD_m3></p>
<p>项目开展中,要关注整个项目的进展,有风险需要及时上报, 需要<strong>向上管理</strong>,把控好项目的节奏和风险;<br>对于紧急项目,既要又要的需求要给出AB方案,考虑时间成本情况下,决策选择方案.<br>整个项目是以结果为导向,大家目标是一致的,要克服困难最终拿到结果.</p>
]]></content>
      <categories>
        <category>工作经验</category>
      </categories>
      <tags>
        <tag>项目流程</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2022/08/07/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="查询-日志"><a href="#查询-日志" class="headerlink" title="查询/日志"></a>查询/日志</h3><ul>
<li>分析 TIME_WAIT<br><code>netstat -natp | grep &quot;TIME_WAIT&quot; | awk &#39;&#123;print $5&#125;&#39; | sort | uniq -c | sort -t &#39; &#39; -k 1 -nr</code>  </li>
<li><p>分析某列倒排<br><code>cat tcp_up_in.log | awk -v FS=&quot;|&quot; -v oneHourMill=3600000 &#39;&#123;group[int($4/(oneHourMill))*(oneHourMill)]++&#125;;END&#123;for(i in group)&#123;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,i/1000),group[i]&#125;&#125;&#39; | sort -t &#39; &#39; -k 3 -nr</code></p>
</li>
<li><p>awk</p>
</li>
<li>sed</li>
<li>grep</li>
<li>cut</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>日志查询</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>工作提效</title>
    <url>/2022/08/06/%E5%B7%A5%E4%BD%9C%E6%8F%90%E6%95%88/</url>
    <content><![CDATA[<h2 id="MAC工具"><a href="#MAC工具" class="headerlink" title="MAC工具"></a>MAC工具</h2><h3 id="clipy"><a href="#clipy" class="headerlink" title="clipy"></a>clipy</h3><p>剪贴板工具</p>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><h5 id="禁用Spotlight-让command-空格键为Alfred的hotkey"><a href="#禁用Spotlight-让command-空格键为Alfred的hotkey" class="headerlink" title="禁用Spotlight, 让command+空格键为Alfred的hotkey"></a>禁用Spotlight, 让command+空格键为Alfred的hotkey</h5><p>偏好设置==》键盘 ==》快捷键==》聚焦 ==》显示“聚焦”搜索  去掉了显示聚焦小√，那么Spotlight就禁止了<br>Alfred 中设置 command+空格键 为hotkey </p>
<h5 id="Clipboard-History"><a href="#Clipboard-History" class="headerlink" title="Clipboard History"></a>Clipboard History</h5><p>设置的快捷键为 control + command + x<br>Alfred无法自动粘贴问题: 虽然在“Advanced” 中勾选了 Pasting: Auto-paste on return<br>还需要添加辅助功能的权限, 系统偏好设置 ==》 安全性与隐私 ==》 辅助功能  给Alfred勾选添加权限才行</p>
<h5 id="alfred-集成idea"><a href="#alfred-集成idea" class="headerlink" title="alfred 集成idea"></a>alfred 集成idea</h5><ul>
<li><code>npm install -g --loglevel verbose @bchatard/alfred-jetbrains</code> 安装idea插件</li>
<li>初始化idea的脚本, idea ==》Tools ==》Create Command-line Launcher </li>
<li>回到Alfred, 点击到Workflows可以看到已经有了, 输入 idea + project 就可以愉快玩耍了</li>
</ul>
<h3 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h3><p>抓包工具</p>
<h3 id="omnigraffle"><a href="#omnigraffle" class="headerlink" title="omnigraffle"></a>omnigraffle</h3><p>画图工具,自由度很大, 架构图、流程图、时序图等等, 个人感觉比processon灵活度更高</p>
<h3 id="keynote"><a href="#keynote" class="headerlink" title="keynote"></a>keynote</h3><p>不错的工具, 可以用来画各种图, 很不错的工具</p>
<h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>编辑器, 关于vscode配置已通过sync插件同步到github</p>
<h5 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h5><ul>
<li>common + shift + p 查找、运行命令</li>
<li>批量选择所有首列或者最后一列<br>shift + alt(optionl) + command + 左右指向键</li>
<li>批量选择，每行末尾出现光标<br>shift + alt + i ==》 改成command + shift + l 同sublimetext</li>
<li>批量选择相同字符<br>fn + f2 + common ==》command + control + g 同sublimetext</li>
<li>分屏<br>common + \ 分一个屏，common + \ + 3 分三个屏</li>
<li>关闭左侧活动栏<br>scp中，sidebar 关闭</li>
<li>common + p 搜索文件</li>
<li>运行快捷键，改成了 command + b，运行python、js等，同sublimetext,</li>
<li>control + R ==》改成了 comman + control + p   切换workspace，同sublimetext</li>
<li>control + w 选择切换窗口</li>
<li>control + U撤销操作</li>
<li>control + z 回退</li>
<li>alt + shift + f 格式化代码</li>
<li>shift + command + e 展示explorer</li>
<li></li>
<li>command + control + t 在终端打开当前文件夹</li>
<li>command + shift +n 打开新窗口</li>
<li>删除重复的行, <code>common + shift + p</code> ==》 <code>&gt;Delete Duplicate Lines</code> 很好用的命令</li>
</ul>
<h5 id="工作区快捷键"><a href="#工作区快捷键" class="headerlink" title="工作区快捷键"></a>工作区快捷键</h5><ul>
<li>显示/隐藏控制台 ，也可通过scp，输入panel<br>command + j </li>
<li>创建多个窗口<br>command + \ + fn ==》alt + command + 2 同sublimetext</li>
<li>聚焦到第 1、第 2 个窗口<br>command + 1、2</li>
<li>重新新建一个文件<br>command + n </li>
<li>关闭当前文件<br>command + w</li>
</ul>
<h5 id="写代码快捷键"><a href="#写代码快捷键" class="headerlink" title="写代码快捷键"></a>写代码快捷键</h5><ul>
<li>fn + f5 调试代码</li>
<li>fn + f12 查看方法在哪里被调用</li>
<li>control + +/-回到鼠标上次的位置</li>
<li>Command+ Option + [   折叠代码</li>
<li>Command + d 单词选中</li>
<li>Command + Shift+ o  文件中符号跳转(变量、方法等等)</li>
<li>Command + Alt + Up / Down  </li>
<li>F2 + fn 重命名</li>
<li>Shift + Option  块选择</li>
<li>Shift + Option  你可以按住上面的快捷键，然后拖动鼠标，选择一个文本块，光标会被添加到选中的每一行中。</li>
</ul>
<h5 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h5><h5 id="跳转操作快捷键"><a href="#跳转操作快捷键" class="headerlink" title="跳转操作快捷键"></a>跳转操作快捷键</h5><h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><h5 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h5><h5 id="多光标编辑"><a href="#多光标编辑" class="headerlink" title="多光标编辑"></a>多光标编辑</h5><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><h5 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h5><blockquote>
<p><a href="https://mp.weixin.qq.com/s/LOfzmZffc6B1xh7JxKtroA">https://mp.weixin.qq.com/s/LOfzmZffc6B1xh7JxKtroA</a></p>
</blockquote>
<h3 id="sublimetext"><a href="#sublimetext" class="headerlink" title="sublimetext"></a>sublimetext</h3><p>编辑器  </p>
<h3 id="omnigraffle-1"><a href="#omnigraffle-1" class="headerlink" title="omnigraffle"></a>omnigraffle</h3><p>绘图软件</p>
<h3 id="xmind"><a href="#xmind" class="headerlink" title="xmind"></a>xmind</h3><p>思维导图</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>插件</tag>
        <tag>提效</tag>
      </tags>
  </entry>
  <entry>
    <title>关于近两次生产问题思考</title>
    <url>/2022/07/21/%E5%85%B3%E4%BA%8E%E8%BF%91%E4%B8%A4%E6%AC%A1%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>复盘下最近两次生产问题，我也是全程参与并定位到问题，问题比较棘手复杂隐晦，难于发现。</p>
<h3 id="更新缓存-2022-6-8"><a href="#更新缓存-2022-6-8" class="headerlink" title="更新缓存 2022/6/8"></a>更新缓存 2022/6/8</h3><ul>
<li>背景<br>由于上午已经出了一个故障，下午在做预发与生产的数据隔离，所以隔离工作需要在当天完成，记得大概晚上9点多，计划回家了，一个同事在说数据有丢失的问题，通过接口查询确实有问题，通过定位代码也没发现，喊我过去帮忙一起排查。了解大概情况后，从代码入手，看调用链路代码是否有过改动，看了几遍没发现什么问题，<br>根据可能出问题的点，一层层看下去，在conver层，会把DO转化成DTO，DTO构造器里会把查出来的feature转换成map（另外一个同事新加逻辑）,由于初始化时feature还是空，所以会new出来一个空featureMap对象，该接口的逻辑是先查缓存，缓存为空，再查数据库再更新缓存，这样会导致缓存里featureMap是空的，进而影响业务。熬了一个通宵修复数据和刷新数据。</li>
<li>总结<br>更新缓存时，保证更新值的正确性</li>
</ul>
<h3 id="fgc问题-2022-7-6"><a href="#fgc问题-2022-7-6" class="headerlink" title="fgc问题 2022/7/6"></a>fgc问题 2022/7/6</h3><ul>
<li><p>背景<br>同事在发布生产，监控告警出来频繁fgc，而且出现的时间和发布时间基本吻合，然后让发布的同事执行回滚，保证业务的进行。当时同事A 执行dump，分析出来只看到有超大的字节数组，并没有其他可用信息，同事A一直分析到晚上，但是还是一无所获得，吃完晚饭我也一起分析，确实无从下手，因为从dump里支配树上只能看到超大字节数组，里面的<br>对象也不是业务对象，从同事A反馈的信息是，应用启动的时候，此时老年代就被打满，出现fgc，给我的直觉不是业务代码导致的，应该是依赖导致，我从启动入手分析，根据支配树上超大的字节数组名称搜索tomcat启动日志可以直观的看到申请时看到new了一个和dump上一样大小的数组，而且有告警信息，接着日志下面有spring-boot-autoconfig的初始化bean的报错信息，由于<br>启动容器是阿里自研的tomcat，不会依赖spring-boot-autoconfig，这里有问题的，通过 <code>mvn dependency:tree</code>分析应用的依赖树，找到spring-boot-autoconfig，排除应用中所有的即可。解决问题时已经到凌晨2点多。</p>
</li>
<li><p>总结<br>解决问题的思路需要转变，有时并不能根据dump直接发现问题，细节很重要，例如应用启动时触发fgc，说明大概不是业务代码导致，进而从其他方面入手，例如依赖，由于本次发布引入了一些依赖包，这些都很可疑，依赖的问题真的很头疼啊。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生产问题</category>
      </categories>
      <tags>
        <tag>故障</tag>
        <tag>复盘</tag>
      </tags>
  </entry>
  <entry>
    <title>监控与预案</title>
    <url>/2022/06/19/%E7%9B%91%E6%8E%A7%E4%B8%8E%E9%A2%84%E6%A1%88/</url>
    <content><![CDATA[<p>监控与预案是根据强弱依赖梳理而来。业务链路要覆盖全，可以结合具体的故障场景，监控的合理性、有效性（阈值、错误码、大盘）也很重要，减少误报、错报。预案可以在发生故障时，可以快速止血，降低资损，减少对业务影响。</p>
<h4 id="强弱依赖"><a href="#强弱依赖" class="headerlink" title="强弱依赖"></a>强弱依赖</h4><img  src=http://www.plantuml.com/plantuml/svg/SoWkIImgoStCIybDBE3IKdYwPzVJFHkVx9lxOkiqBYqWVzsi9pixWIom54Jy_PvPJtRqFkrV_t9cx_DToz_lwNavO_UpQMkVx9Zrj6lXY_spNopiKO1gsGZNWgmUg1rJ2zYwZhPdyoQ0zJvRiEFf_kQNa_UzsBuU983a01WNuKujXPTpvs7J0LFYa0hq8SIN0000>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><img  src=http://www.plantuml.com/plantuml/svg/SoWkIImgoStCIybDBE3IKdW-U-AplkLSMa3MscdFfou5ie3CpRkVxvx_SihC5-lNFssTytJNLBWoBOMdIvO_dpq3IU39ZeRdkvP31DxlcVLoyhuNszV3k1rFTinwshKGnks4wDZLWwm3mdYoR-wBhTF0BW7pd_MqFrlG3bR_h6F2qwxvp_kWl8RTBzlxeMxP-6BBKZXlGi-pzLD0JA2YwKkHkKydha1m5OfAk1nIWI402GK0>
<p>系统监控不在上述业务监控范围内，系统监控指基础监控(cpu、内存、磁盘、load)、健康检查、jvm、消息、缓存等监控。</p>
<!-- 示例
```
 下跌：
（总量）最近两分钟与昨天同比持续下跌超过30%预警
（总量）最近1分钟求和>300

 下跌：
 (总量) 最近2分钟求和与昨天同比下跌超过30%
（总量）最近1分钟求和>300

 同比上涨：
（总量）最近两分钟与昨天同比持续上涨超过30%预警
（总量）最近1分钟求和>500

成功率下跌1：
(总量) 最近1分钟求和>500
(成功率)最近1分钟求和<99%预防警
（失败量）当前时间的值>30

成功率下跌2：
(成功率)最近2分钟持续<99%预防警

RT上涨：
（耗时）最近10分钟与昨天同比持续上涨超过10%预警
（耗时）最近30分钟与上周同比持续上涨超过10%

总量同比上周：
（总量）最近2分钟与上周同比持续下跌超过30%
```
 -->
<h4 id="预案"><a href="#预案" class="headerlink" title="预案"></a>预案</h4><img  src=http://www.plantuml.com/plantuml/svg/SoWkIImgoStCIybDBE3IKdYvgENPmWukBIs55ylQdi-UzdJNCX3dsPpEPrCxdZKi1t9WYfxid_joqnommDCzkvxksVXatzmNMwSXgzWrvSMonkTR5d0vf08jW5W20000>
<!-- ```
五要素：
1、执行时机
2、执行行动
3、执行影响
4、恢复时机
5、客服口径
``` -->
<!-- <img  src=http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNBCoKnELT2rKt3AJx9IS2mjoKZDAybCJYp9pCzJ24ejB4qjBk42oYde0jM05MDHLLoGdrUSoiLbewYhgu1cObu-K76HGY9sao6ARO3QyAk6sk2GcfS2T3K0> –&gt; ]]></content>
  </entry>
  <entry>
    <title>不辜负每一程的相遇</title>
    <url>/2021/12/17/%E4%B8%8D%E8%BE%9C%E8%B4%9F%E6%AF%8F%E4%B8%80%E7%A8%8B%E7%9A%84%E7%9B%B8%E9%81%87/</url>
    <content><![CDATA[<p>来曹操出行一转眼已经2年零3个月，记得入职时间是2019/8/26日。开始进来的时候首先面对生疏业务的困难，后来随着对业务的了解，才熟悉起来，这是每个新人需要有的痛苦过程。<br>在曹操的最大成长主要分成2块，第一是理解复杂的业务需求（业务），第二是设计复杂的业务系统（技术），要知道为什么这么做，要大胆提出自己的想法，思考怎么做会更好，全局眼界去看待整个需求。<br>在曹操2年多的时间，见证了订单量翻了3倍之多， 这也是在曹操很开心的一件事，曹操是一家有社会责任感、有社会价值的公司，相信未来一定会越来越好。<br>在曹操工作是件很开心的事情，曾经一起奋斗过的兄弟，熟悉的环境，今天是最后一天，不得不离开了，人生就是如此，此时心里感慨万千，最后想说不辜负每一程的相遇，感谢曹操，从此踏上新的一段职业旅程，希望大家都越来越好！</p>
<pre><code>                                                                             -- Lios 2021/12/17 15:37 滨江区物联网产业孵化器2号楼-B座 13F
</code></pre>]]></content>
      <categories>
        <category>Lios</category>
      </categories>
      <tags>
        <tag>恰同学少年</tag>
      </tags>
  </entry>
  <entry>
    <title>WHY-HOW-WHAT</title>
    <url>/2021/12/13/WHY-HOW-WHAT/</url>
    <content><![CDATA[<h4 id="什么是WHY-HOW-WHAT"><a href="#什么是WHY-HOW-WHAT" class="headerlink" title="什么是WHY-HOW-WHAT"></a>什么是WHY-HOW-WHAT</h4><p>黄金圈法(WHY-HOW-WHAT)则是西蒙·斯涅克在TED演讲时提出来阐释激励人心的领袖力的模型，下面有视频链接。 写这篇文章也是在提醒自己，在做事情前想清楚为什么做，如何做，做的是什么。<br><img src="Golden_circle.png" alt="Golden_circle.png"></p>
<h4 id="黄金环的提出与解释"><a href="#黄金环的提出与解释" class="headerlink" title="黄金环的提出与解释"></a>黄金环的提出与解释</h4><p>世界上大部分人都知道自己在做什么，其中一部分人知道自己怎么去做，这可以称作为自己的差异价值，但很少的人知道自己为什么要做这件事情，这是西蒙·斯涅克做出的术语解释。<br>因此，成功的伟大领袖就是极少数的人，他们是从里到外的生活方式，从为什么到怎么做再到是什么，与大多数人完全相反。<br>以大脑与黄金圈法则相比较，就很容易发现从里到外与从外到里的完全不一样的感觉，当人们能感觉到你的理念时，就会对你的产品抱有希望。</p>
<h4 id="黄金环的内容"><a href="#黄金环的内容" class="headerlink" title="黄金环的内容"></a>黄金环的内容</h4><p>黄金圆环的中心是”为什么why”, 第二个环是”怎么做how”，最外面的环是”是什么what”。为什么？怎么做？是什么？这个黄金圆环解释了为什么有的组织和领导者能够激发行动，而其他的不能。<br>作为结果，我们思考的方式，我们行动的方式，和我们沟通的方式，在这个黄金圆环上都是从外到内的。我们从最清楚的再到最模糊的。但是激励型的领导者和组织，不管他们大小规模，不管他们所在行业，都从内到外地思考，行动，和沟通。<br>在这个黄金圆环上当我们从外向内沟通时，我们可以让人们理解大量复杂的信息，比如特点，好处，事实，还有图表，但就是无法激发他们的行动。<br>当我们可以从内向外沟通时，我们就是在直接与大脑中控制行动的部分沟通，然后人们再理性地考虑我们所说和做的“怎样”和“什么”。这就是那些勇敢大胆决定的来源。人们不因你所做的而买单，他们因你所做的理由而买单，你的行动就证明了你的信念。</p>
<h4 id="黄金环的启示"><a href="#黄金环的启示" class="headerlink" title="黄金环的启示"></a>黄金环的启示</h4><ul>
<li>以终为始。思考问题从“为什么”开始，通过“挑战现状、挑战自我、战胜自<br>我”，从而实现创新与发展。</li>
<li>由内而外。从“为什么”找到新目标；再研究“怎么做”；然后通过“是什么”明确结果，落地实施。</li>
<li>循环提高。从“为什么”、“怎么做”到“是什么”，不断设定新目标、完善新思路、发展新成果，闭环优化、循环提高。</li>
</ul>
<blockquote>
<p>摘自</p>
</blockquote>
<p><a href="https://wiki.mbalib.com/wiki/%E9%BB%84%E9%87%91%E5%9C%86%E7%8E%AF">https://wiki.mbalib.com/wiki/%E9%BB%84%E9%87%91%E5%9C%86%E7%8E%AF</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E8%92%99%C2%B7%E6%96%AF%E6%B6%85%E5%85%8B">https://zh.wikipedia.org/wiki/%E8%A5%BF%E8%92%99%C2%B7%E6%96%AF%E6%B6%85%E5%85%8B</a><br><a href="https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action/transcript?language=zh-cn">https://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action/transcript?language=zh-cn</a><br><a href="https://zhuanlan.zhihu.com/p/60774962">https://zhuanlan.zhihu.com/p/60774962</a></p>
]]></content>
      <categories>
        <category>方法&amp;策略&amp;思想</category>
      </categories>
      <tags>
        <tag>WHY-HOW-WHAT</tag>
        <tag>黄金圈</tag>
        <tag>方法论</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title>技术图谱</title>
    <url>/2021/12/07/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p>以下梳理一些基础、通用的技术图谱，构建知识网络，会持续更新，仅供自己参考。<br><img src="技术图谱.png" alt="技术图谱.png"></p>
]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
      <tags>
        <tag>技术图谱</tag>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title>职业规划</title>
    <url>/2021/11/27/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>目前工作4年多，从事软件开发是我非常喜欢的职业，当时读大学时，主要想选择计算机专业和电子专业，对计算机太充满好奇了，最早接触电脑应该是读小学的时候，当时有电脑课，每周一节好像。后来接触就是去网吧了，不过只是玩游戏或者qq。<br>在这个行业，未来如何发展，每个人都有自己的目标，下面谈谈我的规划和想法，不构成任何建议和参考。</p>
<h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><!-- ![职业规划.png](职业规划.png =100x100) -->
<div align="center"><img src="职业规划.png" width = "500" height = "400"/></div>

<p>根据职级划分，未来1-3年的目标是专家，在这行业有自己深度的思考和沉淀，总结提炼出自己的一套“理论”，需不懈努力而实现。我认为有下面具体举措：<br>1、拓展知识广度<br>2、扩展知识<strong>深度</strong><br>3、<strong>业务架构、技术架构</strong><br>4、<strong>不设边界（提前思考业务未来发展、架构设计）；不断提问（为什么？存在什么问题？）、不断思考（更好方案？业界方案？业务价值？）；挑战权威</strong><br>5、全局业务视角</p>
<p>还有很长的路要走，还需不断努力，还需不断学习，披荆斩棘，路漫漫其修远兮，吾将上下而求索！</p>
<h4 id="核心竞争力"><a href="#核心竞争力" class="headerlink" title="核心竞争力"></a>核心竞争力</h4><p>不管在任何行业，拥有核心竞争力，就站在了行业的顶端，什么是核心竞争力呢，可以参考下知乎<a href="https://www.zhihu.com/question/403304892">核心竞争力是什么？如何培养核心竞争力？</a><br>我应该构建以下自己的核心竞争力：<br>1、架构能力<br>2、视野，全局、体系化思考能力<br>3、思考，给自己提问题，反哺业务，给业务带来价值<br>4、学习能力<br>5、沟通领导能力<br>6、价值点、堡垒、差异化、沉淀、方法论、自己的思考</p>
<h4 id="如何成功"><a href="#如何成功" class="headerlink" title="如何成功"></a>如何成功</h4><p>我不推崇、更不相信成功学，我认为作为普通人想成功，通过以下两种方式：<br>1、通过自己，努力（勤奋）+ 想法 + 机遇（运气）<br>2、通过大佬提拔，贵人相助（构建关系圈、人情社会）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><div align="center"><img src="1.png" width = "500" height = "400"/></div><br>说了这么多，职业规划，通过构建自己核心竞争力，在卷的时代，让自己朝着立于行业顶端而努力！</p>
]]></content>
      <categories>
        <category>Lios</category>
      </categories>
      <tags>
        <tag>恰同学少年</tag>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title>项目流程</title>
    <url>/2021/10/20/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>项目开展过程中，项目经理、产品、交互、UI、客户端、前端、后端、测试一起合作而完成，不是个体而独立完成，是由团队合作一起，尤其大型项目，可能会涉及到多条业务线、业务中台、大数据、风控、中间件等其他跨业务部门，结合工作中的项目开展，大概梳理项目的流程。</p>
<div align="center"><img src="Untitled-2021-10-20-2322.png" width = "500" height = "600"/></div>]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>项目流程</tag>
      </tags>
  </entry>
  <entry>
    <title>业务闭环思考</title>
    <url>/2021/10/15/%E4%BE%9B%E9%9C%80%E6%92%AE%E5%90%88%E3%80%81%E8%B7%83%E8%BF%81%E8%B7%83%E8%BF%81%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>刚接触到打车业务时，很好奇我们的整体业务链路是什么样的？系统如何圈司机？订单通过什么方式派给司机？订单的状态如何跃迁？等等一连串的疑问，困扰着我，当然产生了更加强烈的兴趣，驱使不断学习周边业务。站在目前我所在的业务模块，用图示简略的概括供需撮合、业务驱动、全局架构图，而形成业务闭环，更加细节的系统交互就不作多述。</p>
<h4 id="供需"><a href="#供需" class="headerlink" title="供需"></a>供需</h4><p><img src="1.png" alt=""><br>从该图发现，乘客发起用车，即生成了订单池，而运营的司机是资源池，需要通过撮合系统，司机接单，完成司机-订单的绑定。</p>
<h4 id="跃迁驱动"><a href="#跃迁驱动" class="headerlink" title="跃迁驱动"></a>跃迁驱动</h4><p><img src="2.png" alt=""><br>撮合完成后，业务的开展需司机驱动订单状态跃迁而展开，完成乘客用车流程，整个流程很复杂。</p>
<h4 id="全局架构"><a href="#全局架构" class="headerlink" title="全局架构"></a>全局架构</h4><p><img src="3.png" alt=""><br>全局架构图展现了各个大模块间的交互，整体架构为大中台-小前台。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>业务的开始与结束，在业务开展中最终会形成业务闭环（用车端发起–》用车端结束）。</p>
]]></content>
      <categories>
        <category>业务模型</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>业务模型</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>批量处理工具类</title>
    <url>/2021/10/05/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>业务开发中，时常会批量执行任务，例如批量同时调用4个http接口或者rpc接口，这类业务代码执行具有通用性，为了提高开发效率及简化代码，抽象一个通用的工具类，方便开发同学使用。<br>使用者只关心入参、具体任务执行、以及任务执行结果、线程池，并不关心如何批量处理:</p>
<center><img src="无标题-2021-09-24-0733.png" alt="无标题-2021-09-24-0733.png"></center>

<p>具体代码：</p>
<pre><code>public class BatchQuery &#123;

    /**
     * 并行且异步处理结果
     *
     * @param tasks    任务列表
     * @param p        参数
     * @param handle   具体业务处理
     * @param complete 完成处理逻辑
     * @param executor 线程池
     * @param &lt;T&gt;
     * @param &lt;P&gt;
     * @param &lt;R&gt;
     */
    public static &lt;T, P, R&gt; void asyncQueryHandleAsync(List&lt;T&gt; tasks, P p, Function&lt;T, P, R&gt; handle,
        BiConsumer&lt;R, Throwable&gt; complete, Executor executor) &#123;

        Objects.requireNonNull(p);

        Optional.ofNullable(tasks).ifPresent(task -&gt; &#123;

            val cfs = task.stream()
                .map(t -&gt;
                    CompletableFuture.supplyAsync(
                        () -&gt; handle.apply(t, p), executor).whenCompleteAsync(complete)
                ).toArray(CompletableFuture[]::new);

            //等待总任务完成
            CompletableFuture.allOf(cfs).join();
        &#125;);
    &#125;

    /**
     * 并行且同步处理结果
     *
     * @param tasks    任务列表
     * @param p        参数
     * @param handle   具体业务处理
     * @param complete 完成处理逻辑
     * @param executor 线程池
     * @param &lt;T&gt;
     * @param &lt;P&gt;
     * @param &lt;R&gt;
     */
    public static &lt;T, P, R&gt; void asyncQueryHandleSync(List&lt;T&gt; tasks, P p, Function&lt;T, P, R&gt; handle,
        BiConsumer&lt;R, Throwable&gt; complete, Executor executor) &#123;

        Objects.requireNonNull(p);

        Optional.ofNullable(tasks).ifPresent(task -&gt; &#123;

            val cfs = task.stream()
                .map(t -&gt;
                    CompletableFuture.supplyAsync(
                        () -&gt; handle.apply(t, p), executor).whenComplete(complete)
                ).toArray(CompletableFuture[]::new);

            //等待总任务完成
            CompletableFuture.allOf(cfs).join();
        &#125;);
    &#125;
&#125;


@FunctionalInterface
public interface Function&lt;T, P, R&gt; &#123;

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @param p
     * @return the function result
     */
    R apply(T t, P p);
&#125;


</code></pre><p>使用者需要传入具体的任务，以及共同参数P，P的存在具有合理性，往往任务会使用共同的参数，因此自定义了Function,以及具体的处理handle，handle里可以做差异化处理，任务执行结果会在complete中拿到，而且需要指定线程池。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈DDD</title>
    <url>/2021/08/14/%E8%B0%88%E8%B0%88DDD/</url>
    <content><![CDATA[<p>首先看一张图：<br><img src="DDD.png" alt="DDD.png"><br>  想想我们开发模式是不是大多面向数据驱动开发的，对于业务需求，首先是数据建模确定表关系及结构，到技术细节设计，然后进行业务的开发；而对于DDD，需求分析过后，进行领域分析和建模，然后再进行核心的业务逻辑及技术细节。DDD是把业务架构与技术架构纳入统一体系，通过通用的语言，开展业务需求设计，把项目的主要重点放在核心领域（core domain）和领域逻辑，以领域中的模型为基础，进行复杂的设计。让技术人员以及领域专家合作，以迭代方式来完善特定领域问题的概念模型。<br>  但我们在实际业务研发中，并不能为了DDD而DDD，那样会让简单的功能变的复杂，而是借鉴DDD的思想，进行业务与技术的融合设计。例如把业务系统划分为：</p>
<p><center><img src="xxx.png" alt="xxx.png"></center><br>在设计时，指导我们要清晰系统业务领域的边界，确认好具体的功能职责，而不能把无关的业务功能模块耦合，否则系统会变得异常的脆弱，最终不得不面临着系统的拆分与优化。<br>我所负责的业务系统将近10个，每一个业务系统的功能模块都是高聚合的，业务耦合度非常低，所以开展具体的业务需求研发时，不会因为领域边界的问题导致设计变得困难。</p>
<blockquote>
<p>参考</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88</a><br><a href="https://zq99299.github.io/note-book2/ddd/">https://zq99299.github.io/note-book2/ddd/</a><br><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">https://tech.meituan.com/2017/12/22/ddd-in-practice.html</a><br><a href="https://gitchat.csdn.net/columnTopic/5a584d86e286423809d4b105?utm_source=juhe">https://gitchat.csdn.net/columnTopic/5a584d86e286423809d4b105?utm_source=juhe</a></p>
<!-- [https://www.bilibili.com/read/cv11334682](https://www.bilibili.com/read/cv11334682) -->
<!-- [https://www.youtube.com/watch?v=b3Au9Iw8mFU](https://www.youtube.com/watch?v=b3Au9Iw8mFU) -->]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>生产应用频繁fullgc分析</title>
    <url>/2021/06/14/%E7%94%9F%E4%BA%A7%E5%BA%94%E7%94%A8%E9%A2%91%E7%B9%81fullgc%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>生产有应用频繁的fullgc，怀疑系统存在异常。</p>
<h4 id="jvm参数配置"><a href="#jvm参数配置" class="headerlink" title="jvm参数配置"></a>jvm参数配置</h4><p>首先大概文字介绍下系统的jvm参数配置：</p>
<pre><code>老年代CMS收集器
堆大小4G 年轻代2G 老年代2G 元空间256M
S0:S1:Eden=1:1:8，Eden=2G*0.8=1.6G
CMS GC阈值是70%，即2G*0.7=1.4G
也就是老年代达到1.4G时，年轻代满的话再往老年代晋升对象的时候，会发生FGC
年轻代默认晋升年龄是15次
</code></pre><p>再来温故下堆内存空间结构：<br><img src="无标题-2021-10-13-1059.png" alt="无标题-2021-10-13-1059.png"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>接下来，dump内存，这里注意一点，dump时切记让运维同学把dump的机器从集群中摘掉，否则dump时会造成JVM线程停顿，导致超时告警，影响业务。dump结果使用MAT(Eclipse Memory Analyzer)分析，具体截图就不展示了，从支配树上可以看出，某个缓存对象占用空间很大，个数非常多。从业务代码中查看，发现该对象是个本地缓存对象(Guava Cache)，缓存3分钟，而且是个配置项，按照不同业务线、城市，总共才500个，每个配置项比较小，怎么会突然占用这么大空间呢？<br>使用<code>jstat</code>命令查看系统的垃圾回收统计情况，发现YGC大概每10s一次，对于一个对象，即在年轻代中驻留约15*10=150s，再晋升到老年代，也就是在缓存有效期内，缓存对象足够晋升到老年代，缓存失效时，则会创新创建对象放入缓存。初步结论是：缓存过期时间过小导致对象晋升到老年代过快。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>根据该业务场景，设置缓存永不过期。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在使用本地缓存时，一定要注意缓存时间设置，否则会导致对象晋升到老年代过快而频繁导致FGC，根据实际的业务场景需要，可以把缓存设置永不过期（缓存的更新可以用定时任务去更新或者配置变更时通过消息方式去更新本地缓存），或者过期时间设大些。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>fullgc</tag>
      </tags>
  </entry>
  <entry>
    <title>Metaspace内存不足导致FGC问题排查</title>
    <url>/2020/08/27/Metaspace%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%AF%BC%E8%87%B4FGC%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<blockquote>
<h4 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h4></blockquote>
<p>清楚的记得是2020/7/25 14:34分左右，周六的下午，我还在公司苦逼的加班中，突然钉钉告警群里出现大量应用OP的dubbo超时调用、空指针异常，异常中间还有Metaspace元空间不足等异常:</p>
<pre><code>o.a.c.f.l.ListenerContainer 98 [ERROR] Listener \(org.apache.curator.framework.recipes.cache.PathChildrenCache$3@7edb7fd5) threw an exception

java.lang.OutOfMemoryError: Metaspace

错误类型：【oom】

告警内容：2020-07-25 15:05:05:113 d5f54db7c1ca49ab85b9f54cde234bd1 c.c.d.l.w.DriverTraceWriterUtil 39 [ERROR] driver trace writer to file fail,ex:[&#123;&#125;]

java.lang.RuntimeException: by java.lang.ClassFormatError: Metaspace

at com.xxx.xx
</code></pre><p>再紧接着，发现我们应用OP的服务器大量FullGC，先一台发生，很快第二台开始FGC，第10台…</p>
<pre><code>2020-07-25T15:10:50
应用:xxx
主机:xxx(
agentId: yyyy
发生FGC，共耗时:25012ms

2020-07-25T15:10:25
应用:xxxx
主机:xxxx
agentId: yyy
发生FGC，共耗时:4223ms
</code></pre><p>涉及到对OP系统调用的各系统都在反馈出现dubbo调用超时，都在报错中，我们通过pinpoint也发现应用频繁发生了FGC:</p>
<p><img src="1.png" alt="1.png"></p>
<p><img src="2.png" alt="2.png"></p>
<p>上面我们大概可以判断出来，是由于Metaspace元空间不足，出现内存溢出，导致jvm频繁触发full GC，为了保证业务正常，此时我们让运维紧急重启了服务器，通过重启服务器，业务逐渐恢复正常，元空间使用量也降下来了。在发生FGC时让运维dump内存了，后面会分析该文件。</p>
<blockquote>
<h4 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h4></blockquote>
<p>OP应用的生成JVM参数如下:</p>
<pre><code>/usr/local/java/bin/java 
-server  #指定JVM的启动模式是client模式还是server模式
-Xms4g   #初始化堆内存4G,堆内存最小值
-Xmx4g   #最大堆4g  
-Xmn2g   #年轻代2G，老年代大小=Xmx-Xmn
-Xss512k #每个线程的堆栈大小
-XX:MetaspaceSize=256m    #元空间的初始大小
-XX:MaxMetaspaceSize=512m #元空间最大值
-XX:-UseGCOverheadLimit   #预测是否要OOM了，提前抛出异常，防止OOM发生
-XX:+DisableExplicitGC    #禁用System.gc()
-XX:+UseConcMarkSweepGC   #指定老年代的收集算法使用CMS，会默认使用ParNew作为新生代收集器
-XX:+CMSParallelRemarkEnabled  #开启并行标记，减少停顿时间
-XX:+UseCMSCompactAtFullCollection  #FULL GC时对老年代进行压缩。CMS默认不会移动内存，因此容易产生碎片。增加该参数虽然会影响性能，但可以消除碎片
-XX:+UseFastAccessorMethods  #正确获取方法的调用计数，以便VM可以更好地识别代码中的热点
-XX:+UseCMSInitiatingOccupancyOnly  #指定HotSpot VM总是使用-XX:CMSInitiatingOccupancyFraction的值作为老年代使用率限制来启动CMS垃圾回收。如果没有使用-XX:+UseCMSInitiatingOccupancyOnly，那么HotSpot VM只是利用CMSInitiatingOccupancyFraction启s动第一次CMS垃圾回收，后面都是使用HotSpot VM自动计算出来的值
-XX:CMSInitiatingOccupancyFraction=70  #CMS垃圾收集器，老年代使用率达到70%时，触发CMS垃圾回收
-XX:LargePageSizeInBytes=128m  #堆内存大页的大小，大的内存分页可以增强 CPU 的内存寻址能力，从而提升系统的性能
-Djava.awt.headless=true 
-Djava.net.preferIPv4Stack=true 
-Ddubbo.application.qos.port=12881 
-javaagent:/usr/local/pinpoint/pinpoint-bootstrap-1.6.0.jar 
-Dpinpoint.agentId=driver-op-...
-Dpinpoint.applicationName=OP
-Djava.ext.dirs=/usr/local/springboot/OP/lib:/usr/local/java/jre/lib/ext 
-XX:+HeapDumpOnOutOfMemoryError  #当堆内存空间溢出时输出堆的内存快照,配合-XX:HeapDumpPath使用
-XX:HeapDumpPath=/home/admin     #当堆内存空间溢出时输出堆的内存快照输出目录
-cp /usr/local/springboot/OP/conf:.:/usr/local/java/lib:/usr/local/java/jre/lib -jar /usr/local/springboot/OP/OP.jar
</code></pre><p>由配置的JVM参数知道，指定了CMS为老年代的垃圾收集器，默认ParNew为新生代垃圾收集器，最大堆4g，老年代2g，年轻代2g，年轻中Eden区域和Survivor区域（From幸存区或To幸存区）的默认比例为8， 即设置survivor：eden=2:8(From:TO:eden=200MB:200MB:1600MB)，元空间初始化大小256MB，最大值512MB，如果老年代空间使用率达到70%，会触发CMS垃圾回收。由pinpoint上可以看出，元空间使用大概在770MB左右，超过了最大元空间值，导致元空间内存不足，触发FGC，这里有个疑问，明明配置的最大512MB，为什么使用了770MB，Metaspace还有一个区间是Klass Metaspace，由参数-XX:CompressedClassSpaceSize进行控制，JDK8的时候 Klass Metaspace默认是1G。</p>
<blockquote>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4></blockquote>
<ul>
<li><p>MAT分析<br>使用MAT打开dump文件，点开<code>Histogram</code>柱状图，选择<code>java.lang.Class</code>，右击选择<code>List objects</code>，选择<code>with incoming references(当前查看的对象，被外部引用)</code>，查看通过这个class创建的类信息：<br><img src="3.png" alt="3.png"><br><img src="4.png" alt="4.png"><br>发现创建了大量<code>Proxy</code>类，右击选中<code>Path To GC Roots</code>，选中<code>exclude all phantom/weak/soft etc.references</code>(排除虚引用/弱引用/软引用等的引用链，被虚引用/弱引用/软引用的对象可以直接被GC给回收，要看该对象否还存在Strong引用链，如果有，则说明存在内存泄漏)：<br><img src="5.png" alt="5.png"><br><img src="6.png" alt="6.png"><br>发现<code>Proxy</code>类被<code>org.springframework.boot.loader.LaunchedURLClassLoader</code>强引用，导致生成的<code>Proxy</code>类无法被卸载一直残留在MetaSpace区造成内存泄漏。</p>
</li>
<li><p>代码分析<br>上面分析出来生成<code>Proxy</code>类可能存在内存泄漏，代码中会发现用动态代理创建<code>Proxy</code>类对象并放入WeakReference中，每次GC时该对象都会被回收，会重复创建<code>Proxy</code>类对象，而且类加载器不会被回收，导致类不会被卸载。具体代码参考了dubbo代码<code>com.alibaba.dubbo.common.bytecode.Proxy#getProxy(java.lang.ClassLoader, java.lang.Class&lt;?&gt;...)</code>。</p>
</li>
<li><p>解决方法<br>上层业务做缓存处理，不会重复创建<code>Proxy</code>对象。上线观察优化前后5天内的元空间增长，的确效果比较明显。</p>
</li>
</ul>
<blockquote>
<p>参考文章</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/738b4f3bc44b">https://www.jianshu.com/p/738b4f3bc44b</a></li>
<li><a href="https://www.cnblogs.com/throwable/p/12216546.html">https://www.cnblogs.com/throwable/p/12216546.html</a></li>
<li><a href="https://blog.csdn.net/a15939557197/article/details/90635460?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param">https://blog.csdn.net/a15939557197/article/details/90635460?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>Metaspace</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>java基本数据类型所占字节</title>
    <url>/2020/05/29/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>bit数</th>
<th>取指范围</th>
<th>默认值</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1</td>
<td>8</td>
<td>-2^7 ~ 2^7-1</td>
<td>0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>16</td>
<td>-2^15 ~ 2^15-1</td>
<td>0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>32</td>
<td>-2^31 ~ 2^31-1</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>64</td>
<td>-2^63 ~ 2^63-1</td>
<td>0</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>32</td>
<td>-3.4e+38 ~ 3.4e+38</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>64</td>
<td>-1.7e+308 ~ 1.7e+308</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>1/8</td>
<td>1</td>
<td>true false</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>16</td>
<td>u0000~uFFFF（‘’~‘？’）</td>
<td>‘0’</td>
<td>Character</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li><a href="https://www.runoob.com/java/java-basic-datatypes.html">https://www.runoob.com/java/java-basic-datatypes.html</a></li>
<li><a href="https://www.cnblogs.com/gu-bin/p/9859103.html">https://www.cnblogs.com/gu-bin/p/9859103.html</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>内存溢出与内存泄漏</title>
    <url>/2020/05/29/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p><img src="yichu.png" alt="yichu.png"></p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/">https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/</a></li>
<li><a href="https://www.jianshu.com/p/2fdee831ed03">https://www.jianshu.com/p/2fdee831ed03</a></li>
<li><a href="https://www.cnblogs.com/lingzhigege/p/11110272.html">https://www.cnblogs.com/lingzhigege/p/11110272.html</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内存溢出</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>并行与并发</title>
    <url>/2020/05/28/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p><img src="bingx.png" alt="bingx.png"></p>
<p><img src="并行与并发.png" alt="并行与并发.png"></p>
<blockquote>
<p>引用</p>
</blockquote>
<ol>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/11161481.html">https://www.cnblogs.com/f-ck-need-u/p/11161481.html</a></li>
<li><a href="http://ifeve.com/parallel_and_con/">http://ifeve.com/parallel_and_con/</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并行与并发</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo_telnet自动化测试脚本</title>
    <url>/2020/05/28/dubbo-telnet%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>该脚本使用dubbo telnet方式（dubbo官网提供的dubbo python client目前只支持jsonrpc协议，目前环境不支持）,可以根据该脚本实现dev、test环境的接口自动化、压力测试，根据具体需求填补脚本即可。</p>
<pre><code>#!/usr/bin/python
# -*- coding:utf-8 -*-
import json
import telnetlib
import unittest
import time
import re


class Dubbo(telnetlib.Telnet):

    prompt = &#39;dubbo&gt;&#39;
    coding = &#39;utf-8&#39;

    def __init__(self, host=None, port=0):
        super().__init__(host, port)
        self.write(b&#39;\n&#39;)

    def command(self, flag, str_=&quot;&quot;):
        data = self.read_until(flag.encode())
        self.write(str_.encode() + b&quot;\n&quot;)
        return data

    def invoke(self, service_name, method_name, args):
        command_str = &quot;invoke &#123;0&#125;.&#123;1&#125;(&#123;2&#125;)&quot;.format(
            service_name, method_name, args)
        self.command(Dubbo.prompt, command_str)
        data = self.command(Dubbo.prompt, &quot;&quot;)
        data = json.loads(data.decode(
            Dubbo.coding, errors=&#39;ignore&#39;).split(&#39;\n&#39;)[0].strip())
        return data


class DcTest(unittest.TestCase):
    #setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用 #
    def setUp(self):
        &#39;&#39;&#39;
        33: Dubbo(&#39;301.57.79.01&#39;, 27075)
        44: Dubbo(&#39;106.12.59.915&#39;, 7075)
        dev: Dubbo(&#39;121.36.108.215&#39;, 6666)
        &#39;&#39;&#39;
        self.dubbo_conn = Dubbo(&#39;127.0.0.1&#39;, 6666)
        self.verificationErrors = []  # 脚本运行时，错误的信息将被打印到这个列表中#
        self.accept_next_alert = True  # 是否继续接受下一个警告#
    # 更改司机状态
    def test_update_driver_status(self):
        data = &#123;&quot;class&quot;:&quot;com.caocao.dc.api.dto.input.DriverStatusDTO&quot;,&quot;driverNo&quot;:1003019,&quot;status&quot;:1&#125;
        result = self.dubbo_conn.invoke(
            &quot;com.caocao.dc.api.app.DriverCenterApi&quot;, &quot;updateDriverStatus&quot;, data)
        print(result)
        time.sleep(2)
    # 司机开始服务
    def test_start_service(self):
        data = &#123;&quot;class&quot;: &quot;com.caocao.dc.api.dto.input.DriverStartServiceParam&quot;, &quot;driverNo&quot;: 1003019,&quot;lat&quot;: 30.206907552083333, &quot;lng&quot;: 120.22090521918403, &quot;orderLabel&quot;: 128, &quot;orderNo&quot;: 74602113541, &quot;bizType&quot;: 1&#125;
        result = self.dubbo_conn.invoke(
            &quot;com.caocao.dc.api.app.response.DriverOrderResponseApi&quot;, &quot;startService&quot;, data)
        print(result)
        time.sleep(2)
    def tearDown(self):
        &#39;&#39;&#39;
        tearDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出浏览器等。
        self.assertEqual([], self.verificationErrors) 是个难点，
        对前面verificationErrors方法获得的列表进行比较；如查verificationErrors的列表不为空，输出列表中的报错信息。
        &#39;&#39;&#39;
        self.assertEqual([], self.verificationErrors)

class DriverSupportTest(unittest.TestCase):
    #setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用 #
    def setUp(self):
        &#39;&#39;&#39;
        33: Dubbo(&#39;17.46.148.208&#39;, 7071)
        44: Dubbo(&#39;19.22.19.25&#39;, 7075)
        &#39;&#39;&#39;
        self.dubbo_conn = Dubbo(&#39;97.92.238.218&#39;, 7071)
        self.verificationErrors = []  # 脚本运行时，错误的信息将被打印到这个列表中#
        self.accept_next_alert = True  # 是否继续接受下一个警告#

    # 虚拟号AX预绑定
    def test_pre_bind_phone(self):
        data = &#123;&quot;class&quot;:&quot;com.caocao.driver.support.dto.phone.BindPhoneAxPreParam&quot;,&quot;customerPhone&quot;:&quot;4141241&quot;,&quot;orderNo&quot;:4141241,&quot;bizType&quot;:80,&quot;expireTime&quot;:1,&quot;areaCode&quot;:&quot;0571&quot;&#125;
        result = self.dubbo_conn.invoke(
            &quot;com.caocao.driver.support.api.VirPhoneAxApi&quot;, &quot;preBindPhone&quot;, data)
        print(result)
        time.sleep(2)
    def tearDown(self):
        &#39;&#39;&#39;
        tearDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出浏览器等。
        self.assertEqual([], self.verificationErrors) 是个难点，
        对前面verificationErrors方法获得的列表进行比较；如查verificationErrors的列表不为空，输出列表中的报错信息。
        &#39;&#39;&#39;
        self.assertEqual([], self.verificationErrors)

&#39;&#39;&#39;
driver-order
&#39;&#39;&#39;
class DriverOrderTest(unittest.TestCase):
    #setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用 #
    def setUp(self):
        &#39;&#39;&#39;
        33: Dubbo(&#39;101.159.59.142&#39;, 7071)
        44: Dubbo(&#39;106.2.9.25&#39;, 7071)
        &#39;&#39;&#39;
        self.dubbo_conn = Dubbo(&#39;111.32.49.515&#39;, 7071)
        self.verificationErrors = []  # 脚本运行时，错误的信息将被打印到这个列表中#
        self.accept_next_alert = True  # 是否继续接受下一个警告#
    # 订单流程校验
    def test_check_serve_flow(self):
        data = &#123;&quot;class&quot;: &quot;com.caocao.driver.order.param.ServeFlowCheckParam&quot;, &quot;bizType&quot;: 1, &quot;cityCode&quot;: &quot;0571&quot;,
                &quot;driverNo&quot;: 3500035951, &quot;driverType&quot;: 1, &quot;orderLabel&quot;: 0, &quot;orderNo&quot;: 8361805001163, &quot;orderType&quot;: 1, &quot;serveFlow&quot;: 1&#125;
        result = self.dubbo_conn.invoke(
            &quot;com.caocao.driver.order.api.DriverServeActionSupportApi&quot;, &quot;checkServeFlow&quot;, data)
        print(result)
        time.sleep(2)
    # 司机开始服务订单(实时单确认接单/预约单开始服务)
    def test_start_service(self):
        print(self.dubbo_conn)

    def tearDown(self):
        &#39;&#39;&#39;
        tearDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出浏览器等。
        self.assertEqual([], self.verificationErrors) 是个难点，
        对前面verificationErrors方法获得的列表进行比较；如查verificationErrors的列表不为空，输出列表中的报错信息。
        &#39;&#39;&#39;
        self.assertEqual([], self.verificationErrors)

&#39;&#39;&#39;
local
&#39;&#39;&#39;
class LocalTest(unittest.TestCase):
    #setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用 #
    def setUp(self):
        &#39;&#39;&#39;
        local1: Dubbo(&#39;127.0.0.1&#39;, 20880)
        &#39;&#39;&#39;
        self.dubbo_conn = Dubbo(&#39;127.0.0.1&#39;, 20880)
        self.verificationErrors = []  # 脚本运行时，错误的信息将被打印到这个列表中#
        self.accept_next_alert = True  # 是否继续接受下一个警告#
    # 测试sayHello
    def test_say_hello(self):
        for x in range(0,1):
            data = &#123;&quot;class&quot;:&quot;com.alibaba.dubbo.demo.BeanParam&quot;,&quot;name&quot;:&quot;lios&quot;,&quot;age&quot;:25+x&#125;
            result = self.dubbo_conn.invoke(
            &quot;com.alibaba.dubbo.demo.DemoService&quot;, &quot;hello&quot;, data)
            print(result)
            pass
        time.sleep(2)

    def test_2(self):
        print(self.dubbo_conn)

    def tearDown(self):
        &#39;&#39;&#39;
        tearDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出浏览器等。
        self.assertEqual([], self.verificationErrors) 是个难点，
        对前面verificationErrors方法获得的列表进行比较；如查verificationErrors的列表不为空，输出列表中的报错信息。
        &#39;&#39;&#39;
        self.assertEqual([], self.verificationErrors)


&#39;&#39;&#39;
dc suite
&#39;&#39;&#39;
def dc_suite():
    suite = unittest.TestSuite()
    suite.addTest(DcTest(&quot;test_update_driver_status&quot;))
    suite.addTest(DcTest(&quot;test_start_service&quot;))
    return suite
    pass

&#39;&#39;&#39;
driver-support suite
&#39;&#39;&#39;
def driver_support_suite():
    suite = unittest.TestSuite()
    suite.addTest(DriverSupportTest(&quot;test_pre_bind_phone&quot;))
    return suite
    pass

&#39;&#39;&#39;
driver-order suite
&#39;&#39;&#39;
def driver_order_suite():
    suite = unittest.TestSuite()
    suite.addTest(DriverOrderTest(&quot;test_check_serve_flow&quot;))
    suite.addTest(DriverOrderTest(&quot;test_start_service&quot;))
    return suite
    pass
&#39;&#39;&#39;
local suite
&#39;&#39;&#39;
def local_suite():
    suite = unittest.TestSuite()
    suite.addTest(LocalTest(&quot;test_say_hello&quot;))
    return suite
    pass

if __name__ == &quot;__main__&quot;:
    ## 指定suite套件
    unittest.main(defaultTest=&#39;dc_suite&#39;)

</code></pre>]]></content>
      <categories>
        <category>useful-scripts</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>java锁类型</title>
    <url>/2020/05/22/java%E9%94%81%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="锁类型.png" alt="锁类型.png"></p>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></li>
<li><a href="https://www.jianshu.com/p/a5155d000616">https://www.jianshu.com/p/a5155d000616</a></li>
<li><a href="https://segmentfault.com/a/1190000017766364">https://segmentfault.com/a/1190000017766364</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
        <tag>锁类型</tag>
      </tags>
  </entry>
  <entry>
    <title>不可不说的Java“锁”事</title>
    <url>/2020/05/21/%E4%B8%8D%E5%8F%AF%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E2%80%9C%E9%94%81%E2%80%9D%E4%BA%8B/</url>
    <content><![CDATA[<p><img src="javasuo.png" alt="javasuo.png"></p>
<blockquote>
<p>原文: <a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
        <tag>锁类型</tag>
      </tags>
  </entry>
  <entry>
    <title>记录xpath解析html的一个坑</title>
    <url>/2020/05/14/%E8%AE%B0%E5%BD%95xpath%E8%A7%A3%E6%9E%90html%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<p>使用xpath解析表格时，个别<code>td</code>标签内容为空，导致解析出来的数组列数有问题，进而在写入csv文件时，数据错位。<br>解决的办法用占位符填补空白:</p>
<pre><code>text.replace(r&#39;&lt;td style=&quot;white-space: pre-wrap;&quot;&gt;&lt;/td&gt;&#39;,
                               &#39;&lt;td style=&quot;white-space: pre-wrap;&quot;&gt;None&lt;/td&gt;&#39;)
</code></pre><blockquote>
<p><a href="https://lioswong.github.io/2020/05/10/%E8%A7%A3%E6%9E%90html%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC/">https://lioswong.github.io/2020/05/10/%E8%A7%A3%E6%9E%90html%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>xpath</category>
      </categories>
      <tags>
        <tag>xpath</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>解析html页面导出csv文件脚本</title>
    <url>/2020/05/10/%E8%A7%A3%E6%9E%90html%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>某些时候，需要从前端页面中批量获取数据，但是没有导出功能，可以通过脚本的方式处理即可。下面是一种情况，后端接口返回了html文件，但是该页面并不支持表格导出功能，如果需要获取数据，需要解析该html文件。根据实际情况灵活处理。</p>
<pre><code>#!/usr/bin/python
# -*- coding:utf-8 -*-
import json
import logging
import math
import time
import re
import requests
import sys
import csv
from lxml import etree


def exec(csrf_token, sql_content, dbase, dbconfig):
    headers = &#123;
        &quot;cookie&quot;: &quot;U8c4-4c6d-8ddd-e66171c338b6; remember_token=300|a7ec4cfa4d27ad8cc523de4a2e0aaf389c4995a1df6&quot;,
        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;,
    &#125;

    url = &quot;https://10.32.48.102/query/mysql&quot;

    data = &#123;&#39;csrf_token&#39;: csrf_token, &#39;sql_content&#39;: sql_content,
            &#39;dbase&#39;: dbase, &#39;dbconfig&#39;: dbconfig&#125;

    re = requests.post(url, data=data, headers=headers)

    # 深坑,可能td节点数据为空,需要特殊处理
    new_text = re.text.replace(r&#39;&lt;td style=&quot;white-space: pre-wrap;&quot;&gt;&lt;/td&gt;&#39;,
                               &#39;&lt;td style=&quot;white-space: pre-wrap;&quot;&gt;None&lt;/td&gt;&#39;)
    html = etree.HTML(new_text)

    thead = html.xpath(&quot;//div[@class=&#39;x_content sql_result&#39;]/table/thead&quot;)[0]

    th = thead.xpath(&quot;//tr/th/text()&quot;)

    filterStr = [&#39;数据库信息&#39;, &#39;名称&#39;, &#39;内容预览&#39;, &#39;是否开放&#39;, &#39;备注&#39;, &#39;操作&#39;]
    fileHeader = []

    for x in th:
        if x not in filterStr:
            fileHeader.append(x)
        pass
    writerToCSV(fileHeader, html)

def writerToCSV(fileHeader, html):
    csvFile = open(
        &quot;/Users/lioswong/LiosWong/sublimetext/python/脚本/draft/cc_sql_to_file.csv&quot;, &quot;w&quot;, encoding=&#39;utf-8-sig&#39;)
    writer = csv.writer(csvFile)
    writer.writerow(fileHeader)

    hLen = len(fileHeader)
    tdData = html.xpath(
        &quot;//div[@class=&#39;x_content sql_result&#39;]/table/tbody/tr/td/text()&quot;)
    col = 0
    d1 = []
    for i in tdData:
        if col == 0:
            d1 = [0 for i in range(hLen)]
        if col + 1 == hLen:
            d1[col] = i
            writer.writerow(d1)
            col = 0
            pass
        else:
            d1[col] = i
            col += 1
    csvFile.close()

exec(&#39;52afaftqywtqsga.EZf8Gw.UF4MSicxUuqJUKjhZ0ORBNMDSF8&#39;,
     &#39;SELECT phone from test_info where status=12 and type=1 order by id desc limit 100;&#39;,  &#39;test_center&#39;, &#39;生产主库只读&#39;)
</code></pre>]]></content>
      <categories>
        <category>useful-scripts</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>html</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka producer</title>
    <url>/2020/05/10/kafka-producer/</url>
    <content><![CDATA[<p>工作中会在开发环境中测试生产kafka消息，该脚本简单的实现了这一功能。</p>
<pre><code>#!/usr/bin/python
# -*- coding:utf-8 -*-
from pykafka import KafkaClient
import json
import logging
logging.basicConfig(level=logging.INFO)

client = KafkaClient(hosts=&quot;10.0.10.21:15386&quot;)  # 可接受多个Client,多个broker

# print(client.topics) # 查看所有topic

def sendDevKafkaMsg(topic, message):
    try:
        topic = client.topics[topic]  # 选择一个topic
        producer = topic.get_producer(delivery_reports=True)
        producer.produce(bytes(message, encoding=&quot;utf8&quot;))
        producer.get_delivery_report() # 返回之前发送失败的消息和结果
    except Exception as e:
        print(e)


sendDevKafkaMsg(&quot;TEST_TOPIC&quot;, json.dumps(data1))
</code></pre>]]></content>
      <categories>
        <category>useful-scripts</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>kafka-producer</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka consumer</title>
    <url>/2020/05/10/kafka-consumer/</url>
    <content><![CDATA[<p>工作中会在开发环境中测试消费其他系统的消息，该脚本简单的实现了这一功能。</p>
<pre><code>#!/usr/bin/python
# -*- coding:utf-8 -*-
from pykafka import KafkaClient
import json
import logging
# logging.basicConfig(level=logging.INFO)

client = KafkaClient(hosts=&quot;102.1.10.221:15386&quot;)  # 可接受多个Client,多个broker

# print(client.topics) # 查看所有topic

def receiveMsg(topics):
    topic = client.topics[topics]  # 选择一个topic
    consumer = topic.get_simple_consumer(consumer_group = &#39;dev26-dc&#39;,reset_offset_on_start=False)
    partitions = topic.partitions
    offset_list = consumer.held_offsets
    print(&quot;当前消费者分区offset情况&#123;&#125;&quot;.format(offset_list))  # 消费者拥有的分区offset的情况
    consumer.reset_offsets([(partitions[0], 0)])  # 设置offset
    msg = consumer.consume()
    for i in range(0,10):
        print(&quot;消费 :&#123;&#125;&quot;.format(msg.value.decode()))
        pass
    pass

receiveMsg(&quot;TEST_NOTIFY&quot;)
</code></pre>]]></content>
      <categories>
        <category>useful-scripts</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>kafka-consumer</tag>
      </tags>
  </entry>
  <entry>
    <title>生成海量csv文件数据脚本</title>
    <url>/2020/05/10/%E7%94%9F%E6%88%90%E6%B5%B7%E9%87%8Fcsv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>工作中可能会用到海量的测试数据，可以通过脚本的方式简单快速处理，下面通过python生成海量的csv数据文件，具体的列可以根据需求定制。</p>
<pre><code># -*- coding: utf-8 -*-
import requests
import sys
import re
import csv
import random
&#39;&#39;&#39;
从csv文件中读取数据
&#39;&#39;&#39;
def readCsv():
# 读取csv至字典
  csvFile = open(&quot;/Users/lioswong/LiosWong/sublimetext/python/脚本/bindPhone.csv&quot;, &quot;r&quot;)
  reader = csv.reader(csvFile)
  # 建立空字典
  result = &#123;&#125;
  for item in reader:
      # 忽略第一行
      if reader.line_num == 1:
        continue
      result[item[0]] = item[1]
  csvFile.close()
  print(result)

&#39;&#39;&#39;
往csv文件中写入数据
&#39;&#39;&#39;
def writerCsv():
  fileHeader = [&quot;customerPhone&quot;, &quot;orderNo&quot;,&quot;driverPhone&quot;,&quot;driverNo&quot;]
  csvFile = open(&quot;/Users/lioswong/LiosWong/sublimetext/python/脚本/test6.csv&quot;, &quot;w&quot;)
  writer = csv.writer(csvFile)
  d1 = [0]*4
  line = 1
  for i in range(0,1000001):
    if line==1:
        writer.writerow(fileHeader)
    d1[0]=random.choice([&#39;177&#39;,&#39;156&#39;,&#39;159&#39;,&#39;188&#39;,&#39;199&#39;,&#39;139&#39;,&#39;152&#39;,&#39;188&#39;,&#39;133&#39;,&#39;185&#39;,&#39;170&#39;,&#39;136&#39;,&#39;189&#39;,&#39;158&#39;,&#39;178&#39;,&#39;151&#39;])+&quot;&quot;.join(random.choice(&quot;0123456789&quot;) for i in range(8))
    d1[1]=&quot;&quot;.join(random.choice(&quot;0123456789&quot;) for i in range(10))
    d1[2]=random.choice([&#39;152&#39;,&#39;139&#39;,&#39;199&#39;,&#39;188&#39;,&#39;190&#39;,&#39;185&#39;,&#39;156&#39;,&#39;136&#39;,&#39;133&#39;,&#39;158&#39;,&#39;136&#39;,&#39;151&#39;,&#39;153&#39;])+&quot;&quot;.join(random.choice(&quot;0123456789&quot;) for i in range(8))
    d1[3]=&quot;&quot;.join(random.choice(&quot;0123456789&quot;) for i in range(8))
    # 写入的内容都是以列表的形式传入函数
    writer.writerow(d1)
    print(line)
    line+=1
  csvFile.close()


writerCsv()
# readCsv()
</code></pre>]]></content>
      <categories>
        <category>useful-scripts</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>filebeat、ELK环境搭建</title>
    <url>/2020/03/31/filebeat%E3%80%81ELK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5></blockquote>
<pre><code>   os: mac pro
   jdk: 1.8
   filebeat: 6.5.4-darwin-x86_64  
   elasticsearch: 6.5.4  
   logstash: 6.5.4  
   kibana: 6.5.4-darwin-x86_64
</code></pre><p>具体安装过程不做介绍，不过在下载具体的版本时，一定要保证版本号一致，否则会出现兼容性问题。</p>
<blockquote>
<h5 id="filebeat、elk交互图"><a href="#filebeat、elk交互图" class="headerlink" title="filebeat、elk交互图"></a>filebeat、elk交互图</h5></blockquote>
<p>关于filebeat、elk的系统交互如下图所示:<br><img src="one.jpg" alt="xxx"></p>
<blockquote>
<h5 id="filebeat配置"><a href="#filebeat配置" class="headerlink" title="filebeat配置"></a>filebeat配置</h5></blockquote>
<p>创建文件filebeat-trace.yml:</p>
<pre><code>filebeat.inputs:
- type: log
  paths:
    - /logs/*/driver-trace.log
  enabled: true
  encoding: utf-8
  document_type: driver_trace
  close_renamed: true
  close_removed: true
  scan_frequency: 1s
  max_bytes: 31457280
  harvester_buffer_size: 409600
  multiline:
    pattern: &#39;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&#39;
    negate: true
    match: after
max_procs: 1
output.logstash:
  hosts: [&quot;localhost:5044&quot;] # 配置实际环境的logstash地址
  #loadbalance: true (在配置时因为加了这个配置项导致filebeat一直不能向logstash输送日志,坑啊！)
</code></pre><p>启动服务:</p>
<pre><code>./filebeat -e -c filebeat-trace.yml
</code></pre><blockquote>
<h5 id="logstash配置"><a href="#logstash配置" class="headerlink" title="logstash配置"></a>logstash配置</h5></blockquote>
<p>创建文件trace-pipeline.conf:</p>
<pre><code>input &#123;
    beats &#123;
        port =&gt; &#39;5044&#39;
        type =&gt; &quot;driver_trace&quot;
        ssl =&gt; false
    &#125;
&#125;

filter &#123;
    if [type] == &quot;driver_trace&quot; &#123;
        grok &#123;
            patterns_dir =&gt; [&quot;/Users/lioswong/dev/software/elk/6.5.4/logstash-6.5.4/config/patterns&quot;]
            match =&gt; &#123;&quot;message&quot; =&gt; [&quot;%&#123;IP:client&#125;\|%&#123;NUMBER:actionTime:int&#125;\|%&#123;NUMBER:traceType:int&#125;\|%&#123;IDSTR:driverNo&#125;\|%&#123;NUMBER:action:int&#125;\|%&#123;NUMBER:actionScene:int&#125;\|%&#123;NUMBER:actionResult:int&#125;\|%&#123;GREEDYDATA:traceExtend&#125;\|%&#123;GREEDYDATA:traceId&#125;\|%&#123;GREEDYDATA:params&#125;\|%&#123;GREEDYDATA:results&#125;\|%&#123;NUMBER:headNode:int&#125;&quot;,&quot;%&#123;IP:client&#125;\|%&#123;NUMBER:actionTime:int&#125;\|%&#123;NUMBER:traceType:int&#125;\|%&#123;IDSTR:driverNo&#125;\|%&#123;NUMBER:action:int&#125;\|%&#123;NUMBER:actionScene:int&#125;\|%&#123;NUMBER:actionResult:int&#125;\|%&#123;GREEDYDATA:traceExtend&#125;\|%&#123;IDSTR:bizLine&#125;\|%&#123;IDSTR:orderNo&#125;\|%&#123;IDSTR:orderType&#125;\|%&#123;NUMBER:orderLabel:int&#125;\|%&#123;GREEDYDATA:traceId&#125;\|%&#123;GREEDYDATA:params&#125;\|%&#123;GREEDYDATA:results&#125;\|%&#123;NUMBER:headNode:int&#125;&quot;]&#125;
        &#125;
        mutate &#123;
            remove_field =&gt; [&quot;message&quot;]
        &#125;
    &#125;  
&#125;

output &#123;
    if [type] == &quot;driver_trace&quot; &#123;
        elasticsearch &#123;
            hosts =&gt; [&quot;localhost:9200&quot;]
            index =&gt; &quot;driver_trace_%&#123;+YYYY.MM.dd&#125;&quot;
            manage_template =&gt; true
            template_name =&gt; &quot;driver_trace&quot;
            template_overwrite =&gt; true
            document_type =&gt; &quot;driver_trace&quot;
            template =&gt; &quot;/Users/lioswong/dev/software/elk/6.5.4/logstash-6.5.4/config/templates/trace.json&quot;
        &#125;
        stdout &#123;
         codec =&gt; rubydebug
        &#125;

    &#125;
&#125;
</code></pre><p><code>/Users/lioswong/dev/software/elk/6.5.4/logstash-6.5.4/config/templates/trace.json</code>文件如下:</p>
<pre><code>&#123;
    &quot;template&quot;: &quot;driver_trace_*&quot;,
    &quot;settings&quot;: &#123;
        &quot;index.refresh_interval&quot;: &quot;5s&quot;
    &#125;,
    &quot;mappings&quot;: &#123;
        &quot;driver_trace&quot;: &#123;
            &quot;properties&quot;: &#123;
                &quot;client&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;actionTime&quot;: &#123;
                    &quot;type&quot;: &quot;long&quot;
                &#125;,
                 &quot;traceType&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;driverNo&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                 &quot;action&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                 &quot;actionScene&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;actionResult&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;traceExtend&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;
                &#125;,        
                &quot;bizLine&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;orderNo&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,  
                &quot;orderType&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;traceId&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;orderLabel&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot;
                &#125;,
                &quot;params&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;
                &#125;,
                &quot;results&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;
                &#125;,
                &quot;headNode&quot;: &#123;
                    &quot;type&quot;:&quot;keyword&quot;
                &#125;            
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>/Users/lioswong/dev/software/elk/6.5.4/logstash-6.5.4/config/patterns下的patterns文件内容:</p>
<pre><code>IDSTR [a-zA-Z0-9._-]*
</code></pre><p>启动服务：</p>
<pre><code>./logstash -f ../config/trace-pipeline.conf 
</code></pre><blockquote>
<h5 id="elasticsearch配置"><a href="#elasticsearch配置" class="headerlink" title="elasticsearch配置"></a>elasticsearch配置</h5></blockquote>
<p>编辑elasticsearch.yml:</p>
<pre><code>...
...
network.host: 127.0.0.1
#
# Set a custom port for HTTP:
#
http.port: 9200
...
...
</code></pre><p>启动服务:</p>
<pre><code>./elasticsearch  
</code></pre><blockquote>
<h5 id="配置kibana"><a href="#配置kibana" class="headerlink" title="配置kibana"></a>配置kibana</h5></blockquote>
<p>编辑kibana.yml:</p>
<pre><code>server.host: &quot;localhost&quot;
elasticsearch.url: &quot;http://localhost:9200&quot;
</code></pre><p>启动服务:ø</p>
<pre><code>./kibana
</code></pre><p>至此服务搭建完毕.</p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>elk</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
        <tag>Filebeat</tag>
      </tags>
  </entry>
  <entry>
    <title>idea debug断点失效</title>
    <url>/2020/03/11/idea-debug%E6%96%AD%E7%82%B9%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h5 id="环境"><a href="#环境" class="headerlink" title="环境:"></a>环境:</h5><blockquote>
<p>os: MacBook Pro<br>  idea: 2019<br>  app: dubbo(2.5.9) provider   </p>
</blockquote>
<hr>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li>该应用是springboot项目，dubbo服务提供者。本地服务启动后，通过telnet invoke 服务，debug模式下，无论如何都进不了断点，<br>检查多次确定断点没有问题，网上找了各种办法试了都无效，包括常用的idea重启、电脑重启。  </li>
<li>由于dubbo默认协议是通过暴露端口而提供服务，神奇的发现，当我把idea关闭后，通过<code>lsof -i tcp:端口号</code>查看该端口信息，竟然还可以看到！！！</li>
<li>把暴露的端口所占进程杀死后，再次重启服务，发现可以进入断点了！不清楚是idea的问题，还是dubbo的问题，后面有时间再研究。总之很神奇啊。</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这个问题困扰我2天时间，一头雾水，但是冷静下思考，还是会找到问题的破绽来。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>How to be a professional distributed system engineer</title>
    <url>/2020/03/08/How-to-be-a-professional-distributed-system-engineer/</url>
    <content><![CDATA[<p>If you want to get better at programming, there are two things you need to do:<br>Write codes and read books.<br>The following readings are my preferred references, please feel free to sink in them.  </p>
<hr>
<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><h5 id="Java-amp-Jvm"><a href="#Java-amp-Jvm" class="headerlink" title="Java &amp; Jvm"></a>Java &amp; Jvm</h5><p><a href="https://www.amazon.com/Core-Java-I--Fundamentals-9th/dp/0137081898/ref=sr_1_15?s=books&amp;ie=UTF8&amp;qid=1474871593&amp;sr=1-15&amp;keywords=thinking+in+java">Core Java Volume I &amp; Volume II</a><br><a href="https://www.amazon.com/Head-First-Java-Kathy-Sierra/dp/0596009208/ref=pd_sim_14_5?ie=UTF8&amp;pd_rd_i=0596009208&amp;pd_rd_r=SPRXGS2PZVAYA6XYPH7D&amp;pd_rd_w=2Hl6x&amp;pd_rd_wg=os22k&amp;psc=1&amp;refRID=SPRXGS2PZVAYA6XYPH7D">Head First Java</a><br><a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=pd_rhf_dp_s_cp_2ie=UTF8&amp;pd_rd_i=0321349601&amp;pd_rd_r=WX4CZQ2FAMC0N206EP3N&amp;pd_rd_w=APm7x&amp;pd_rd_wg=wv2aR&amp;psc=1&amp;refRID=WX4CZQ2FAMC0N206EP3N">Java Concurrency in Practice</a><br><a href="https://www.amazon.com/Programming-Concurrency-JVM-Mastering-Synchronization/dp/193435676X/ref=sr_1_5?ie=UTF8&amp;qid=1474944772&amp;sr=8-5&amp;keywords=jvm">Programming Concurrency on the JVM: Mastering Synchronization, STM, and Actors</a><br><a href="https://www.amazon.com/Java-Performance-Definitive-Scott-Oaks/dp/1449358454/ref=sr_1_1?ie=UTF8&amp;qid=1474944772&amp;sr=8-1&amp;keywords=jvm">Java Performance: The Definitive Guide</a><br><a href="https://www.amazon.com/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH">Effective Java 3rd Edition</a></p>
<!--
1. java核心技术
2. Head First Java
3. Java并发编程实践
4. Programming Concurrency on the JVM：Mastering Synchronization, STM, and Actors
5. Java性能权威手册
6. Effective Java 3rd Edition

-->
<h5 id="Refactor-amp-Design"><a href="#Refactor-amp-Design" class="headerlink" title="Refactor &amp; Design"></a>Refactor &amp; Design</h5><p><a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_rhf_dp_s_cp_4?ie=UTF8&amp;pd_rd_i=0132350882&amp;pd_rd_r=WX4CZQ2FAMC0N206EP3N&amp;pd_rd_w=APm7x&amp;pd_rd_wg=wv2aR&amp;psc=1&amp;refRID=WX4CZQ2FAMC0N206EP3N">Clean Code</a><br><a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=pd_sim_14_7?ie=UTF8&amp;pd_rd_i=0201485672&amp;pd_rd_r=E682SHZVPNGKEEGQZAEN&amp;pd_rd_w=vnwpP&amp;pd_rd_wg=L4EFb&amp;psc=1&amp;refRID=E682SHZVPNGKEEGQZAEN">Refactoring: Improving the Design of Existing Code</a><br><a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124/ref=pd_rhf_dp_s_cp_1?ie=UTF8&amp;pd_rd_i=0596007124&amp;pd_rd_r=WX4CZQ2FAMC0N206EP3N&amp;pd_rd_w=APm7x&amp;pd_rd_wg=wv2aR&amp;psc=1&amp;refRID=WX4CZQ2FAMC0N206EP3N">Head First Design Patterns</a><br><a href="https://www.amazon.com/Design-Essays-Computer-Scientist/dp/0201362988/ref=sr_1_1?ie=UTF8&amp;qid=1474952279&amp;sr=8-1&amp;keywords=The+Design+of+Design%3A+Essays+from+a+Computer+Scientist">The Design of Design: Essays from a Computer Scientist</a><br><a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=Pattern-Oriented+Software+Architecture">Pattern-Oriented Software Architecture</a><br><a href="https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/ref=sr_1_6?ie=UTF8&amp;qid=1474952693&amp;sr=8-6&amp;keywords=Pattern-Oriented+Software+Architecture">Patterns of Enterprise Application Architecture</a><br><a href="https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062/ref=sr_1_1?ie=UTF8&amp;qid=1474952990&amp;sr=8-1&amp;keywords=Applying+UML+and+Patterns">Applying UML and Patterns : An Introduction to Object-Oriented Analysis and Design and Iterative Development</a></p>
<!--
1. CleanCode-代码整洁之道
2. 重构：改善既有代码的设计
3. Head First 设计模式
4. 设计原本
5. 面向模式的软件架构
6. 企业应用架构模式
7. Applying UML and Patterns : An Introduction to Object-Oriented Analysis and Design and Iterative Development
-->
<h5 id="Software-management-amp-Agile-practice"><a href="#Software-management-amp-Agile-practice" class="headerlink" title="Software management &amp; Agile practice"></a>Software management &amp; Agile practice</h5><p><a href="https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=pd_sim_14_7?ie=UTF8&amp;pd_rd_i=020161622X&amp;pd_rd_r=SPRXGS2PZVAYA6XYPH7D&amp;pd_rd_w=2Hl6x&amp;pd_rd_wg=os22k&amp;psc=1&amp;refRID=SPRXGS2PZVAYA6XYPH7D">The Pragmatic Programmer: From Journeyman to Master</a><br><a href="https://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/ref=sr_1_1?ie=UTF8&amp;qid=1474952367&amp;sr=8-1&amp;keywords=The+Mythical+Man-Month%3A+Essays+on+Software+Engineering%2CAnniversary+Edition">The Mythical Man-Month: Essays on Software Engineering,Anniversary Edition</a><br><a href="https://www.amazon.com/Peopleware-Productive-Projects-Teams-3rd/dp/0321934113/ref=sr_1_1?ie=UTF8&amp;qid=1474952492&amp;sr=8-1&amp;keywords=Peopleware%3A+Productive+Projects+and+Teams">Peopleware: Productive Projects and Teams</a></p>
<!--
1. 程序员修炼之道：从小工到专家
2. 人月神话
3. 人件（第3版）
-->
<h5 id="Linux-internal"><a href="#Linux-internal" class="headerlink" title="Linux internal"></a>Linux internal</h5><p><a href="https://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1474871802&amp;sr=1-4&amp;keywords=linux&amp;refinements=p_72%3A1250221011">The Linux Programming Interface: A Linux and UNIX System Programming Handbook</a><br><a href="https://www.amazon.com/Internetworking-TCP-Vol-1-Principles-Architecture/dp/0130183806/ref=pd_sim_14_2?ie=UTF8&amp;pd_rd_i=0130183806&amp;pd_rd_r=R1SH3SQ0SYVFPJQXPNE5&amp;pd_rd_w=5p0ox&amp;pd_rd_wg=knykx&amp;psc=1&amp;refRID=R1SH3SQ0SYVFPJQXPNE5">Internetworking with TCP/IP</a><br><a href="https://www.amazon.com/Unix-Network-Programming-Sockets-Networking/dp/0131411551/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1474872220&amp;sr=1-1&amp;keywords=Unix+Network+Programming">Unix Network Programming</a></p>
<!--
1. linux/unix系统编程手册
2. TCP/IP详解,
3. unix 网络编程
-->
<h5 id="Computer-science"><a href="#Computer-science" class="headerlink" title="Computer science"></a>Computer science</h5><p><a href="https://www.amazon.com/Art-Computer-Programming-Vol-Fundamental/dp/0201896834/ref=sr_1_2?ie=UTF8&amp;qid=1474952215&amp;sr=8-2&amp;keywords=The+Art+of+Computer+Programming">The Art of Computer Programming</a><br><a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1475060034&amp;sr=8-1&amp;keywords=algorithm">Introduction to Algorithms</a></p>
<!--
1.  计算机程序设计艺术
2. 算法导论)
-->
<h5 id="Effective"><a href="#Effective" class="headerlink" title="Effective"></a>Effective</h5><p><a href="https://www.amazon.com/Habits-Highly-Effective-People-Powerful/dp/1451639619/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1476079772&amp;sr=1-1&amp;keywords=The+Seven+Habits+of+Highly+Effective+People">The Seven Habits of Highly Effective People</a><br><a href="https://www.amazon.com/Pomodoro-Technique-Illustrated-Pragmatic-Life/dp/1934356506/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1476080242&amp;sr=1-1&amp;keywords=Pomodoro+Technique+Illustrated">Pomodoro Technique Illustrated</a></p>
<!--
1. 成功人士的七个习惯
2. 番茄工作法图解:简单易行的时间管理方法
-->
<h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><hr>
<h5 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h5><p><a href="https://www.amazon.com/Systems-Performance-Enterprise-Brendan-Gregg/dp/0133390098/ref=sr_1_1?ie=UTF8&amp;qid=1474953097&amp;sr=8-1&amp;keywords=systems+performance">Systems Performance: Enterprise and the Cloud</a><br><a href="https://www.amazon.com/High-Performance-Browser-Networking-performance/dp/1449344763/ref=sr_1_1?ie=UTF8&amp;qid=1474953244&amp;sr=8-1&amp;keywords=High+performance+browser+networking">High performance browser networking</a><br><a href="https://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X/ref=sr_1_1?ie=UTF8&amp;qid=1474953535&amp;sr=8-1&amp;keywords=Computer+Systems%3A+A+Programmer%27s+Perspective">Computer Systems: A Programmer’s Perspective</a></p>
<!--
1. 系统性能：企业与云
2. web性能权威指南
3. 深入理解计算机系统
-->
<h5 id="Distributed-Related"><a href="#Distributed-Related" class="headerlink" title="Distributed Related"></a>Distributed Related</h5><p><a href="https://www.amazon.com/Programming-Distributed-Computing-Systems-Foundational/dp/0262018985/ref=sr_1_7?s=books&amp;ie=UTF8&amp;qid=1539845327&amp;sr=1-7&amp;keywords=distributed+system">Programming Distributed Computing Systems: A Foundational Approach</a><br><a href="https://www.amazon.com/Distributed-Systems-Concepts-Design-5th/dp/0132143011/ref=sr_1_6?s=books&amp;ie=UTF8&amp;qid=1539845327&amp;sr=1-6&amp;keywords=distributed+system">Distributed Systems: Concepts and Design (5th Edition)</a></p>
<!--
1. 分布式计算系统编程：一种基本方法
2. 分布式系统：概念与设计（第5版）
-->
<blockquote>
<h4 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h4></blockquote>
<p><a href="https://github.com/apache/rocketmq/issues/494">https://github.com/apache/rocketmq/issues/494</a></p>
]]></content>
      <categories>
        <category>技术书籍</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>Refactor</tag>
        <tag>Design</tag>
        <tag>linux</tag>
        <tag>Computer science</tag>
        <tag>Effective</tag>
        <tag>Performance</tag>
        <tag>Distributed Related</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo消费者启动报错</title>
    <url>/2020/03/01/dubbo%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><pre><code>os: MacBook Pro
dubbo: 2.7.5
java: 1.8
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>运行dubbo-demo-xml-consumer项目，控制台报以下错误:</p>
<pre><code>java.lang.IllegalStateException: There&#39;s no ApplicationConfig specified.
    at org.apache.dubbo.config.context.ConfigManager.lambda$getApplicationOrElseThrow$0(ConfigManager.java:88)
    at java.util.Optional.orElseThrow(Optional.java:290)
    at org.apache.dubbo.config.context.ConfigManager.getApplicationOrElseThrow(ConfigManager.java:88)
    at org.apache.dubbo.rpc.model.ApplicationModel.getApplicationConfig(ApplicationModel.java:100)
    at org.apache.dubbo.registry.integration.RegistryProtocol.destroy(RegistryProtocol.java:500)
    at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.destroy(ProtocolFilterWrapper.java:166)
    at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.destroy(ProtocolListenerWrapper.java:80)
    at org.apache.dubbo.config.DubboShutdownHook.destroyProtocols(DubboShutdownHook.java:140)
    at org.apache.dubbo.config.DubboShutdownHook.destroyAll(DubboShutdownHook.java:124)
    at org.apache.dubbo.config.bootstrap.DubboBootstrap.destroy(DubboBootstrap.java:1037)
    at org.apache.dubbo.config.bootstrap.DubboBootstrap.stop(DubboBootstrap.java:817)
    at org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.onContextClosedEvent(DubboBootstrapApplicationListener.java:65)
    at org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.onApplicationContextEvent(DubboBootstrapApplicationListener.java:55)
    at org.apache.dubbo.config.spring.context.OneTimeExecutionApplicationContextEventListener.onApplicationEvent(OneTimeExecutionApplicationContextEventListener.java:40)
    at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)
    at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)
    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)
    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:393)
    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:347)
    at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:991)
    at org.springframework.context.support.AbstractApplicationContext$2.run(AbstractApplicationContext.java:929)
</code></pre><p>根据打印出来的日志，方法调用栈为<br><img src="1.png" alt="1"><br>通过图可知<code>org.apache.dubbo.registry.integration.RegistryProtocol#destroy</code>该方法都会在<code>org.apache.dubbo.config.bootstrap.DubboBootstrap#destroy</code>中被调用，而且是通过Spring ContextClosedEvent事件(容器关闭时)、JVM钩子函数(JVM退出)触发。<br>报错的具体位置，在方法<code>org.apache.dubbo.config.context.ConfigManager#getApplicationOrElseThrow</code>中，通过断点分析<code>org.apache.dubbo.config.context.ConfigManager#getConfig(java.lang.String)</code>中获取配置信息时，<code>configsCache</code>为空，所以该方法的返回值为null，上层方法就报错了。</p>
<pre><code>protected &lt;C extends AbstractConfig&gt; C getConfig(String configType) throws IllegalStateException &#123;
        return read(() -&gt; &#123;
            Map&lt;String, C&gt; configsMap = (Map) configsCache.getOrDefault(configType, emptyMap());
            int size = configsMap.size();
            if (size &lt; 1) &#123;
//                throw new IllegalStateException(&quot;No such &quot; + configType.getName() + &quot; is found&quot;);
                return null;
            &#125; else if (size &gt; 1) &#123;
                logger.warn(&quot;Expected single matching of &quot; + configType + &quot;, but found &quot; + size + &quot; instances, will randomly pick the first one.&quot;);
            &#125;

            return configsMap.values().iterator().next();
        &#125;);
    &#125;
</code></pre><p>已经定位到报错的位置，奇怪的时，运行dubbo-demo-api-consumer项目时，却不报错，那具体原因是什么呢？</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><code>configsCache</code>什么时候会被删除呢，通过代码可发现，在<code>org.apache.dubbo.config.context.ConfigManager#clear</code>方法中会删除：</p>
<pre><code> public void clear() &#123;
        write(() -&gt; &#123;
            this.configsCache.clear();
        &#125;);
    &#125;
</code></pre><p>而该方法只会在<code>org.apache.dubbo.config.bootstrap.DubboBootstrap#clearConfigs</code>中被调用(除单元测试外)，该方法的调用栈:<br><img src="2.png" alt="2"><br>通过调用栈发现<code>org.apache.dubbo.config.context.ConfigManager#clear</code>也会在<code>org.apache.dubbo.config.bootstrap.DubboBootstrap#destroy</code>被调用，而<code>destroy</code>同样会被Spring ContextClosedEvent事件(容器关闭时)、JVM钩子函数(JVM退出)触发。到这里，猜想:<br>在dubbo-demo-xml-consumer中运行程序结束后，Spring容器关闭时，会触发ContextClosedEvent事件[A]，而JVM退出时也会触发钩子函数[B]，两个都会去销毁缓存的配置信息等，存在[A]销毁了配置信息，即上文中<code>configsCache</code>，而[B]此时从缓存中没有获取到配置就会报错，实际通过断点调试确实如此。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>虽然这个错误不会导致程序的结果，但是报错的确让人很疑惑，如果不深入分析很难找到问题所在。</p>
<blockquote>
<p>该问题已被解决，issues:<a href="https://github.com/apache/dubbo/issues/5813">https://github.com/apache/dubbo/issues/5813</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Kibana使用的Lucene查询语法</title>
    <url>/2019/12/08/Kibana%E4%BD%BF%E7%94%A8%E7%9A%84Lucene%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><img src="Lucene.png" alt="Lucene.png"></p>
<blockquote>
<p>参考</p>
</blockquote>
<p><a href="https://owelinux.github.io/2018/08/03/article11-linux-luncene/">https://owelinux.github.io/2018/08/03/article11-linux-luncene/</a></p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
        <tag>Kibana</tag>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis穿透、雪崩、击穿</title>
    <url>/2019/12/05/Redis%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<p><img src="Redis01.png" alt="Redis01.png"></p>
<blockquote>
<p>参考</p>
</blockquote>
<p><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath Helper插件使用</title>
    <url>/2019/12/04/XPath-Helper%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Chrome XPath Helper插件安装地址:<br><a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl">https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl</a></p>
<h4 id="需求1"><a href="#需求1" class="headerlink" title="需求1"></a>需求1</h4><p>获取表格第二列数据</p>
<h5 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h5><p>打开XPath Helper,并打开chrome检查元素,使用<code>select an element in the page to inspect it</code>选择想要获取的元素值,<br>然后在XPath Helper里输入表达式:</p>
<pre><code>//td[@style=&#39;white-space: pre-wrap;&#39;][2]
</code></pre><p>上面表达式的意思是获取标签为td且style为<code>white-space: pre-wrap;</code>的所有元素,<br>由于获取的是表格中第二列的数据,所以取数组中的第二个元素.结果如下:<br><img src="sim1.png" alt="sim1.png"></p>
]]></content>
      <categories>
        <category>xpath</category>
      </categories>
      <tags>
        <tag>xpath</tag>
        <tag>爬虫</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>NoClassDefFoundError</title>
    <url>/2019/12/03/NoClassDefFoundError/</url>
    <content><![CDATA[<p>线上发布时,报错如下:</p>
<pre><code>java.lang.NoClassDefFoundError: com/xxxxx/xx/ex/XXLogException
    at com.xxxxx.xx.log.DriverTraceAspect.doWriter(DriverTraceAspect.java:113)
    at com.xxxxx.xx.log.DriverTraceAspect.doTrace(DriverTraceAspect.java:100)
    at com.xxxxx.xx.log.DriverTraceAspect.doAround(DriverTraceAspect.java:74)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
    at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
</code></pre><p>首先来复习下Java中的异常结构图:<br><img src="error.png" alt="error.png"><br>Throwable有两个重要的子类:Exception和Error,二者都是Java异常处理的重要子类,各自都包含大量子类:<br><em>1. Exception</em><br>改异常是应用程序中可能的可预测、可恢复问题.Exception下又分为RuntimeException和非RuntimeException,RuntimeException异常指可能在Java 虚拟机正常运行期间抛出的异常的超类,RuntimException是非检查异常.除了RuntimeException及它的子类外的Exception异常为检查异常.<br><em>2. Error</em><br>表示运行应用程序中较严重问题.大多数错误与代码编写者执行的操作无关,而表示代码运行时JVM出现的问题,例如,如内存溢出、虚拟机错误、栈溢出等.<br>上面报错是<code>NoClassDefFoundError</code>异常,属于Error异常,导致该问题是由于应用A依赖B、C,B又依赖C,B中引用最新的C,而A中没有引用最新的C,把A中C改成最新的版本号即可.<br>该异常和ClassNotFoundException异常咋看起来很像,关于这两种异常比较可以参考文章<a href="https://www.jianshu.com/p/93d0db07d2e3">https://www.jianshu.com/p/93d0db07d2e3</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用本地图片</title>
    <url>/2019/11/28/hexo%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>步骤如下:<br><strong>1. post_asset_folder:true</strong><br>配置_config.yml里面的<code>post_asset_folder:true</code><br><strong>2. 安装hexo-asset-image</strong>  </p>
<pre><code>npm install hexo-asset-image --save
</code></pre><p><strong>3. 插入图片</strong><br>运行<code>hexo new &quot;Redis深度探险梳理&quot;</code>,<br>来生成md博文时,/source/_posts文件夹内除了<code>Redis深度探险梳理.md</code>文件还有一个同名的文件夹 <code>Redis深度探险梳理</code> ,把图片放入该文件夹,<br>然后在文章中引入:</p>
<pre><code>![Redis](Redis深度探险梳理/Redis.png)
</code></pre><p>本地运行发现是OK的,但是deploy到github上,发现图片不能展示了,然后看html文件发现是文件路径问题,然后改成:</p>
<pre><code>![Redis](Redis.png)
</code></pre><p>就好了.</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis深度历险梳理</title>
    <url>/2019/11/28/Redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p><img src="Redis.png" alt="Redis"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间传递值</title>
    <url>/2019/11/27/%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%80%BC/</url>
    <content><![CDATA[<center><img src="https://note.youdao.com/yws/api/personal/file/WEB021fbc18fce1d108894fe711779539be?method=download&amp;shareKey=ea89c6a8cd350af57d7b934c28578044" alt="https://note.youdao.com/yws/api/personal/file/WEB021fbc18fce1d108894fe711779539be?method=download&amp;shareKey=ea89c6a8cd350af57d7b934c28578044"></center>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>maven打包生成源码</title>
    <url>/2019/11/24/maven%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>开发中,项目A中的模块需要打包给项目B用,在调试B时,发现A中的包的源码下载失败,报错:</p>
<pre><code>上午10:37 Cannot download sources
Sources not found for:
com.xxxxxx.xx.base:xxxx-log:1.1.4.4-20191124.023005-49
</code></pre><p>开始怀疑是打的包问题,到远程仓库看了也没发现什么问题,idea检查也没问题,再去A中看maven配置,没有配置源码包插件,所以加入项目的配置即可:</p>
<pre><code>            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.0.0&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;attach-sources&lt;/id&gt;
                        &lt;phase&gt;verify&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre><p>往往我们打包都不会把源码打上去.如果想配置生成Javadoc包,加入插件即可:</p>
<pre><code>        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.10.4&lt;/version&gt;
            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;aggregate&gt;true&lt;/aggregate&gt;
                &lt;charset&gt;UTF-8&lt;/charset&gt;
                &lt;docencoding&gt;UTF-8&lt;/docencoding&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;attach-javadocs&lt;/id&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;jar&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;

</code></pre>]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch(6.5.4)踩坑</title>
    <url>/2019/11/15/elasticsearch-6-5-4-%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ol>
<li>mac pro</li>
<li>elk、filebeat版本6.5.4  </li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>本地在本地搭建elk+filebeat环境,elasticsearch启动报错如下：</p>
<pre><code>java.lang.IllegalArgumentException: Rejecting mapping update to [driver_trace_2019.11.15] as the final mapping would have more than 1 type: [driver_trace, doc]
    at org.elasticsearch.index.mapper.MapperService.internalMerge(MapperService.java:451) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.index.mapper.MapperService.internalMerge(MapperService.java:399) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.index.mapper.MapperService.merge(MapperService.java:331) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.metadata.MetaDataMappingService$PutMappingExecutor.applyRequest(MetaDataMappingService.java:313) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.metadata.MetaDataMappingService$PutMappingExecutor.execute(MetaDataMappingService.java:229) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.service.MasterService.executeTasks(MasterService.java:639) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.service.MasterService.calculateTaskOutputs(MasterService.java:268) ~[elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.service.MasterService.runTasks(MasterService.java:198) [elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.service.MasterService$Batcher.run(MasterService.java:133) [elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.service.TaskBatcher.runIfNotProcessed(TaskBatcher.java:150) [elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.cluster.service.TaskBatcher$BatchedTask.run(TaskBatcher.java:188) [elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingRunnable.run(ThreadContext.java:624) [elasticsearch-6.5.4.jar:6.5.4]
    at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.runAndClean(PrioritizedEsThreadPoolExecutor.java:244) [elasticsearch-6.5.4.jar:6.5.4]
</code></pre><p>原因是elastic search在6.x版本调整了,一个index只能存储一种type导致,即Logstash启动的时候会看到它使用的template是默认的,然后这样导入的数据后,自动创建了索引,默认的_type是doc,即:logstash在同步的时候会自动创建一个doc类型的index. </p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>参考<a href="https://blog.csdn.net/q18810146167/article/details/89339380">https://blog.csdn.net/q18810146167/article/details/89339380</a>这篇文章:<br><strong>1.删除原有的Elasticsearch indices</strong><br><img src="https://note.youdao.com/yws/api/personal/file/WEB1b3ebfdc85a39f18fc7d6a3e39fe084d?method=download&amp;shareKey=228b42ff8a6f4f6bf3fbd9c9f973e5ca" alt="https://note.youdao.com/yws/api/personal/file/WEB1b3ebfdc85a39f18fc7d6a3e39fe084d?method=download&amp;shareKey=228b42ff8a6f4f6bf3fbd9c9f973e5ca"><br><strong>2.新建Elasticsearch indices</strong><br><img src="https://note.youdao.com/yws/api/personal/file/WEB931f74297293eb06e5ae7be70f8271d2?method=download&amp;shareKey=ed8e634e35bc7a8101af35970c4858c9" alt="https://note.youdao.com/yws/api/personal/file/WEB931f74297293eb06e5ae7be70f8271d2?method=download&amp;shareKey=ed8e634e35bc7a8101af35970c4858c9"><br>创建的索引里默认mapping里面的type是doc,上面操作的含义可以理解为把所有的类型都映射为string,里面type为text 分词为ik_max_word.<br>具体创建的脚本如下:</p>
<pre><code>&#123;
  &quot;mappings&quot;:&#123;
    &quot;doc&quot;:&#123;
      &quot;dynamic_templates&quot;:[
       &#123;
        &quot;named_analyzers&quot;:&#123;
         &quot;match_mapping_type&quot;:&quot;string&quot;,
         &quot;match&quot;:&quot;*&quot;,
         &quot;mapping&quot;:&#123;
          &quot;type&quot;:&quot;text&quot;,
          &quot;analyzer&quot;:&quot;ik_max_word&quot;
         &#125;
        &#125;
       &#125;
      ]
    &#125;

  &#125;
&#125;
</code></pre><p>重新创建后,不再报错了.</p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>elk</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
        <tag>Filebeat</tag>
      </tags>
  </entry>
  <entry>
    <title>charles踩坑记录</title>
    <url>/2019/11/11/charles%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ol>
<li>charles v 4.2.8</li>
<li>MacBook Pro </li>
<li>手机一加6</li>
</ol>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>使用charles抓手机上的包一直抓不到,手机上已经装了charles证书,而且重复装了很多次,还是不行</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1a267a2d81820b6a79afd5d61aac7296?method=download&amp;shareKey=dd6a1f5644e0c958a2622ebb9877399c" alt="https://note.youdao.com/yws/api/personal/file/WEB1a267a2d81820b6a79afd5d61aac7296?method=download&amp;shareKey=dd6a1f5644e0c958a2622ebb9877399c"></p>
<p>检查Proxy Settings的配置没有发现什么问题,<br>再检查SSL Proxying Settings:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB2723e35e566573ed79da41131c8f2010?method=download&amp;shareKey=ef22df54ea67fd4331e5a4c56916a45f" alt="https://note.youdao.com/yws/api/personal/file/WEB2723e35e566573ed79da41131c8f2010?method=download&amp;shareKey=ef22df54ea67fd4331e5a4c56916a45f"><br>SSL Proxying Settings配置也没发现问题,后面再检查Access Controll Setting发现里面配置了可用的IP段,猜想应该是这里引起的,修改成指定所有的ipv4、ipv6段:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9cf0957faf9120d4e55b34e762c6618e?method=download&amp;shareKey=dd722afc63b9db082cd06067933f46bf" alt="https://note.youdao.com/yws/api/personal/file/WEB9cf0957faf9120d4e55b34e762c6618e?method=download&amp;shareKey=dd722afc63b9db082cd06067933f46bf"><br>然后就好了.</p>
<p>这个问题困扰了很久,之前一直怀疑是证书的问题,但是charles一直抓不到包,应该不是证书的问题,后面检查仔细charles配置发现了问题.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo中telnet命令使用</title>
    <url>/2019/10/24/Dubbo%E4%B8%ADtelnet%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来进行服务治理。  </p>
<h4 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h4><pre><code> status [-l]                      - Show status.
 shutdown [-t &lt;milliseconds&gt;]     - Shutdown Dubbo Application.
 pwd                              - Print working default service.
 trace [service] [method] [times] - Trace the service.
 help [command]                   - Show help.
 exit                             - Exit the telnet.
 invoke [service.]method(args)    - Invoke the service method.
 clear [lines]                    - Clear screen.
 count [service] [method] [times] - Count the service.
 ls [-l] [service]                - List services and methods.
 log level                        - Change log level or show log 
 select [index]                   - Select the index of the method you want to invoke.
 ps [-l] [port]                   - Print server ports and connections.
 cd [service]                     - Change default service.
</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>首先启动Dubbo提供者服务</li>
<li><code>telnet localhost 20880</code></li>
<li>输入<code>help</code>可以查看命令列表</li>
<li>使用<code>invoke</code>命令调用服务  <pre><code>dubbo&gt;invoke org.apache.dubbo.demo.DemoService.sayHello(&quot;lios&quot;)
Use default service org.apache.dubbo.demo.DemoService.
result: &quot;Hello lios, response from provider: null；null&quot;
elapsed: 10 ms.
</code></pre>由上可知,服务调用成功.</li>
</ul>
<h4 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h4><ul>
<li>ls<pre><code>ls: 显示服务列表
ls -l: 显示服务详细信息列表
ls XxxService: 显示服务的方法列表
ls -l XxxService: 显示服务的方法详细信息列表
</code></pre></li>
<li>ps<pre><code>ps: 显示服务端口列表
ps -l: 显示服务地址列表
ps 20880: 显示端口上的连接信息
ps -l 20880: 显示端口上的连接详细信息
</code></pre></li>
<li>cd<pre><code>cd XxxService: 改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数
cd /: 取消缺省服务
</code></pre></li>
<li>pwd<pre><code>pwd: 显示当前缺省服务
</code></pre></li>
<li>trace <pre><code>trace XxxService: 跟踪 1 次服务任意方法的调用情况
trace XxxService 10: 跟踪 10 次服务任意方法的调用情况
trace XxxService xxxMethod: 跟踪 1 次服务方法的调用情况
trace XxxService xxxMethod 10: 跟踪 10 次服务方法的调用情况
</code></pre></li>
<li>count<pre><code>count XxxService: 统计 1 次服务任意方法的调用情况
count XxxService 10: 统计 10 次服务任意方法的调用情况
count XxxService xxxMethod: 统计 1 次服务方法的调用情况
count XxxService xxxMethod 10: 统计 10 次服务方法的调用情况
</code></pre></li>
<li>invoke<pre><code>invoke XxxService.xxxMethod(&#123;&quot;prop&quot;: &quot;value&quot;&#125;): 调用服务的方法
invoke xxxMethod(&#123;&quot;prop&quot;: &quot;value&quot;&#125;): 调用服务的方法(自动查找包含此方法的服务)
</code></pre></li>
<li>select <pre><code>select 1: 当 invoke 命令匹配到多个方法时使用，根据提示列表选择需要调用的方法
</code></pre></li>
<li>status<pre><code>status: 显示汇总状态，该状态将汇总所有资源的状态，当全部 OK 时则显示 OK，只要有一个 ERROR 则显示 ERROR，只要有一个 WARN 则显示 WARN
status -l: 显示状态列表
</code></pre></li>
<li>log<pre><code>log debug: 修改 dubbo logger 的日志级别
log 100: 查看 file logger 的最后 100 字符的日志
</code></pre></li>
<li>help <pre><code>help: 显示 telnet 命帮助信息
help xxx: 显示xxx命令的详细帮助信息
</code></pre></li>
<li>clear<pre><code>clear: 清除屏幕上的内容
clear 100: 清除屏幕上的指定行数的内容
</code></pre></li>
<li>exit<pre><code>exit: 退出当前 telnet 命令行
</code></pre></li>
<li>shutdown<pre><code>shutdown: 关闭 dubbo 应用
shutdown -t 1000: 延迟 1000 毫秒关闭 dubbo 应用
</code></pre></li>
</ul>
<blockquote>
<p>参考</p>
</blockquote>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/references/telnet.html">http://dubbo.apache.org/zh-cn/docs/user/references/telnet.html</a></p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql毫秒数丢失问题</title>
    <url>/2019/10/17/mysql%E6%AF%AB%E7%A7%92%E6%95%B0%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>开发过程中,前端传入时间’2019-10-10 23:59:59.600’入库后变成’2019-10-11 00:00:00’,通过查询网上资料可知,mysql在<code>5.6.4</code>之前是不保存毫秒数的,在<code>5.6.4</code>之后的版本中毫秒数在低于500的时候会舍弃掉,大于等于500会进位,类似四舍五入.通过查当前的数据库版本在<code>5.6.4</code>之后:</p>
<pre><code>select version();
`version()`
5.7.20-log
</code></pre><p>所以解决的方法就是设置日期的毫秒数,避免进位:</p>
<pre><code>public static Date getDateInDay(Date date, int hour, int minute, int second)&#123;
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, hour);
        c.set(Calendar.MINUTE, minute);
        c.set(Calendar.SECOND, second);
        //设置毫秒数，避免产生进位
        c.set(Calendar.MILLISECOND,0);
        return c.getTime();
    &#125;
</code></pre><blockquote>
<p>参考文章</p>
</blockquote>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1483417">https://cloud.tencent.com/developer/article/1483417</a></li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>毫秒数丢失</tag>
      </tags>
  </entry>
  <entry>
    <title>arthas简单使用</title>
    <url>/2019/10/15/arthas%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Arthas 是Alibaba开源的Java诊断工具,深受开发者喜爱,<a href="https://github.com/alibaba/arthas">项目地址</a>.当你遇到以下类似问题而束手无策时,Arthas可以帮助你解决:  </p>
<ol>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？  </li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？  </li>
<li>遇到问题无法在线上 debug,难道只能通过加日志再重新发布吗？  </li>
<li>线上遇到某个用户的数据处理有问题,但线上同样无法 debug,线下无法重现！  </li>
<li>是否有一个全局视角来查看系统的运行状况？  </li>
<li>有什么办法可以监控到JVM的实时运行状态？<br>Arthas支持JDK 6+,支持Linux/Mac/Windows,采用命令行交互模式,同时提供丰富的 Tab 自动补全功能,进一步方便进行问题的定位和诊断.</li>
</ol>
<h4 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h4><p>官方推荐通过arthas-boot方式安装,下载<code>arthas-boot.jar</code>,然后用<code>java -jar</code>的方式启动：</p>
<pre><code>wget https://alibaba.github.io/arthas/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre><p>当然如果有其他的需求,可以使用全量安装、手动安装的方式,具体参考<a href="https://alibaba.github.io/arthas/install-detail.html">Arthas Install</a></p>
<h4 id="Simplecase"><a href="#Simplecase" class="headerlink" title="Simplecase"></a>Simplecase</h4><p>dubbo消费端调用服务时,会为接口生成一个代理类,这个代理类有什么信息呢,可以通过arthas可以反编译出Protocol、Cluster、Transporter、Wrapper等代理类,帮助理解源码.</p>
<ul>
<li>启动dubbo消费端服务</li>
<li>启动arthas服务<br><code>`</code><br>➜  arthas java -jar arthas-boot.jar<br>[INFO] arthas-boot version: 3.1.4<br>[INFO] Found existing java process, please choose one and hit RETURN.</li>
<li>[1]: 1089 zookeeper-dev-ZooInspector.jar<br>[2]: 982 org.jetbrains.kotlin.daemon.KotlinCompileDaemon<br>[3]: 1623 org.apache.dubbo.demo.provider.ApplicationProvider1<br>[4]: 1627 org.jetbrains.jps.cmdline.Launcher<br>[5]: 1628 org.apache.dubbo.demo.consumer.ApplicationConsumer</li>
</ul>
<p>  [7]: 637 org.jetbrains.idea.maven.server.RemoteMavenServer36<br>  [8]: 957 org.apache.zookeeper.server.quorum.QuorumPeerMain<br>  [9]: 958 org.apache.zookeeper.server.quorum.QuorumPeerMain<br>  [10]: 959 org.apache.zookeeper.server.quorum.QuorumPeerMain<br>5<br>[INFO] arthas home: /Users/lioswong/.arthas/lib/3.1.4/arthas<br>[INFO] Try to attach process 1628<br>[INFO] Attach process 1628 success.<br>[INFO] arthas-client connect 127.0.0.1 9998<br>  ,—.  ,——. ,——–.,–.  ,–.  ,—.   ,—.<br> /  O  \ |  .–. ‘’–.  .–’|  ‘–’  | /  O  \ ‘   .-‘<br>|  .-.  ||  ‘–’.’   |  |   |  .–.  ||  .-.  |<code>.</code>-.<br>|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-‘    |<br><code>--&#39;</code>–’<code>--&#39; &#39;--&#39;</code>–’   <code>--&#39;</code>–’<code>--&#39;</code>–’`—–’                          </p>
<p>wiki      <a href="https://alibaba.github.io/arthas">https://alibaba.github.io/arthas</a><br>tutorials <a href="https://alibaba.github.io/arthas/arthas-tutorials">https://alibaba.github.io/arthas/arthas-tutorials</a><br>version   3.1.4<br>pid       1628<br>time      2019-10-15 14:01:56    </p>
<pre><code>arthas启动时,会发现dubbo服务消费者进程是第5个,则输入5,再输入回车/enter,Arthas会attach到目标进程上,并输出日志.

* 根据``sc``命令搜索JVM已加载的类信息
</code></pre><p>[arthas@1628]$ sc *proxy0<br>org.apache.dubbo.common.bytecode.proxy0<br>Affect(row-cnt:1) cost in 22 ms.</p>
<pre><code>* 通过``jad``命令反编译  
</code></pre><p>[arthas@1628]$ jad org.apache.dubbo.common.bytecode.proxy0</p>
<p>ClassLoader:<br>+-sun.misc.Launcher$AppClassLoader@18b4aac2<br>  +-sun.misc.Launcher$ExtClassLoader@153f5a29                                                       </p>
<p>Location:<br>/Users/lioswong/dev/source/dubbo/dubbo-common/target/classes/                                       </p>
<p>/*</p>
<ul>
<li>Decompiled with CFR.</li>
<li></li>
<li>Could not load the following classes:</li>
<li>com.alibaba.dubbo.rpc.service.EchoService</li>
<li>org.apache.dubbo.common.bytecode.ClassGenerator</li>
<li>org.apache.dubbo.common.bytecode.ClassGenerator$DC<br>*/<br>package org.apache.dubbo.common.bytecode;</li>
</ul>
<p>import com.alibaba.dubbo.rpc.service.EchoService;<br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import org.apache.dubbo.common.bytecode.ClassGenerator;<br>import org.apache.dubbo.demo.DemoService;</p>
<p>public class proxy0<br>implements ClassGenerator.DC,<br>EchoService,<br>DemoService {<br>    public static Method[] methods;<br>    private InvocationHandler handler;</p>
<pre><code>@Override
public String sayHello(String string) &#123;
    Object[] arrobject = new Object[]&#123;string&#125;;
    Object object = this.handler.invoke(this, methods[0], arrobject);
    return (String)object;
&#125;

public Object $echo(Object object) &#123;
    Object[] arrobject = new Object[]&#123;object&#125;;
    Object object2 = this.handler.invoke(this, methods[1], arrobject);
    return object2;
&#125;

public proxy0() &#123;
&#125;

public proxy0(InvocationHandler invocationHandler) &#123;
    this.handler = invocationHandler;
&#125;
</code></pre><p>}</p>
<p>Affect(row-cnt:1) cost in 571 ms.<br><code>`</code><br>上面简单介绍arthas使用.</p>
<h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><p>可参考官方<a href="https://alibaba.github.io/arthas/advanced-use.html">中文文档</a></p>
]]></content>
      <categories>
        <category>arthas</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo服务引入</title>
    <url>/2019/10/06/Dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<p>关于Dubbo的SPI机制、服务暴露已有文章介绍,该文介绍Dubbo的服务引入.在Dubbo中,我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务,第二种方式是基于注册中心进行引用.服务直连的方式仅适合在调试或测试服务的场景下使用,不适合在线上环境使用.因此,本文我将重点分析通过注册中心引用服务的过程.<br>运行 <code>demo-dubbo --》 dubbo-demo-api --》 dubbo-demo-api-consumer</code> 中 <code>Application</code>:</p>
<pre><code>public class ApplicationConsumer &#123;
    public static void main(String[] args) &#123;
        ReferenceConfig&lt;DemoService&gt; reference = new ReferenceConfig&lt;&gt;();
        reference.setApplication(new ApplicationConfig(&quot;dubbo-demo-api-consumer&quot;));
        reference.setRegistry(new RegistryConfig(&quot;zookeeper://127.0.0.1:2181&quot;));
        reference.setInterface(DemoService.class);
        DemoService service = reference.get();
        String message = service.sayHello(&quot;dubbo&quot;);
        System.out.println(message);
    &#125;
&#125;
</code></pre><p>断点进入org.apache.dubbo.config.ReferenceConfig#get:</p>
<pre><code>public synchronized T get() &#123;
        checkAndUpdateSubConfigs();

        if (destroyed) &#123;
            throw new IllegalStateException(&quot;The invoker of ReferenceConfig(&quot; + url + &quot;) has already destroyed!&quot;);
        &#125;
        if (ref == null) &#123;
            init();
        &#125;
        return ref;
    &#125;
</code></pre><p>该方法中会判断接口的代理对象是否为空,如果为空,则初始化,进入org.apache.dubbo.config.ReferenceConfig#init,该方法中大部分代码是对属性检查、获取,最关键的是看代理对象的创建,进入方法org.apache.dubbo.config.ReferenceConfig#createProxy:</p>
<pre><code>    private T createProxy(Map&lt;String, String&gt; map) &#123;
        if (shouldJvmRefer(map)) &#123;  //本地引用
            ...
            ...
        &#125; else &#123;  // 远程引用
            urls.clear(); // reference retry init will add url to urls, lead to OOM
            // url 不为空，表明用户可能想进行点对点调用
            if (url != null &amp;&amp; url.length() &gt; 0) &#123; // user specified URL, could be peer-to-peer address, or register center&#39;s address.
                // 当需要配置多个 url 时，可用分号进行分割，这里会进行切分
                String[] us = SEMICOLON_SPLIT_PATTERN.split(url);
                if (us != null &amp;&amp; us.length &gt; 0) &#123;
                    ...
                    ...
                &#125;
            &#125; else &#123; // assemble URL from register center&#39;s configuration
                // if protocols not injvm checkRegistry
                if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol()))&#123;
                    checkRegistry();
                    // 加载注册中心 url
                    List&lt;URL&gt; us = loadRegistries(false);
                    ...
                    ...
                &#125;
            &#125;
            // 单个注册中心或服务提供者(服务直连，下同)
            if (urls.size() == 1) &#123;
                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));
            &#125; else &#123; // 多个注册中心或多个服务提供者，或者两者混合
                List&lt;Invoker&lt;?&gt;&gt; invokers = new ArrayList&lt;Invoker&lt;?&gt;&gt;();
                URL registryURL = null;
                for (URL url : urls) &#123;
                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));
                    if (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;
                        registryURL = url; // use last registry url
                    &#125;
                &#125;
                if (registryURL != null) &#123; // registry url is available
                    // use RegistryAwareCluster only when register&#39;s CLUSTER is available
                    URL u = registryURL.addParameter(CLUSTER_KEY, RegistryAwareCluster.NAME);
                    // The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker
                    invoker = CLUSTER.join(new StaticDirectory(u, invokers));
                &#125; else &#123; // not a registry url, must be direct invoke.
                    invoker = CLUSTER.join(new StaticDirectory(invokers));
                &#125;
            &#125;
        &#125;
        ...
        ...
        // create service proxy
        return (T) PROXY_FACTORY.getProxy(invoker);
    &#125;
</code></pre><h4 id="创建Invoker"><a href="#创建Invoker" class="headerlink" title="创建Invoker"></a>创建Invoker</h4><p>该方法首先判断是否为本地引用服务,否则远程,这里走的是远程引用服务,如果单个注册中心,则直接获取Invoker:</p>
<pre><code>invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));
</code></pre><p>REF_PROTOCOL对象是在运行时由Dubbo SPI机制创建的,这里会根据自适应扩展创建对象包装对象,结构如下:</p>
<pre><code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper
   org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper
       org.apache.dubbo.registry.integration.RegistryProtocol
</code></pre><p>前面文章也分析过,这里直接看RegistryProtocol中的refer:</p>
<pre><code> // 修改协议为dubbo
 url = URLBuilder.from(url)
                .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))
                .removeParameter(REGISTRY_KEY)
                .build();
        Registry registry = registryFactory.getRegistry(url);
        if (RegistryService.class.equals(type)) &#123;
            return proxyFactory.getInvoker((T) registry, type, url);
        &#125;

        // group=&quot;a,b&quot; or group=&quot;*&quot;
        Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
        String group = qs.get(GROUP_KEY);
        if (group != null &amp;&amp; group.length() &gt; 0) &#123;
            if ((COMMA_SPLIT_PATTERN.split(group)).length &gt; 1 || &quot;*&quot;.equals(group)) &#123;
                return doRefer(getMergeableCluster(), registry, type, url);
            &#125;
        &#125;
        return doRefer(cluster, registry, type, url);
</code></pre><p>继续看doRefer方法:</p>
<pre><code>        // 创建服务目录 RegistryDirectory 实例
        RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url);
        directory.setRegistry(registry);
        directory.setProtocol(protocol);
        // all attributes of REFER_KEY
        Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());
        // 生成服务消费者链接
        URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);
        if (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, true)) &#123;
            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));
            // 注册服务消费者，在 consumers 目录下新节点
            registry.register(directory.getRegisteredConsumerUrl());
        &#125;
        directory.buildRouterChain(subscribeUrl);
        // 订阅 providers、configurators、routers 等节点数据
        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,
                PROVIDERS_CATEGORY + &quot;,&quot; + CONFIGURATORS_CATEGORY + &quot;,&quot; + ROUTERS_CATEGORY));

        // 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个
        Invoker invoker = cluster.join(directory);
        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
        return invoker;
</code></pre><p>进入服务目录订阅节点信息方法org.apache.dubbo.registry.integration.RegistryDirectory#subscribe:</p>
<pre><code>public void subscribe(URL url) &#123;
        setConsumerUrl(url);
        CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);
        serviceConfigurationListener = new ReferenceConfigurationListener(this, url);
        registry.subscribe(url, this);
    &#125;
</code></pre><p>继续进入org.apache.dubbo.registry.support.FailbackRegistry#subscribe:</p>
<pre><code>public void subscribe(URL url, NotifyListener listener) &#123;
        super.subscribe(url, listener);
        removeFailedSubscribed(url, listener);
        // Sending a subscription request to the server side
        doSubscribe(url, listener);
        ...
        ...
&#125;
</code></pre><p>继续进入org.apache.dubbo.registry.zookeeper.ZookeeperRegistry#doSubscribe:</p>
<pre><code>...
...
notify(url, listener, urls);
</code></pre><p>以上代码很多都省略了,主要看notify方法,进入:</p>
<pre><code>protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;
        if (url == null) &#123;
            throw new IllegalArgumentException(&quot;notify url == null&quot;);
        &#125;
        if (listener == null) &#123;
            throw new IllegalArgumentException(&quot;notify listener == null&quot;);
        &#125;
        try &#123;
            doNotify(url, listener, urls);
        &#125; catch (Exception t) &#123;
            // Record a failed registration request to a failed list, retry regularly
            addFailedNotified(url, listener, urls);
            logger.error(&quot;Failed to notify for subscribe &quot; + url + &quot;, waiting for retry, cause: &quot; + t.getMessage(), t);
        &#125;
    &#125;
</code></pre><p>主要看org.apache.dubbo.registry.support.FailbackRegistry#doNotify方法:</p>
<pre><code> protected void doNotify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;
        super.notify(url, listener, urls);
    &#125;
</code></pre><p>继续进入org.apache.dubbo.registry.support.AbstractRegistry#notify(org.apache.dubbo.common.URL, org.apache.dubbo.registry.NotifyListener, java.util.List&lt;org.apache.dubbo.common.URL&gt;):</p>
<pre><code>...
...
for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;
            String category = entry.getKey();
            List&lt;URL&gt; categoryList = entry.getValue();
            categoryNotified.put(category, categoryList);
            listener.notify(categoryList);
            // We will update our cache file after each notification.
            // When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.
            saveProperties(url);
        &#125;
</code></pre><p>这里会遍历routers、configurators、providers节点,示范:</p>
<pre><code>routers=[empty://192.168.1.220/org.apache.dubbo.demo.DemoService?application=dubbo-demo-api-consumer&amp;category=routers&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;lazy=false&amp;methods=sayHello&amp;pid=77530&amp;retries=0&amp;sent=true&amp;side=consumer&amp;sticky=false&amp;timeout=3600&amp;timestamp=1572419547454]

configurators=[empty://192.168.1.220/org.apache.dubbo.demo.DemoService?application=dubbo-demo-api-consumer&amp;category=configurators&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;lazy=false&amp;methods=sayHello&amp;pid=77530&amp;retries=0&amp;sent=true&amp;side=consumer&amp;sticky=false&amp;timeout=3600&amp;timestamp=1572419547454]

providers=[dubbo://192.168.1.220:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=73959&amp;release=&amp;side=provider&amp;timeout=3600&amp;timestamp=1572403767806]
</code></pre><p>如果是providers节点时,则方法调用链入下:</p>
<pre><code>org.apache.dubbo.registry.integration.RegistryDirectory#notify
   --&gt;  org.apache.dubbo.registry.integration.RegistryDirectory#refreshOverrideAndInvoker
   --&gt;  org.apache.dubbo.registry.integration.RegistryDirectory#refreshInvoker
   --&gt;  org.apache.dubbo.registry.integration.RegistryDirectory#toInvokers
</code></pre><p>org.apache.dubbo.registry.integration.RegistryDirectory#toInvokers中会重新引用远程服务:</p>
<pre><code> ...
 ...
 ...
 // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = this.urlInvokerMap; // local reference
            Invoker&lt;T&gt; invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
            if (invoker == null) &#123; // Not in the cache, refer again
                try &#123;
                    boolean enabled = true;
                    if (url.hasParameter(DISABLED_KEY)) &#123;
                        enabled = !url.getParameter(DISABLED_KEY, false);
                    &#125; else &#123;
                        enabled = url.getParameter(ENABLED_KEY, true);
                    &#125;
                    if (enabled) &#123;
                        invoker = new InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);
                    &#125;
                &#125; catch (Throwable t) &#123;
                    logger.error(&quot;Failed to refer invoker for interface:&quot; + serviceType + &quot;,url:(&quot; + url + &quot;)&quot; + t.getMessage(), t);
                &#125;
...
...
...
</code></pre><p>回到org.apache.dubbo.registry.integration.RegistryProtocol#doRefer中,上面注释也很清楚,具体看:</p>
<pre><code>Invoker invoker = cluster.join(directory);
</code></pre><p>如果一个注册中心有多个服务提供者,这里需要将多个服务提供者合并为一个,cluster对象也是在运行时由Dubbo SPI生成的对象,会根据自适应创建包装类org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper,结构如下:</p>
<pre><code>org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper
  org.apache.dubbo.rpc.cluster.support.FailbackCluster
</code></pre><p>Dubbo提供了Failover Cluster(失败自动切换)、Failfast Cluster(快速失败)、Failsafe Cluster(失败安全)、Failback Cluster(失败自动恢复)、Forking Cluster(并行调用多个服务提供者)五种集群容错机制,默认为Failover,关于集群的这里不多作介绍,<br>继续进入MockClusterWrapper的join方法:</p>
<pre><code>public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException &#123;
        return new MockClusterInvoker&lt;T&gt;(directory,
                this.cluster.join(directory));
    &#125;
</code></pre><p>在创建MockClusterInvoker对象之前,会调用org.apache.dubbo.rpc.cluster.support.FailbackCluster#join:</p>
<pre><code> public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException &#123;
        return new FailbackClusterInvoker&lt;T&gt;(directory);
    &#125;
</code></pre><p>会直接创建对象FailbackClusterInvoker,然后返回,到这里Invoker的对象创建已经完成.</p>
<h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>回到org.apache.dubbo.config.ReferenceConfig#createProxy方法中,最后一段代码用于创建代理对象,同理PROXY_FACTORY对象也是通过Dubbo SPI创建,根据自适应实现,创建对象StubProxyFactoryWrapper,进入org.apache.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper#getProxy:</p>
<pre><code>T proxy = proxyFactory.getProxy(invoker);
...
...
</code></pre><p>进入org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getProxy:</p>
<pre><code> public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;
        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
    &#125;
</code></pre><p>上面使用了jdk的动态代理实现代理对象的创建,具体看InvokerInvocationHandler的代码:</p>
<pre><code>public class InvokerInvocationHandler implements InvocationHandler &#123;
    private static final Logger logger = LoggerFactory.getLogger(InvokerInvocationHandler.class);
    private final Invoker&lt;?&gt; invoker;

    public InvokerInvocationHandler(Invoker&lt;?&gt; handler) &#123;
        this.invoker = handler;
    &#125;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        String methodName = method.getName();
        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
        if (method.getDeclaringClass() == Object.class) &#123;
            return method.invoke(invoker, args);
        &#125;
        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;
            return invoker.toString();
        &#125;
        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;
            return invoker.hashCode();
        &#125;
        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123;
            return invoker.equals(args[0]);
        &#125;

        return invoker.invoke(new RpcInvocation(method, args)).recreate();
    &#125;
&#125;
</code></pre><p>invoke方法里会实现Invoker的invoke方法调用.到这里代理对象的创建已经完成.</p>
<blockquote>
<p>参考文章</p>
</blockquote>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo服务暴露过程解析</title>
    <url>/2019/09/29/Dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Dubbo SPI的暴露原理参考<a href="https://lioswong.github.io/2019/09/17/Dubbo-SPI%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">https://lioswong.github.io/2019/09/17/Dubbo-SPI%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a>,本文分析服务暴露过程,运行 <code>demo-dubbo --》 dubbo-demo-api --》 dubbo-demo-api-provider</code> 中 <code>Application</code>:</p>
<pre><code>public class Application &#123;
    public static void main(String[] args) throws Exception &#123;
        ServiceConfig&lt;DemoServiceImpl&gt; service = new ServiceConfig&lt;&gt;();
        service.setApplication(new ApplicationConfig(&quot;dubbo-demo-api-provider&quot;));
        service.setRegistry(new RegistryConfig(&quot;zookeeper://127.0.0.1:2181&quot;));
        service.setInterface(DemoService.class);
        service.setRef(new DemoServiceImpl());
        service.export();
        System.in.read();
    &#125;
&#125;
</code></pre><p>先创建对象 <code>ServiceConfig</code> ,设置 <code>ApplicationConfig</code> 、<code>RegistryConfig</code> 、接口 、实现类对象,接下来导出服务,断点进入 <code>org.apache.dubbo.config.ServiceConfig#export</code> :</p>
<pre><code> public synchronized void export() &#123;
        // 配置检查
        checkAndUpdateSubConfigs();
        // 是否导出
        if (!shouldExport()) &#123;
            return;
        &#125;
        // 是否延导出
        if (shouldDelay()) &#123;
            DELAY_EXPORT_EXECUTOR.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS);
        &#125; else &#123;
            // 直接暴露服务
            doExport();
        &#125;
    &#125;
</code></pre><p>首先配置检查(涉及检查和刷新,这里不多做介绍),根据属性配置 <code>export</code> 判断是否导出服务,根据 <code>delay</code> 判断是否延迟导出,比如某些应用需要预热处理,配置示例如下:</p>
<pre><code>&lt;dubbo:service interface=&quot;org.apache.dubbo.demo.DemoService&quot; export=&quot;true&quot; delay=&quot;5000&quot;/&gt;
</code></pre><p>进入 <code>org.apache.dubbo.config.ServiceConfig#doExport</code> 方法:</p>
<pre><code>protected synchronized void doExport() &#123;
        if (unexported) &#123;
            throw new IllegalStateException(&quot;The service &quot; + interfaceClass.getName() + &quot; has already unexported!&quot;);
        &#125;
        if (exported) &#123;
            return;
        &#125;
        exported = true;

        if (StringUtils.isEmpty(path)) &#123;
            path = interfaceName;
        &#125;
        // 导出
        doExportUrls();
    &#125;
</code></pre><p>上面的代码很简单,直接断点进入 <code>org.apache.dubbo.config.ServiceConfig#doExportUrls()</code> :</p>
<pre><code>    List&lt;URL&gt; registryURLs = loadRegistries(true);
    for (ProtocolConfig protocolConfig : protocols) &#123;
        String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + &quot;/&quot; + path).orElse(path), group, version);
        ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass);
        ApplicationModel.initProviderModel(pathKey, providerModel);
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    &#125;
</code></pre><p><code>org.apache.dubbo.config.AbstractInterfaceConfig#loadRegistries</code> 这个方法逻辑很简单,从 <code>RegistryConfig</code> 中获取协议配置属性然后封装成 <code>org.apache.dubbo.common.URL</code> ,返回协议列表,然后遍历列表,把服务以不同的协议以 <code>URL</code> 形式暴露,例如:</p>
<pre><code>registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;pid=7660&amp;registry=zookeeper&amp;timestamp=1569035160813
</code></pre><p>进入 <code>org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code> :</p>
<pre><code>private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;
        String name = protocolConfig.getName();
        // 默认协议dubbo
        if (StringUtils.isEmpty(name)) &#123;
            name = DUBBO;
        &#125;

        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        map.put(SIDE_KEY, PROVIDER_SIDE);

        // 获取属性配置放入map中
        appendRuntimeParameters(map);
        appendParameters(map, metrics);
        appendParameters(map, application);
        appendParameters(map, module);
        ...
        ...
        ...
        if (ProtocolUtils.isGeneric(generic)) &#123;
            map.put(GENERIC_KEY, generic);
            map.put(METHODS_KEY, ANY_VALUE);
        &#125; else &#123;
            // 获取revision
            String revision = Version.getVersion(interfaceClass, version);
            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;
                map.put(REVISION_KEY, revision);
            &#125;

            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();  // a
            if (methods.length == 0) &#123;
                logger.warn(&quot;No method found in service interface &quot; + interfaceClass.getName());
                map.put(METHODS_KEY, ANY_VALUE);
            &#125; else &#123;
                map.put(METHODS_KEY, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));
            &#125;
        &#125;
        if (!ConfigUtils.isEmpty(token)) &#123;
            if (ConfigUtils.isDefault(token)) &#123;
                map.put(TOKEN_KEY, UUID.randomUUID().toString());
            &#125; else &#123;
                map.put(TOKEN_KEY, token);
            &#125;
        &#125;
        // export service
        String host = this.findConfigedHosts(protocolConfig, registryURLs, map);
        // 获取服务暴露端口号
        Integer port = this.findConfigedPorts(protocolConfig, name, map);
        // 构建URL
        URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + &quot;/&quot; + path).orElse(path), map);

        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class) // b
                .hasExtension(url.getProtocol())) &#123; 
            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class) // c
                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
        &#125;

        String scope = url.getParameter(SCOPE_KEY);
        // don&#39;t export when none is configured
        if (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;  // d

            // export to local if the config is not remote (export to remote only when config is remote)
            if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123; // e
                exportLocal(url); 
            &#125;
            // export to remote if the config is not local (export to local only when config is local)
            if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123; // f
                if (CollectionUtils.isNotEmpty(registryURLs)) &#123;
                    for (URL registryURL : registryURLs) &#123;
                        //if protocol is only injvm ,not register
                        if (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;
                            continue;
                        &#125;
                        url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));
                        URL monitorUrl = loadMonitor(registryURL);
                        if (monitorUrl != null) &#123;
                            url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());
                        &#125;
                        if (logger.isInfoEnabled()) &#123;
                            if (url.getParameter(REGISTER_KEY, true)) &#123;
                                logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);
                            &#125; else &#123;
                                logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);
                            &#125;
                        &#125;

                        // For providers, this is used to enable custom proxy to generate invoker
                        String proxy = url.getParameter(PROXY_KEY);
                        if (StringUtils.isNotEmpty(proxy)) &#123;
                            registryURL = registryURL.addParameter(PROXY_KEY, proxy);
                        &#125;

                        Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));  // f
                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); // g
                        exporters.add(exporter); // h
                    &#125;
                &#125; else &#123;
                    if (logger.isInfoEnabled()) &#123;
                        logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);
                    &#125;
                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);
                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);
                    exporters.add(exporter);
                &#125;
                /**
                 * @since 2.7.0
                 * ServiceData Store
                 */
                MetadataReportService metadataReportService = null;
                if ((metadataReportService = getMetadataReportService()) != null) &#123;
                    metadataReportService.publishProvider(url);
                &#125;
            &#125;
        &#125;
        this.urls.add(url);
    &#125;
</code></pre><h4 id="构建包装类Wrapper"><a href="#构建包装类Wrapper" class="headerlink" title="构建包装类Wrapper"></a>构建包装类Wrapper</h4><p>这段代码比较长,首先把各个属性值放入到 <code>map</code> 中，断点到 <code>a</code> 处,进入 <code>org.apache.dubbo.common.bytecode.Wrapper#getWrapper</code> :</p>
<pre><code>public static Wrapper getWrapper(Class&lt;?&gt; c) &#123;
        while (ClassGenerator.isDynamicClass(c)) // can not wrapper on dynamic class.
        &#123;
            c = c.getSuperclass();
        &#125;

        if (c == Object.class) &#123;
            return OBJECT_WRAPPER;
        &#125;

        Wrapper ret = WRAPPER_MAP.get(c);
        if (ret == null) &#123;
            ret = makeWrapper(c);
            WRAPPER_MAP.put(c, ret);
        &#125;
        return ret;
    &#125;
</code></pre><p>首先从缓存中获取包装类 <code>Wrapper</code>,如果没有创建,进入 <code>org.apache.dubbo.common.bytecode.Wrapper#makeWrapper</code> :</p>
<pre><code>private static Wrapper makeWrapper(Class&lt;?&gt; c) &#123;
        if (c.isPrimitive()) &#123;
            throw new IllegalArgumentException(&quot;Can not create wrapper for primitive type: &quot; + c);
        &#125;
        String name = c.getName();
        ClassLoader cl = ClassUtils.getClassLoader(c);
        StringBuilder c1 = new StringBuilder(&quot;public void setPropertyValue(Object o, String n, Object v)&#123; &quot;);
        StringBuilder c2 = new StringBuilder(&quot;public Object getPropertyValue(Object o, String n)&#123; &quot;);
        StringBuilder c3 = new StringBuilder(&quot;public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws &quot; + InvocationTargetException.class.getName() + &quot;&#123; &quot;);
        ...
        ...
        ...
        ...
        try &#123;
            Class&lt;?&gt; wc = cc.toClass();
            // setup static field.
            wc.getField(&quot;pts&quot;).set(null, pts);
            wc.getField(&quot;pns&quot;).set(null, pts.keySet().toArray(new String[0]));
            wc.getField(&quot;mns&quot;).set(null, mns.toArray(new String[0]));
            wc.getField(&quot;dmns&quot;).set(null, dmns.toArray(new String[0]));
            int ix = 0;
            for (Method m : ms.values()) &#123;
                wc.getField(&quot;mts&quot; + ix++).set(null, m.getParameterTypes());
            &#125;
            return (Wrapper) wc.newInstance();
        &#125; catch (RuntimeException e) &#123;
            throw e;
        &#125; catch (Throwable e) &#123;
            throw new RuntimeException(e.getMessage(), e);
        &#125; finally &#123;
            cc.release();
            ms.clear();
            mns.clear();
            dmns.clear();
        &#125;
    &#125;
</code></pre><p>上面的代码不具体分析,通过javassist动态生成类 <code>class org.apache.dubbo.common.bytecode.Wrapper0</code> :</p>
<pre><code>public class org.apache.dubbo.common.bytecode.Wrapper0 extends Wrapper
&#123;
    public static String[] pns;
    public static java.util.Map pts;
    public static String[] mns;
    public static String[] dmns;
    public static Class[] mts0;
    public String[] getPropertyNames()
    &#123;
        return pns;
    &#125;
    public boolean hasProperty(String n)
    &#123;
        return pts.containsKey($1);
    &#125;
    public Class getPropertyType(String n)
    &#123;
        return (Class)pts.get($1);
    &#125;
    public String[] getMethodNames()
    &#123;
        return mns;
    &#125;
    public String[] getDeclaredMethodNames()
    &#123;
        return dmns;
    &#125;
    public void setPropertyValue(Object o, String n, Object v)
    &#123;
        org.apache.dubbo.demo.DemoService w;
        try
        &#123;
            w = ((org.apache.dubbo.demo.DemoService)$1);
        &#125;
        catch(Throwable e)
        &#123;
            throw new IllegalArgumentException(e);
        &#125;
        throw new org.apache.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; field or setter method in class org.apache.dubbo.demo.DemoService.&quot;);
    &#125;
    public Object getPropertyValue(Object o, String n)
    &#123;
        org.apache.dubbo.demo.DemoService w;
        try
        &#123;
            w = ((org.apache.dubbo.demo.DemoService)$1);
        &#125;
        catch(Throwable e)
        &#123;
            throw new IllegalArgumentException(e);
        &#125;
        throw new org.apache.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; field or setter method in class org.apache.dubbo.demo.DemoService.&quot;);
    &#125;
    // 根据方法名调用
    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException
    &#123;
        org.apache.dubbo.demo.DemoService w;
        try
        &#123;
            w = ((org.apache.dubbo.demo.DemoService)$1);
        &#125;
        catch(Throwable e)
        &#123;
            throw new IllegalArgumentException(e);
        &#125;
        try
        &#123;
            if( &quot;sayHello&quot;.equals( $2 )  &amp;&amp;  $3.length == 1 )
            &#123;
                return ($w)w.sayHello((java.lang.String)$4[0]);
            &#125;
        &#125;
        catch(Throwable e)
        &#123;
            throw new java.lang.reflect.InvocationTargetException(e);
        &#125;
        throw new org.apache.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot; + $2 + &quot;\&quot; in class org.apache.dubbo.demo.DemoService.&quot;);
    &#125;
&#125;
</code></pre><p>有上面可知,包装类 <code>Wrapper0</code> 的 <code>invokeMethod</code> 方法里会真正调用服务方法。</p>
<h4 id="本地暴露服务"><a href="#本地暴露服务" class="headerlink" title="本地暴露服务"></a>本地暴露服务</h4><p>回到 <code>org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code> 方法的 <code>a</code> 处,返回的方法数组只有一个元素 <code>sayHello</code>, <code>d</code> 处会根据 <code>scope</code> 判断是否暴露服务, <code>e</code> 处如果不是远程暴露服务则暴露到本地,进入 <code>org.apache.dubbo.config.ServiceConfig#exportLocal</code> :</p>
<pre><code>private void exportLocal(URL url) &#123;
    URL local = URLBuilder.from(url)
    .setProtocol(LOCAL_PROTOCOL)
    .setHost(LOCALHOST_VALUE)
    .setPort(0)
    .build();
    Exporter&lt;?&gt; exporter = protocol.export(
        PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local));
        exporters.add(exporter);
        logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to local registry url : &quot; + local);
&#125;
</code></pre><p>关于 <code>PROXY_FACTORY</code> 、<code>protocol</code> 的初始化过程不再分析,通过Dubbo SPI实现,生成的自适应代理工厂类 <code>PROXY_FACTORY</code> 对象为:</p>
<pre><code>package org.apache.dubbo.rpc;
import org.apache.dubbo.common.extension.ExtensionLoader;
public class ProxyFactory$Adaptive implements org.apache.dubbo.rpc.ProxyFactory
&#123;
    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException
    &#123;
        if (arg0 == null) throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;);
        if (arg0.getUrl() == null) throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;);
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);
        if(extName == null) throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot; + url.toString() + &quot;) use keys([proxy])&quot;);
        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);
        return extension.getProxy(arg0);
    &#125;
    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0, boolean arg1) throws org.apache.dubbo.rpc.RpcException
    &#123;
        if (arg0 == null) throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;);
        if (arg0.getUrl() == null) throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;);
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);
        if(extName == null) throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot; + url.toString() + &quot;) use keys([proxy])&quot;);
        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);
        return extension.getProxy(arg0, arg1);
    &#125;
    public org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException
    &#123;
        if (arg2 == null) throw new IllegalArgumentException(&quot;url == null&quot;);
        org.apache.dubbo.common.URL url = arg2;
        String extName = url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);
        if(extName == null) throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (&quot; + url.toString() + &quot;) use keys([proxy])&quot;);
        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);
        return extension.getInvoker(arg0, arg1, arg2);
    &#125;
&#125;
</code></pre><p><code>getInvoker</code> 方法中首先会获取 <code>extName</code>,默认值为 <code>javassist</code>,即默认的代理工厂类为 <code>org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory</code>, 在文章 <a href="https://lioswong.github.io/2019/09/17/Dubbo-SPI%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Dubbo SPI实现原理</a> 中知晓,该类会被包装类 <code>org.apache.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper</code> 包裹,进入 <code>org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getInvoker</code> :</p>
<pre><code> public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;
        // TODO Wrapper cannot handle this scenario correctly: the classname contains &#39;$&#39;
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);
        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class&lt;?&gt;[] parameterTypes,
                                      Object[] arguments) throws Throwable &#123;
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            &#125;
        &#125;;
    &#125;
</code></pre><p>首先会获取包装类,然后生成 <code>org.apache.dubbo.rpc.proxy.AbstractProxyInvoker</code> 的匿名类,并返回.在 <code>doInvoke</code> 方法中实现真正的方法调用,<br>关于包装类 <code>Wrapper</code> 的生成不具体分析,和上文分析一致,看下生成的包装类: </p>
<pre><code>class org.apache.dubbo.common.bytecode.Wrapper1
&#123;
    public static String[] pns;
    public static java.util.Map pts;
    public static String[] mns;
    public static String[] dmns;
    public static Class[] mts0;
    public String[] getPropertyNames()
    &#123;
        return pns;
    &#125;
    public boolean hasProperty(String n)
    &#123;
        return pts.containsKey($1);
    &#125;
    public Class getPropertyType(String n)
    &#123;
        return (Class)pts.get($1);
    &#125;
    public String[] getMethodNames()
    &#123;
        return mns;
    &#125;
    public String[] getDeclaredMethodNames()
    &#123;
        return dmns;
    &#125;
    public void setPropertyValue(Object o, String n, Object v)
    &#123;
        org.apache.dubbo.demo.provider.DemoServiceImpl w;
        try
        &#123;
            w = ((org.apache.dubbo.demo.provider.DemoServiceImpl)$1);
        &#125;
        catch(Throwable e)
        &#123;
            throw new IllegalArgumentException(e);
        &#125;
        throw new org.apache.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; field or setter method in class org.apache.dubbo.demo.provider.DemoServiceImpl.&quot;);
    &#125;
    public Object getPropertyValue(Object o, String n)
    &#123;
        org.apache.dubbo.demo.provider.DemoServiceImpl w;
        try
        &#123;
            w = ((org.apache.dubbo.demo.provider.DemoServiceImpl)$1);
        &#125;
        catch(Throwable e)
        &#123;
            throw new IllegalArgumentException(e);
        &#125;
        throw new org.apache.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; field or setter method in class org.apache.dubbo.demo.provider.DemoServiceImpl.&quot;);
    &#125;
    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException
    &#123;
        org.apache.dubbo.demo.provider.DemoServiceImpl w;
        try
        &#123;
            w = ((org.apache.dubbo.demo.provider.DemoServiceImpl)$1);
        &#125;
        catch(Throwable e)
        &#123;
            throw new IllegalArgumentException(e);
        &#125;
        try
        &#123;
            if( &quot;sayHello&quot;.equals( $2 )  &amp;&amp;  $3.length == 1 )
            &#123;
                return ($w)w.sayHello((java.lang.String)$4[0]);
            &#125;
        &#125;
        catch(Throwable e)
        &#123;
            throw new java.lang.reflect.InvocationTargetException(e);
        &#125;
        throw new org.apache.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot; + $2 + &quot;\&quot; in class org.apache.dubbo.demo.provider.DemoServiceImpl.&quot;);
    &#125;
&#125;
</code></pre><p>invokeMethod方法的内部逻辑十分清晰,就不多做分析,继续回到 <code>org.apache.dubbo.config.ServiceConfig#exportLocal</code> 方法中,上面 <code>Invoker</code> 对象已经生成,然后就导出服务,在<a href="https://lioswong.github.io/2019/09/17/Dubbo-SPI%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Dubbo SPI实现原理</a>中分析过,生成的 <code>Protocol</code> 会被包装类包裹,由于是本地暴露,所以结构为:</p>
<pre><code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper
   org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper
      org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol
</code></pre><p>即首先会调用 <code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper#export</code> 方法,然后再调用 <code>org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper#export</code> 方法,最后调用 <code>org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol#export</code> 方法,首先进入 <code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper#export</code> 方法:</p>
<pre><code> public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;
        // 如果协议为registry,直接暴露
        if (REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;
            return protocol.export(invoker);
        &#125;
        // 构建过滤器调用链
        return protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));
    &#125;
</code></pre><p>上面代码注释已经说明,如果协议是非registry,则会调用 <code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper#buildInvokerChain</code> 方法,进行过滤器调用链的组装,进入该方法:</p>
<pre><code>private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123;
        Invoker&lt;T&gt; last = invoker;
        // 自适应扩展获取过滤器
        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);

        if (!filters.isEmpty()) &#123;
            for (int i = filters.size() - 1; i &gt;= 0; i--) &#123;
                final Filter filter = filters.get(i);
                final Invoker&lt;T&gt; next = last;
                last = new Invoker&lt;T&gt;() &#123;

                    @Override
                    public Class&lt;T&gt; getInterface() &#123;
                        return invoker.getInterface();
                    &#125;

                    @Override
                    public URL getUrl() &#123;
                        return invoker.getUrl();
                    &#125;

                    @Override
                    public boolean isAvailable() &#123;
                        return invoker.isAvailable();
                    &#125;

                    @Override
                    public Result invoke(Invocation invocation) throws RpcException &#123;
                        Result asyncResult;
                        try &#123;
                            asyncResult = filter.invoke(next, invocation);
                        &#125; catch (Exception e) &#123;
                            // onError callback
                            if (filter instanceof ListenableFilter) &#123;
                                Filter.Listener listener = ((ListenableFilter) filter).listener();
                                if (listener != null) &#123;
                                    listener.onError(e, invoker, invocation);
                                &#125;
                            &#125;
                            throw e;
                        &#125;
                        return asyncResult;
                    &#125;

                    @Override
                    public void destroy() &#123;
                        invoker.destroy();
                    &#125;

                    @Override
                    public String toString() &#123;
                        return invoker.toString();
                    &#125;
                &#125;;
            &#125;
        &#125;
        return new CallbackRegistrationInvoker&lt;&gt;(last, filters);
    &#125;
</code></pre><p>上面主要根据自适应扩展获取过滤器,然后循环过滤器列表,创建匿名的 <code>Invoker</code> 类,在<code>invoke</code>方法中调用过滤器的<code>invoke</code>方法,实现一些其他功能逻辑,获取的过滤器如下:</p>
<pre><code>org.apache.dubbo.rpc.filter.ExceptionFilter
org.apache.dubbo.monitor.support.MonitorFilter
org.apache.dubbo.rpc.filter.TimeoutFilter
org.apache.dubbo.rpc.protocol.dubbo.filter.TraceFilter
org.apache.dubbo.rpc.filter.ContextFilter
org.apache.dubbo.rpc.filter.GenericFilter
org.apache.dubbo.rpc.filter.ClassLoaderFilter
org.apache.dubbo.rpc.filter.EchoFilter
</code></pre><p>根据过滤器的名称就大概知道功能,获取过滤器的过程就不多做分析,感兴趣可以调试分析,回到 <code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper#export</code> 方法中,至此,过滤器链已构建完成,下一步继续调用包装类<code>ProtocolListenerWrapper</code>的<code>org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper#export</code>方法:</p>
<pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;
        // 如果协议为registry,直接暴露
        if (REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;
            return protocol.export(invoker);
        &#125;
        // 
        return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),
                Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)
                        .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));
    &#125;
</code></pre><p>如果协议为registry,直接暴露,否则会先暴露,然后获取监听器列表,构建ListenerExporterWrapper对象返回.由于本地暴露,所以直接导出到本地, 进入到 <code>org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol#export</code>:</p>
<pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;
        return new InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);
    &#125;
</code></pre><p>直接创建对象 <code>InjvmExporter</code> 返回,并把 <code>InjvmExporter</code> 放入缓存 <code>exporterMap</code>中.回到 <code>org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper#export</code>中,本地服务导出很简单,然后通过 </p>
<pre><code>ExtensionLoader.getExtensionLoader(ExporterListener.class)
                        .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)
</code></pre><p>自适应扩展获取监听器列表,该过程不再分析,然后进入到 <code>org.apache.dubbo.rpc.listener.ListenerExporterWrapper#ListenerExporterWrapper</code> 中:</p>
<pre><code>    public ListenerExporterWrapper(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners) &#123;
        // 如果exporter为空则抛异常
        if (exporter == null) &#123;
            throw new IllegalArgumentException(&quot;exporter == null&quot;);
        &#125;
        this.exporter = exporter;
        this.listeners = listeners;
        if (CollectionUtils.isNotEmpty(listeners)) &#123;
            RuntimeException exception = null;
            // 循环调用监听器
            for (ExporterListener listener : listeners) &#123;
                if (listener != null) &#123;
                    try &#123;
                        listener.exported(this);
                    &#125; catch (RuntimeException t) &#123;
                        logger.error(t.getMessage(), t);
                        exception = t;
                    &#125;
                &#125;
            &#125;
            if (exception != null) &#123;
                throw exception;
            &#125;
        &#125;
    &#125;
</code></pre><p>调试过程中发现,<code>listeners</code> 为空,也就是这里dubbo没有实现自己的监听器,所以用户可以在服务暴露完成或者不暴露添加自定义监听器,用于业务逻辑的处理.<br>分析到这里,本地暴露基本完成,回到 <code>org.apache.dubbo.config.ServiceConfig#exportLocal</code> 中,暴露结束后,会把 <code>exporter</code> 放入到缓存中.</p>
<h4 id="服务远程暴露"><a href="#服务远程暴露" class="headerlink" title="服务远程暴露"></a>服务远程暴露</h4><p>让我们再回到 <code>org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code>,下面判断如果没有配置本地暴露,则远程暴露,然后循环协议列表 <code>registryURLs</code> 逐个暴露服务,我们着重分析以下几行代码:</p>
<pre><code>Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);
exporters.add(exporter);
</code></pre><p>关于 <code>invoker</code> 的获取,在本地暴露时已经分析,由于本地依据暴露完成,所以 <code>JavassistProxyFactory</code>、<code>Wrapper</code>直接从缓存中获取即可,不再分析.然后构建对象 <code>DelegateProviderMetaDataInvoker</code>,然后服务导出,由本地导出可知,通过自适应扩展动态获取的 <code>RegistryProtocol</code> 对象被对象 <code>ProtocolFilterWrapper</code>、<code>ProtocolListenerWrapper</code> 包裹,但是注意,由于此时协议为<code>registry</code>,所以再这两个类中导出时不作任何处理,直接进入 <code>org.apache.dubbo.registry.integration.RegistryProtocol#export</code>:</p>
<pre><code>    public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;
        // 获取URL,用于向注册中心注册
        URL registryUrl = getRegistryUrl(originInvoker);
        // url to export locally  获取URL用于导出服务
        URL providerUrl = getProviderUrl(originInvoker);

        // Subscribe the override data
        // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call
        //  the same service. Because the subscribed is cached key with the name of the service, it causes the
        //  subscription information to cover.
        final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);
        final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);

        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);
        //export invoker 导出服务
        final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);

        // url to registry
        final Registry registry = getRegistry(originInvoker);
        final URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);
        ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,
                registryUrl, registeredProviderUrl);
        //to judge if we need to delay publish
        boolean register = registeredProviderUrl.getParameter(&quot;register&quot;, true);
        if (register) &#123;
            register(registryUrl, registeredProviderUrl);
            providerInvokerWrapper.setReg(true);
        &#125;

        // Deprecated! Subscribe to override rules in 2.6.x or before.
        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);

        exporter.setRegisterUrl(registeredProviderUrl);
        exporter.setSubscribeUrl(overrideSubscribeUrl);
        //Ensure that a new exporter instance is returned every time export
        return new DestroyableExporter&lt;&gt;(exporter);
    &#125;
</code></pre><p>首先获取注册URL,在后面往注册中心注册服务会用到,然后获取服务提供者URL,用于服务导出,例如:</p>
<pre><code>dubbo://192.168.1.220:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;bind.ip=192.168.1.220&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=11557&amp;release=&amp;side=provider&amp;timestamp=1569413558031
</code></pre><p>断点进入<code>org.apache.dubbo.registry.integration.RegistryProtocol#doLocalExport</code>:</p>
<pre><code>private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker, URL providerUrl) &#123;
        String key = getCacheKey(originInvoker);
        return (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;
            // 创建InvokerDelegate封装originInvoker, providerUrl
            Invoker&lt;?&gt; invokerDelegate = new InvokerDelegate&lt;&gt;(originInvoker, providerUrl);
            return new ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);
        &#125;);
    &#125;
</code></pre><p>首先从缓存中获取key-value的值,如果key-value值不存在,则重新获取,再重新获取时,就需要暴露服务,一般key为:</p>
<pre><code>dubbo://192.168.1.220:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;bind.ip=192.168.1.220&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=11557&amp;release=&amp;side=provider&amp;timestamp=1569413558031
</code></pre><p>暴露服务时,还是通过Dubbo SPI自适应扩展实现,动态获取到的对象结构如下:</p>
<pre><code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper
  org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper
     org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
</code></pre><p><code>DubboProtocol</code> 被包装类包装,所以在导出时首先调用的是 <code>ProtocolFilterWrapper</code>的<code>export</code> 方法,同样与本地服务导出一样,同样会构建过滤器链,这里就不再重述;然后继续调用 <code>ProtocolListenerWrapper</code>的 <code>export</code> 方法,在该方法中,首先进行服务的暴露,然后再根据自适应扩展获取监听器类列表,再构建<code>ListenerExporterWrapper</code>对象返回,与本地暴露一样.但是这里服务暴露会调用 <code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#export</code>:</p>
<pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;
    URL url = invoker.getUrl();

    // export service.
    String key = serviceKey(url);  
    DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap);
    exporterMap.put(key, exporter);

    //export an stub service for dispatching event
    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false);
    if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;
        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);
        if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123;
            if (logger.isWarnEnabled()) &#123;
                logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(INTERFACE_KEY) +
                &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));
            &#125;
            &#125; else &#123;
                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);
            &#125;
        &#125;
        openServer(url);
        optimizeSerialization(url);
        return exporter;
&#125;
</code></pre><p>首先获取service key,这里的值为<code>org.apache.dubbo.demo.DemoService:20880</code>,然后创建DubboExporter对象,放入缓存Map中,直接进入到<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#openServer</code>:</p>
<pre><code> private void openServer(URL url) &#123;
        // find server.  
        String key = url.getAddress(); 
        //client can export a service which&#39;s only for server to invoke
        boolean isServer = url.getParameter(IS_SERVER_KEY, true);
        if (isServer) &#123;
            // 从缓存中获取ExchangeServer
            ExchangeServer server = serverMap.get(key);
            if (server == null) &#123;
                synchronized (this) &#123;
                    server = serverMap.get(key);
                    if (server == null) &#123;
                        serverMap.put(key, createServer(url));
                    &#125;
                &#125;
            &#125; else &#123;
                // server supports reset, use together with override
                server.reset(url);
            &#125;
        &#125;
    &#125;
</code></pre><p>首先获取到服务提供者地址,例如<code>192.168.1.220:20880</code>,根据URL判断,如果是服务提供者,则从缓存中获取ExchangeServer,如果缓存为空,则创建,断点进入到<code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer</code>:</p>
<pre><code>    private ExchangeServer createServer(URL url) &#123;
        url = URLBuilder.from(url)
                // send readonly event when server closes, it&#39;s enabled by default
                .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
                // enable heartbeat by default
                .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
                .addParameter(CODEC_KEY, DubboCodec.NAME)
                .build();
        // 获取通信协议,默认为netty
        String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);

        if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;
            throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);
        &#125;

        ExchangeServer server;
        try &#123;
            server = Exchangers.bind(url, requestHandler);
        &#125; catch (RemotingException e) &#123;
            throw new RpcException(&quot;Fail to start server(url: &quot; + url + &quot;) &quot; + e.getMessage(), e);
        &#125;

        str = url.getParameter(CLIENT_KEY);
        if (str != null &amp;&amp; str.length() &gt; 0) &#123;
            Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();
            if (!supportedTypes.contains(str)) &#123;
                throw new RpcException(&quot;Unsupported client type: &quot; + str);
            &#125;
        &#125;

        return server;
    &#125;
</code></pre><p>首先构建URL,添加属性参数,比如心跳、编码解码器参数,默认通信协议是netty,传入的<code>requestHandler</code>是ExchangeHandler类型,这个类十分重要,服务提供者在收到消费这请求时,会通过该处理器处理,实现方法的调用.然后根据自适应扩展判断是否存在协议通信类,然后再进行服务的绑定,进入<code>org.apache.dubbo.remoting.exchange.Exchangers#bind</code>:</p>
<pre><code>public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;
        if (url == null) &#123;
            throw new IllegalArgumentException(&quot;url == null&quot;);
        &#125;
        if (handler == null) &#123;
            throw new IllegalArgumentException(&quot;handler == null&quot;);
        &#125;
        url = url.addParameterIfAbsent(Constants.CODEC_KEY, &quot;exchange&quot;);
        return getExchanger(url).bind(url, handler);
    &#125;
</code></pre><p>根据自适应扩展动态获取到对象<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger</code>,然后继续调用<code>org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger#bind</code>:</p>
<pre><code>public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;
    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
&#125;
</code></pre><p>首先对传入的<code>handler</code>进行包裹,然后调用<code>org.apache.dubbo.remoting.Transporters#bind</code>方法:</p>
<pre><code>public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;
        if (url == null) &#123;
            throw new IllegalArgumentException(&quot;url == null&quot;);
        &#125;
        if (handlers == null || handlers.length == 0) &#123;
            throw new IllegalArgumentException(&quot;handlers == null&quot;);
        &#125;
        ChannelHandler handler;
        if (handlers.length == 1) &#123;
            handler = handlers[0];
        &#125; else &#123;
            handler = new ChannelHandlerDispatcher(handlers);
        &#125;
        return getTransporter().bind(url, handler);
&#125;
</code></pre><p><code>getTransporter</code>获取自适应扩展类,具体过程不再分析,然后根据URL动态获取具体的实现,断点进入<code>org.apache.dubbo.remoting.transport.netty4.NettyTransporter#bind</code>:</p>
<pre><code> public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;
        return new NettyServer(url, listener);
&#125;
</code></pre><p>创建了NettyServer对象,进入其构造函数:</p>
<pre><code>  public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123;
        // you can customize name and type of client thread pool by THREAD_NAME_KEY and THREADPOOL_KEY in CommonConstants.
        // the handler will be warped: MultiMessageHandler-&gt;HeartbeatHandler-&gt;handler
        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));
    &#125;
</code></pre><p>继续进入父类的构造函数<code>org.apache.dubbo.remoting.transport.AbstractServer#AbstractServer</code>:</p>
<pre><code>public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123;
        super(url, handler);
        localAddress = getUrl().toInetSocketAddress();

        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());
        int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());
        if (url.getParameter(ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) &#123;
            bindIp = ANYHOST_VALUE;
        &#125;
        bindAddress = new InetSocketAddress(bindIp, bindPort);
        this.accepts = url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);
        this.idleTimeout = url.getParameter(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);
        try &#123;
            doOpen();
            if (logger.isInfoEnabled()) &#123;
                logger.info(&quot;Start &quot; + getClass().getSimpleName() + &quot; bind &quot; + getBindAddress() + &quot;, export &quot; + getLocalAddress());
            &#125;
        &#125; catch (Throwable t) &#123;
            throw new RemotingException(url.toInetSocketAddress(), null, &quot;Failed to bind &quot; + getClass().getSimpleName()
                    + &quot; on &quot; + getLocalAddress() + &quot;, cause: &quot; + t.getMessage(), t);
        &#125;
        //fixme replace this with better method
        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();
        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));
&#125;
</code></pre><p>再进入父类构造函数:</p>
<pre><code>public AbstractEndpoint(URL url, ChannelHandler handler) &#123;
        super(url, handler);
        // 编解码器
        this.codec = getChannelCodec(url);
        this.timeout = url.getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);
        this.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);
&#125;
</code></pre><p>上面会获取编解码器,默认获取的是<code>org.apache.dubbo.rpc.protocol.dubbo.DubboCountCodec</code>,再获取远程服务调用超时时间、netty连接超时时间.<br>再回到<code>org.apache.dubbo.remoting.transport.AbstractServer#AbstractServer</code>中,根据URL获取服务提供者的IP、端口号,据此创建对象 <code>InetSocketAddress</code>,进入<code>org.apache.dubbo.remoting.transport.netty4.NettyServer#doOpen</code>,该方法是模版方法,具体实现有子类完成: </p>
<pre><code>    @Override
    protected void doOpen() throws Throwable &#123;
        bootstrap = new ServerBootstrap();

        bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(&quot;NettyServerBoss&quot;, true));
        workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
                new DefaultThreadFactory(&quot;NettyServerWorker&quot;, true));

        final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);
        channels = nettyServerHandler.getChannels();

        bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;
                        // FIXME: should we use getTimeout()?
                        int idleTimeout = UrlUtils.getIdleTimeout(getUrl());
                        NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);
                        ch.pipeline()//.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))//for debug
                                .addLast(&quot;decoder&quot;, adapter.getDecoder())
                                .addLast(&quot;encoder&quot;, adapter.getEncoder())
                                .addLast(&quot;server-idle-handler&quot;, new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS))
                                .addLast(&quot;handler&quot;, nettyServerHandler);
                    &#125;
                &#125;);
        // bind 服务绑定
        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());
        channelFuture.syncUninterruptibly();
        channel = channelFuture.channel();

    &#125;
</code></pre><p>这里很清楚的看到netty相关的类了,在这里进行服务端口的暴露,关于netty相关知识在这里不作介绍了.</p>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>继续回到<code>org.apache.dubbo.registry.integration.RegistryProtocol#export</code>中.<br>然后获取Registry、注册服务提供者URL对象,然后在往注册中心注册服务,进入<code>org.apache.dubbo.registry.support.FailbackRegistry#register</code>:</p>
<pre><code>@Override
    public void register(URL url) &#123;
        super.register(url);
        removeFailedRegistered(url);
        removeFailedUnregistered(url);
        try &#123;
            // Sending a registration request to the server side
            doRegister(url);
        &#125; catch (Exception e) &#123;
            Throwable t = e;

            // If the startup detection is opened, the Exception is thrown directly.
            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, true)
                    &amp;&amp; !CONSUMER_PROTOCOL.equals(url.getProtocol());
            boolean skipFailback = t instanceof SkipFailbackWrapperException;
            if (check || skipFailback) &#123;
                if (skipFailback) &#123;
                    t = t.getCause();
                &#125;
                throw new IllegalStateException(&quot;Failed to register &quot; + url + &quot; to registry &quot; + getUrl().getAddress() + &quot;, cause: &quot; + t.getMessage(), t);
            &#125; else &#123;
                logger.error(&quot;Failed to register &quot; + url + &quot;, waiting for retry, cause: &quot; + t.getMessage(), t);
            &#125;

            // Record a failed registration request to a failed list, retry regularly
            addFailedRegistered(url);
        &#125;
    &#125;
</code></pre><p>在doRegister完成注册的逻辑:</p>
<pre><code> public void doRegister(URL url) &#123;
        try &#123;
            zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, true));
        &#125; catch (Throwable e) &#123;
            throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);
        &#125;
    &#125;
</code></pre><p>进入<code>org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperClient#create</code>:</p>
<pre><code> public void create(String path, boolean ephemeral) &#123;
        if (!ephemeral) &#123;
            if(persistentExistNodePath.contains(path))&#123;
                return;
            &#125;
            if (checkExists(path)) &#123;
                persistentExistNodePath.add(path);
                return;
            &#125;
        &#125;
        int i = path.lastIndexOf(&#39;/&#39;);
        if (i &gt; 0) &#123;
            create(path.substring(0, i), false);
        &#125;
        if (ephemeral) &#123;
            createEphemeral(path);
        &#125; else &#123;
            createPersistent(path);
            persistentExistNodePath.add(path);
        &#125;
    &#125;
</code></pre><p>依次创建持久结点:</p>
<pre><code>/dubbo
/dubbo/org.apache.dubbo.demo.DemoService
/dubbo/org.apache.dubbo.demo.DemoService/providers
</code></pre><p>最后创建临时结点:</p>
<pre><code>/dubbo/org.apache.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.1.220%3A20880%2Forg.apache.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-demo-api-provider%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dorg.apache.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D19865%26release%3D%26side%3Dprovider%26timestamp%3D1569551377814
</code></pre><p>此时服务往注册中心已经注册完成.</p>
<h4 id="服务订阅"><a href="#服务订阅" class="headerlink" title="服务订阅"></a>服务订阅</h4><p>进入 <code>org.apache.dubbo.registry.support.FailbackRegistry#subscribe</code>:</p>
<pre><code>    public void subscribe(URL url, NotifyListener listener) &#123;
        super.subscribe(url, listener);
        removeFailedSubscribed(url, listener);
        try &#123;
            // Sending a subscription request to the server side
            doSubscribe(url, listener);
        &#125; catch (Exception e) &#123;
            Throwable t = e;

            List&lt;URL&gt; urls = getCacheUrls(url);
            if (CollectionUtils.isNotEmpty(urls)) &#123;
                notify(url, listener, urls);
                logger.error(&quot;Failed to subscribe &quot; + url + &quot;, Using cached list: &quot; + urls + &quot; from cache file: &quot; + getUrl().getParameter(FILE_KEY, System.getProperty(&quot;user.home&quot;) + &quot;/dubbo-registry-&quot; + url.getHost() + &quot;.cache&quot;) + &quot;, cause: &quot; + t.getMessage(), t);
            &#125; else &#123;
                // If the startup detection is opened, the Exception is thrown directly.
                boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                        &amp;&amp; url.getParameter(Constants.CHECK_KEY, true);
                boolean skipFailback = t instanceof SkipFailbackWrapperException;
                if (check || skipFailback) &#123;
                    if (skipFailback) &#123;
                        t = t.getCause();
                    &#125;
                    throw new IllegalStateException(&quot;Failed to subscribe &quot; + url + &quot;, cause: &quot; + t.getMessage(), t);
                &#125; else &#123;
                    logger.error(&quot;Failed to subscribe &quot; + url + &quot;, waiting for retry, cause: &quot; + t.getMessage(), t);
                &#125;
            &#125;

            // Record a failed registration request to a failed list, retry regularly
            addFailedSubscribed(url, listener);
        &#125;
    &#125;
</code></pre><p>继续进入方法<code>doSubscribe</code>:</p>
<pre><code>    public void doSubscribe(final URL url, final NotifyListener listener) &#123;
        try &#123;
            if (ANY_VALUE.equals(url.getServiceInterface())) &#123;
                String root = toRootPath();
                ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);
                if (listeners == null) &#123;
                    zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;&gt;());
                    listeners = zkListeners.get(url);
                &#125;
                ChildListener zkListener = listeners.get(listener);
                if (zkListener == null) &#123;
                    listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; &#123;
                        for (String child : currentChilds) &#123;
                            child = URL.decode(child);
                            if (!anyServices.contains(child)) &#123;
                                anyServices.add(child);
                                subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,
                                        Constants.CHECK_KEY, String.valueOf(false)), listener);
                            &#125;
                        &#125;
                    &#125;);
                    zkListener = listeners.get(listener);
                &#125;
                zkClient.create(root, false);
                List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);
                if (CollectionUtils.isNotEmpty(services)) &#123;
                    for (String service : services) &#123;
                        service = URL.decode(service);
                        anyServices.add(service);
                        subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,
                                Constants.CHECK_KEY, String.valueOf(false)), listener);
                    &#125;
                &#125;
            &#125; else &#123;
                List&lt;URL&gt; urls = new ArrayList&lt;&gt;();
                for (String path : toCategoriesPath(url)) &#123;
                    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);
                    if (listeners == null) &#123;
                        zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;&gt;());
                        listeners = zkListeners.get(url);
                    &#125;
                    ChildListener zkListener = listeners.get(listener);
                    if (zkListener == null) &#123;
                        listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));
                        zkListener = listeners.get(listener);
                    &#125;
                    zkClient.create(path, false);
                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);
                    if (children != null) &#123;
                        urls.addAll(toUrlsWithEmpty(url, path, children));
                    &#125;
                &#125;
                notify(url, listener, urls);
            &#125;
        &#125; catch (Throwable e) &#123;
            throw new RpcException(&quot;Failed to subscribe &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);
        &#125;
    &#125;
</code></pre><p>上面主要是往zk服务端注册客户端的监听回调,当zk服务端结点发生变化时,会通知zk客户端,具体进入 <code>org.apache.dubbo.registry.support.FailbackRegistry#notify</code>,该方法中调用 <code>org.apache.dubbo.registry.support.FailbackRegistry#doNotify</code>处理,继续调用父类<code>org.apache.dubbo.registry.support.AbstractRegistry#notify</code>:</p>
<pre><code>protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;
        ...
        ...
        ...
        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; new ConcurrentHashMap&lt;&gt;());
        for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;
            String category = entry.getKey();
            List&lt;URL&gt; categoryList = entry.getValue();
            categoryNotified.put(category, categoryList);
            // 调用监听器通知
            listener.notify(categoryList);
            // We will update our cache file after each notification.
            // When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.
            // 持久化到磁盘文件
            saveProperties(url);
        &#125;
    &#125;
</code></pre><p>首先看监听器的notify方法,该方法又调用doOverrideIfNecessary进行处理:</p>
<pre><code>public synchronized void doOverrideIfNecessary() &#123;
            final Invoker&lt;?&gt; invoker;
            if (originInvoker instanceof InvokerDelegate) &#123;
                invoker = ((InvokerDelegate&lt;?&gt;) originInvoker).getInvoker();
            &#125; else &#123;
                invoker = originInvoker;
            &#125;
            //The origin invoker
            URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);
            String key = getCacheKey(originInvoker);
            ExporterChangeableWrapper&lt;?&gt; exporter = bounds.get(key);
            if (exporter == null) &#123;
                logger.warn(new IllegalStateException(&quot;error state, exporter should not be null&quot;));
                return;
            &#125;
            //The current, may have been merged many times
            URL currentUrl = exporter.getInvoker().getUrl();
            //Merged with this configuration
            URL newUrl = getConfigedInvokerUrl(configurators, originUrl);
            newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);
            newUrl = getConfigedInvokerUrl(serviceConfigurationListeners.get(originUrl.getServiceKey())
                    .getConfigurators(), newUrl);
            if (!currentUrl.equals(newUrl)) &#123;
                RegistryProtocol.this.reExport(originInvoker, newUrl);
                logger.info(&quot;exported provider url changed, origin url: &quot; + originUrl +
                        &quot;, old export url: &quot; + currentUrl + &quot;, new export url: &quot; + newUrl);
            &#125;
        &#125;
</code></pre><p>上面主要就是比较当前与最新的URL,如果不相等,则根据最新的URL重新进行服务的暴露.再回到<code>org.apache.dubbo.registry.support.AbstractRegistry#notify</code>中,下一步会把URL信息持久化到本地磁盘,感兴趣可自己分析代码,具体保存的目录及文件信息如下:</p>
<pre><code>➜  ~ cd .dubbo 
➜  .dubbo pwd
/Users/lioswong/.dubbo
➜  .dubbo cat dubbo-registry-dubbo-demo-api-provider-127.0.0.1:2181.cache 
#Dubbo Registry Cache
#Sun Sep 29 11:13:03 CST 2019
org.apache.dubbo.demo.DemoService=empty\://192.168.31.40\:20880/org.apache.dubbo.demo.DemoService?anyhost\=true&amp;application\=dubbo-demo-api-provider&amp;bind.ip\=192.168.31.40&amp;bind.port\=20880&amp;category\=configurators&amp;check\=false&amp;deprecated\=false&amp;dubbo\=2.0.2&amp;dynamic\=true&amp;generic\=false&amp;interface\=org.apache.dubbo.demo.DemoService&amp;methods\=sayHello&amp;pid\=8443&amp;release\=&amp;side\=provider&amp;timestamp\=1569602514942
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于时间问题,分析的过程比较粗糙,上文主要介绍Wrapper和Invoker的创建、服务本地暴露、服务远程暴露、服务注册、服务订阅等,尤其理解Wrapper、Invoker的创建过程至关重要.</p>
<blockquote>
<p>参考文档</p>
</blockquote>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo SPI实现原理</title>
    <url>/2019/09/17/Dubbo-SPI%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Dubbo 并未使用 Java 原生的 SPI 机制,而是对其进行了增强,使其能够更好的满足需求,在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI,我们可以很容易的对 Dubbo 进行拓展.<br>本篇文章通过示例说明,先 <a href="https://github.com/apache/dubbo">download</a> 代码，然后在 <code>demo-dubbo --》 dubbo-demo-api --》 dubbo-demo-api-provider</code> 下新建类:</p>
<pre><code>@SPI(&quot;robot&quot;)
public interface Robot &#123;
    @Adaptive
    void sayHello();
&#125;

public class Bumblebee implements Robot&#123;
    @Override
    public void sayHello() &#123;
        System.out.println(&quot;Hello, I am Bumblebee.&quot;);
    &#125;
&#125;

public class OptimusPrime implements Robot&#123;
    @Override
    public void sayHello() &#123;
        System.out.println(&quot;Hello, I am Optimus Prime.&quot;);
    &#125;
&#125;
</code></pre><p>然后在 <code>resources</code> 文件夹下创建 <code>META-INF/dubbo/internal</code> ,再在该文件夹下创建文件 <code>org.apache.dubbo.demo.provider.Robot</code>,并写入:</p>
<pre><code>optimusPrime = org.apache.dubbo.demo.provider.OptimusPrime
bumblebee = org.apache.dubbo.demo.provider.Bumblebee
</code></pre><p>测试方法如下:</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) throws Exception &#123;
        ExtensionLoader&lt;Robot&gt; extensionLoader =
                ExtensionLoader.getExtensionLoader(Robot.class);
        Robot optimusPrime = extensionLoader.getExtension(&quot;optimusPrime&quot;);
        optimusPrime.sayHello();
        Robot bumblebee = extensionLoader.getExtension(&quot;bumblebee&quot;);
        bumblebee.sayHello();
    &#125;
&#125;
</code></pre><h4 id="ExtensionLoader-getExtensionLoader-实现原理"><a href="#ExtensionLoader-getExtensionLoader-实现原理" class="headerlink" title="ExtensionLoader#getExtensionLoader 实现原理"></a>ExtensionLoader#getExtensionLoader 实现原理</h4><p>然后运行该 <code>Test</code> 类的main方法,从断点进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#getExtensionLoader</code> 方法,用于获取 <code>ExtensionLoader</code> 实例:</p>
<pre><code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123;
        // type为空抛出异常
        if (type == null) &#123;
            throw new IllegalArgumentException(&quot;Extension type == null&quot;);
        &#125;
        // 不是接口抛出异常
        if (!type.isInterface()) &#123;
            throw new IllegalArgumentException(&quot;Extension type (&quot; + type + &quot;) is not an interface!&quot;);
        &#125;
        // 若没有SPI注解抛出异常
        if (!withExtensionAnnotation(type)) &#123;
            throw new IllegalArgumentException(&quot;Extension type (&quot; + type +
                    &quot;) is not an extension, because it is NOT annotated with @&quot; + SPI.class.getSimpleName() + &quot;!&quot;);
        &#125;
        // 从缓存EXTENSION_LOADERS获取
        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
        if (loader == null) &#123;
            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));
            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
        &#125;
        return loader;
    &#125;
</code></pre><p>首选会检查type是否为空、type是否为接口、type是否有SPI注解(Robot必须有SPI注解,否则会报错),再从缓存中获取 <code>ExtensionLoader</code>,如果为空,从新创建ExtensionLoader实例,断点进入 <code>ExtensionLoader</code> 构造函数:</p>
<pre><code>  private ExtensionLoader(Class&lt;?&gt; type) &#123;
        this.type = type;
        objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
    &#125;
</code></pre><p>如果type是 <code>ExtensionFactory.class</code> 时,objectFactory初始化为null,否则执行 <code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</code> ,断点继续进入,还是会进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#getExtensionLoader</code> 方法,这里就不做分析,由于此时type为 <code>ExtensionFactory.class</code> ,所以objectFactory为null,这里分析<code>org.apache.dubbo.common.extension.ExtensionLoader#getAdaptiveExtension</code> ,断点进入:</p>
<pre><code>        // cachedAdaptiveInstance
        Object instance = cachedAdaptiveInstance.get();
        if (instance == null) &#123;
            // createAdaptiveInstanceError不为null则报错
            if (createAdaptiveInstanceError != null) &#123;
                throw new IllegalStateException(&quot;Failed to create adaptive instance: &quot; +
                        createAdaptiveInstanceError.toString(),
                        createAdaptiveInstanceError);
            &#125;
            // dubbo里常出现的双重检查
            synchronized (cachedAdaptiveInstance) &#123;
                instance = cachedAdaptiveInstance.get();
                if (instance == null) &#123;
                    try &#123;
                        // instance为空,则创建
                        instance = createAdaptiveExtension();
                        cachedAdaptiveInstance.set(instance);
                    &#125; catch (Throwable t) &#123;
                        createAdaptiveInstanceError = t;
                        throw new IllegalStateException(&quot;Failed to create adaptive instance: &quot; + t.toString(), t);
                    &#125;
                &#125;
            &#125;
        &#125;

        return (T) instance;
</code></pre><p>断点进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#createAdaptiveExtension</code>:</p>
<pre><code> private T createAdaptiveExtension() &#123;
        try &#123;
            return injectExtension((T) getAdaptiveExtensionClass().newInstance());
        &#125; catch (Exception e) &#123;
            throw new IllegalStateException(&quot;Can&#39;t create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);
        &#125;
    &#125;
</code></pre><p><code>injectExtension</code> 负责扩展点的依赖注入，<code>getAdaptiveExtensionClass</code> 方法为了获取自适应扩展类,断点进入<code>org.apache.dubbo.common.extension.ExtensionLoader#getAdaptiveExtensionClass</code> :</p>
<pre><code>  private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;
        getExtensionClasses();
        if (cachedAdaptiveClass != null) &#123;
            return cachedAdaptiveClass;
        &#125;
        return cachedAdaptiveClass = createAdaptiveExtensionClass();
    &#125;
</code></pre><p>无疑继续进入方法 <code>getExtensionClasses</code> ,获取扩展类:</p>
<pre><code>private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;
        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
        if (classes == null) &#123;
            synchronized (cachedClasses) &#123;
                classes = cachedClasses.get();
                if (classes == null) &#123;
                    classes = loadExtensionClasses();
                    cachedClasses.set(classes);
                &#125;
            &#125;
        &#125;
        return classes;
    &#125;
</code></pre><p>这里也没什么好说的,首先从缓存里获取,缓存里没有则调用 <code>loadExtensionClasses</code> 加载,断点进入:</p>
<pre><code>private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;
        cacheDefaultExtensionName();

        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;&gt;();
        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());
        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());
        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());
        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
        return extensionClasses;
    &#125;
</code></pre><p>会从目录</p>
<pre><code>META-INF/dubbo/internal/
META-INF/dubbo/
META-INF/services/
</code></pre><p>中根据type名称加载文件,此时type.getName为 <code>org.apache.dubbo.common.extension.ExtensionFactory</code> ,继续进入 <code>loadDirectory</code> :</p>
<pre><code>private void loadDirectory(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type) &#123;
        String fileName = dir + type;
        try &#123;
            Enumeration&lt;java.net.URL&gt; urls;
            ClassLoader classLoader = findClassLoader();
            if (classLoader != null) &#123;
                urls = classLoader.getResources(fileName);
            &#125; else &#123;
                urls = ClassLoader.getSystemResources(fileName);
            &#125;
            if (urls != null) &#123;
                while (urls.hasMoreElements()) &#123;
                    java.net.URL resourceURL = urls.nextElement();
                    loadResource(extensionClasses, classLoader, resourceURL);
                &#125;
            &#125;
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;Exception occurred when loading extension class (interface: &quot; +
                    type + &quot;, description file: &quot; + fileName + &quot;).&quot;, t);
        &#125;
    &#125;
</code></pre><p>和上面所说一样,根据名称获取资源文件,然后调用 <code>loadResource</code> 加载,进入该方法:</p>
<pre><code>private void loadResource(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) &#123;
        try &#123;
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;
                String line;
                while ((line = reader.readLine()) != null) &#123;
                    final int ci = line.indexOf(&#39;#&#39;);
                    if (ci &gt;= 0) &#123;
                        line = line.substring(0, ci);
                    &#125;
                    line = line.trim();
                    if (line.length() &gt; 0) &#123;
                        try &#123;
                            String name = null;
                            int i = line.indexOf(&#39;=&#39;);
                            if (i &gt; 0) &#123;
                                name = line.substring(0, i).trim();
                                line = line.substring(i + 1).trim();
                            &#125;
                            if (line.length() &gt; 0) &#123;
                                loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);
                            &#125;
                        &#125; catch (Throwable t) &#123;
                            IllegalStateException e = new IllegalStateException(&quot;Failed to load extension class (interface: &quot; + type + &quot;, class line: &quot; + line + &quot;) in &quot; + resourceURL + &quot;, cause: &quot; + t.getMessage(), t);
                            exceptions.put(line, e);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;Exception occurred when loading extension class (interface: &quot; +
                    type + &quot;, class file: &quot; + resourceURL + &quot;) in &quot; + resourceURL, t);
        &#125;
    &#125;
</code></pre><p>上面代码获取到文件流后,然后读取解析得到key、value值,继续调用 <code>loadClass</code> 方法,断点进入:  </p>
<pre><code> private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException &#123;
        if (!type.isAssignableFrom(clazz)) &#123;
            throw new IllegalStateException(&quot;Error occurred when loading extension class (interface: &quot; +
                    type + &quot;, class line: &quot; + clazz.getName() + &quot;), class &quot;
                    + clazz.getName() + &quot; is not subtype of interface.&quot;);
        &#125;
        // 判断类上是否带Adaptive注解,如果带的话,把clazz赋值给cachedAdaptiveClass
        if (clazz.isAnnotationPresent(Adaptive.class)) &#123;
            cacheAdaptiveClass(clazz);
        &#125; else if (isWrapperClass(clazz)) &#123;
            // cache wrapper class
            cacheWrapperClass(clazz);
        &#125; else &#123;
            clazz.getConstructor();
            if (StringUtils.isEmpty(name)) &#123;
                name = findAnnotationName(clazz);
                if (name.length() == 0) &#123;
                    throw new IllegalStateException(&quot;No such extension name for the class &quot; + clazz.getName() + &quot; in the config &quot; + resourceURL);
                &#125;
            &#125;

            String[] names = NAME_SEPARATOR.split(name);
            if (ArrayUtils.isNotEmpty(names)) &#123;
                // 如果类带有Activate注解,则缓存
                cacheActivateClass(clazz, names[0]);
                for (String n : names) &#123;
                    cacheName(clazz, n);
                    // 保存扩展类
                    saveInExtensionClass(extensionClasses, clazz, n);
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre><p>上面注意 <code>org.apache.dubbo.common.extension.ExtensionLoader#isWrapperClass</code> 方法,判断是否为包装类,是的话就缓存,判断依据就是扩展接口为该类的构造器参数,例如 <code>Protocol</code> 的两个子类 <code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</code> 、<code>org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</code> ,它们的构造函数都有以 <code>Protocol</code> 为参数,所以为包装类,在 <code>org.apache.dubbo.common.extension.ExtensionLoader#createExtension</code> 中会判断是否有包装类,有的的话会循环注入,例如在获取对象 <code>org.apache.dubbo.rpc.Protocol</code> 时,通过自适应扩展获取到的对象会被包装类包裹,例如:</p>
<pre><code>org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper
     org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper
          org.apache.dubbo.registry.integration.RegistryProtocol

</code></pre><p>这样的好处就是在调用前可以添加额外的处理逻辑.<br>到这里扩展类已经加载完了,并且保存,回到 <code>org.apache.dubbo.common.extension.ExtensionLoader#getAdaptiveExtensionClass</code>方法中,调用完 <code>getExtensionClasses</code> 后，会判断 <code>cachedAdaptiveClass</code> 是否为空,如果不为空直接返回,也就是如果类上有 <code>Adaptive</code>注解,此时会直接返回,注意结合 <code>org.apache.dubbo.common.extension.ExtensionLoader#loadClass</code> 方法中的判断分析,否则继续执行调用 <code>createAdaptiveExtensionClass</code> ,但是此时 <code>cachedAdaptiveClass</code> 是不为空的,所以直接返回.为什么不为空呢,由于 <code>ExtensionFactory</code> 的实现类 <code>org.apache.dubbo.common.extension.factory.AdaptiveExtensionFactory</code> 加上了 <code>Adaptive</code> 注解,在 <code>org.apache.dubbo.common.extension.ExtensionLoader#loadClass</code> 方法中,初始化了 <code>cachedAdaptiveClass</code> ,dubbo中的类上被 <code>Adaptive</code> 修饰的非常少,仅有两个: <code>AdaptiveCompiler</code> 、<code>AdaptiveExtensionFactory</code>.<br>回到 <code>org.apache.dubbo.common.extension.ExtensionLoader#createAdaptiveExtension</code> 方法中, <code>getAdaptiveExtensionClass</code> 获取到扩展类后,通过反射创建对象,然后再调用 <code>injectExtension</code> ,断点进入:  </p>
<pre><code>private T injectExtension(T instance) &#123;
        // 若objectFactory为null,直接返回instance
        if (objectFactory == null) &#123;
            return instance;
        &#125;
        try &#123;
            for (Method method : instance.getClass().getMethods()) &#123;
                if (!isSetter(method)) &#123;
                    continue;
                &#125;
                /**
                 * Check &#123;@link DisableInject&#125; to see if we need auto injection for this property
                 */
                if (method.getAnnotation(DisableInject.class) != null) &#123;
                    continue;
                &#125;
                Class&lt;?&gt; pt = method.getParameterTypes()[0];
                if (ReflectUtils.isPrimitives(pt)) &#123;
                    continue;
                &#125;
                try &#123;
                    String property = getSetterProperty(method);
                    Object object = objectFactory.getExtension(pt, property);
                    if (object != null) &#123;
                        method.invoke(instance, object);
                    &#125;
                &#125; catch (Exception e) &#123;
                    logger.error(&quot;Failed to inject via method &quot; + method.getName()
                            + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage(), e);
        &#125;
        return instance;
    &#125;
</code></pre><p>首先判断 objectFactory 是否为空，为空则直接返回，前面分析的 ExtensionLoader 构造方法的时若扩展点类型是 ExtensionFactory ,则 objectFactory 为null，否则为 objectFactory 的自适应扩展,如果 objectFactory 不为空,则遍历所有的 <code>setter</code> 方法，如果方法上有 <code>@DisableInject</code> 则直接跳过，否则通过 objectFactory 获取对应的属性,不为空则调用 <code>setter</code> 方法，如果为 SPI 扩展点注入属性值.<br>回到 <code>org.apache.dubbo.common.extension.ExtensionLoader#getExtensionLoader</code> 方法中, <code>ExtensionLoader</code> 实例已创建完成,并放入<br> <code>EXTENSION_LOADERS</code>  中,key是 <code>interface org.apache.dubbo.demo.provider.Robot.class</code> ,value是 <code>ExtensionLoader</code> 对象.  </p>
<h4 id="ExtensionLoader-getExtension实现"><a href="#ExtensionLoader-getExtension实现" class="headerlink" title="ExtensionLoader#getExtension实现"></a>ExtensionLoader#getExtension实现</h4><p>回到 <code>org.apache.dubbo.demo.provider.Test#main</code> 中,即 <code>ExtensionLoader</code> 对象已经创建成功,下一步获取扩展对象:  </p>
<pre><code>Robot optimusPrime = extensionLoader.getExtension(&quot;optimusPrime&quot;);
</code></pre><p>断点进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#getExtension</code> 中:  </p>
<pre><code>public T getExtension(String name) &#123;
        // 若扩展名称为空,则抛出异常
        if (StringUtils.isEmpty(name)) &#123;
            throw new IllegalArgumentException(&quot;Extension name == null&quot;);
        &#125;
        // 若扩展名为true,返回默认扩展对象
        if (&quot;true&quot;.equals(name)) &#123;
            return getDefaultExtension();
        &#125;
        // 获取Holder对象,如果从缓存获取为空,则重新创建
        final Holder&lt;Object&gt; holder = getOrCreateHolder(name);
        Object instance = holder.get();
        if (instance == null) &#123;
            synchronized (holder) &#123;
                instance = holder.get();
                if (instance == null) &#123;
                    instance = createExtension(name);
                    holder.set(instance);
                &#125;
            &#125;
        &#125;
        return (T) instance;
    &#125;
</code></pre><p>上面代码主要看 <code>org.apache.dubbo.common.extension.ExtensionLoader#createExtension</code> 方法,断点进入:  </p>
<pre><code>private T createExtension(String name) &#123;
        Class&lt;?&gt; clazz = getExtensionClasses().get(name);
        if (clazz == null) &#123;
            throw findException(name);
        &#125;
        try &#123;
            T instance = (T) EXTENSION_INSTANCES.get(clazz);
            if (instance == null) &#123;
                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
                instance = (T) EXTENSION_INSTANCES.get(clazz);
            &#125;
            // 依赖注入属性
            injectExtension(instance);
            Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;
            // Wrapper包装
            if (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;
                for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;
                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                &#125;
            &#125;
            return instance;
        &#125; catch (Throwable t) &#123;
            throw new IllegalStateException(&quot;Extension instance (name: &quot; + name + &quot;, class: &quot; +
                    type + &quot;) couldn&#39;t be instantiated: &quot; + t.getMessage(), t);
        &#125;
    &#125;
</code></pre><p>明显继续进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#getExtensionClasses</code> 方法:</p>
<pre><code>private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;
        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
        if (classes == null) &#123;
            synchronized (cachedClasses) &#123;
                classes = cachedClasses.get();
                if (classes == null) &#123;
                    classes = loadExtensionClasses();
                    cachedClasses.set(classes);
                &#125;
            &#125;
        &#125;
        return classes;
    &#125;
</code></pre><p>双重检查判断,继续断点进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#loadExtensionClasses</code> :</p>
<pre><code>private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;
        cacheDefaultExtensionName();

        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;&gt;();
        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());
        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());
        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());
        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
        return extensionClasses;
    &#125;
</code></pre><p>这段代码是不是似曾相识,不错,就是上面创建 <code>ExtensionLoader</code> 时加载自适应扩展类时调用的方法,思路和上面的一样,就不再次分析了,解析完得到<br>的 Map 里存放的是:</p>
<pre><code>optimusPrime -&gt; &#123;Class@1527&#125; &quot;class org.apache.dubbo.demo.provider.OptimusPrime&quot;
bumblebee -&gt; &#123;Class@1569&#125; &quot;class org.apache.dubbo.demo.provider.Bumblebee&quot;
</code></pre><p>回到 <code>org.apache.dubbo.common.extension.ExtensionLoader#createExtension</code>方法内,此时根据 <code>optimusPrime</code> 就可以从 Map 中获取到 <code>org.apache.dubbo.demo.provider.OptimusPrime.class</code>,判断 <code>EXTENSION_INSTANCES</code> 中是否有缓存,没有的话会根据反射创建该类对象,并放入到 <code>EXTENSION_INSTANCES</code> ,然后调用方法<code>org.apache.dubbo.common.extension.ExtensionLoader#injectExtension</code>,依赖注入属性,这个不作分析,与上文一致.至此对象 <code>OptimusPrime</code> 已生成了,然后返回到 <code>Test</code> 类测试方法中,可调用具体的方法了.<br>通过<code>ExtensionLoader#getExtension</code>获取扩展点的实现,并不能体现自适应特性,和java SPI 并没有多大的差别,下面介绍<code>ExtensionLoader#getAdaptiveExtension</code> 的实现.</p>
<h4 id="ExtensionLoader-getAdaptiveExtension的实现"><a href="#ExtensionLoader-getAdaptiveExtension的实现" class="headerlink" title="ExtensionLoader#getAdaptiveExtension的实现"></a>ExtensionLoader#getAdaptiveExtension的实现</h4><p>下面的分析需要注册中心 <code>zookeeper</code> ,关于安装和配置就不多分析.首先在 <code></code>org.apache.dubbo.config.ServiceConfig#protocol` 处打上断点:</p>
<pre><code>private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
</code></pre><p>在加载类 <code>ServiceConfig</code> 时,会先初始化静态变量 <code>protocol</code> , 而此时会获取自适应扩展类.到模块 <code>demo-dubbo --》 dubbo-demo-api --》 dubbo-demo-api-provider</code> 中运行 <code>Application</code> 类的main方法:</p>
<pre><code>public class Application &#123;
    public static void main(String[] args) throws Exception &#123;
        ServiceConfig&lt;DemoServiceImpl&gt; service = new ServiceConfig&lt;&gt;();
        service.setApplication(new ApplicationConfig(&quot;dubbo-demo-api-provider&quot;));
        service.setRegistry(new RegistryConfig(&quot;zookeeper://127.0.0.1:2181&quot;));
        service.setInterface(DemoService.class);
        service.setRef(new DemoServiceImpl());
        service.export();
        System.in.read();
    &#125;
&#125;
</code></pre><p>从断点进入,关于 <code>ExtensionLoader#getExtensionLoader</code> 的实现上文已经分析,这里不多作分析,断点直接进入 <code>org.apache.dubbo.common.extension.ExtensionLoader#getAdaptiveExtensionClass</code> 方法内: </p>
<pre><code>private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;
        getExtensionClasses();
        if (cachedAdaptiveClass != null) &#123;
            return cachedAdaptiveClass;
        &#125;
        return cachedAdaptiveClass = createAdaptiveExtensionClass();
    &#125;
</code></pre><p>由上文分析可知,由于 <code>Protocol</code> 的实现类上都没有注解 <code>Adaptive</code> ,所以 <code>cachedAdaptiveClass</code> 为空,此时会调用方法 <code>org.apache.dubbo.common.extension.ExtensionLoader#createAdaptiveExtensionClass</code> ,断点进入: </p>
<pre><code> private Class&lt;?&gt; createAdaptiveExtensionClass() &#123;
        // 获取扩展类字符串
        String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();
        ClassLoader classLoader = findClassLoader();
        org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
        return compiler.compile(code, classLoader);
    &#125;
</code></pre><p>断点进入 <code>org.apache.dubbo.common.extension.AdaptiveClassCodeGenerator#generate</code>  :</p>
<pre><code>public String generate() &#123;
        // no need to generate adaptive class since there&#39;s no adaptive method found.
        // type中至少一个方法被注解Adaptive修饰
        if (!hasAdaptiveMethod()) &#123;
            throw new IllegalStateException(&quot;No adaptive method exist on extension &quot; + type.getName() + &quot;, refuse to create the adaptive class!&quot;);
        &#125;

        StringBuilder code = new StringBuilder();
        // 拼接包名
        code.append(generatePackageInfo());
        // 拼接依赖包
        code.append(generateImports());
        // 拼接类名
        code.append(generateClassDeclaration());

        Method[] methods = type.getMethods();
        // 拼接方法
        for (Method method : methods) &#123;
            code.append(generateMethod(method));
        &#125;
        code.append(&quot;&#125;&quot;);

        if (logger.isDebugEnabled()) &#123;
            logger.debug(code.toString());
        &#125;
        return code.toString();
    &#125;
</code></pre><p>首先会校验 扩展类的接口中至少有一个方法被 <code>Adaptive</code> 注解修饰,具体代码不作分析了,看生成的类字符串信息:  </p>
<pre><code>    package org.apache.dubbo.rpc;
    import org.apache.dubbo.common.extension.ExtensionLoader;
    public class Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol &#123;
        public void destroy() &#123;
            throw new UnsupportedOperationException(&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
        &#125;

        public int getDefaultPort() &#123;
            throw new UnsupportedOperationException(&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
        &#125;

        public org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException &#123;
            if (arg1 == null) &#123;
                throw new IllegalArgumentException(&quot;url == null&quot;);
            &#125;
            org.apache.dubbo.common.URL url = arg1;
            String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
            if (extName == null) &#123;
                throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
            &#125;
            org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
            return extension.refer(arg0, arg1);
        &#125;

        public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException &#123;
            if (arg0 == null) &#123;
                throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;);
            &#125;
            if (arg0.getUrl() == null) &#123;
                throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;);
            &#125;
            org.apache.dubbo.common.URL url = arg0.getUrl();
            String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
            if (extName == null) &#123;
                throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
            &#125;
            org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
            return extension.export(arg0);
        &#125;
    &#125;
</code></pre><p>上面生成了类Protocol的子类 <code>Protocol$Adaptive</code> ,仔细观察发发现, <code>export</code> 、<code>refer</code> 方法都被注解  <code>Adaptive</code> 修饰,生成的 <code>Protocol$Adaptive</code> 中这两个方法都有具体的实现,而 <code>destroy</code> 、<code>getDefaultPort</code> 没有被注解修饰,生成的类中直接抛出 <code>UnsupportedOperationException</code> 异常.<br>回到  <code>org.apache.dubbo.common.extension.ExtensionLoader#createAdaptiveExtensionClass</code> 方法中,<br>由于 <code>org.apache.dubbo.common.compiler.Compiler</code> 的子类 <code>org.apache.dubbo.common.compiler.support.AdaptiveCompiler</code> 被 注解  <code>Adaptive</code> 修饰,所以变量 <code>compiler</code> 的值是 <code>AdaptiveCompiler</code> 实例,断点进入 <code>org.apache.dubbo.common.compiler.support.AdaptiveCompiler#compile</code>: </p>
<pre><code>    public Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;
        Compiler compiler;
        // 获取ExtensionLoader
        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class);
        String name = DEFAULT_COMPILER; // copy reference
        if (name != null &amp;&amp; name.length() &gt; 0) &#123;
            compiler = loader.getExtension(name);
        &#125; else &#123;
            compiler = loader.getDefaultExtension();
        &#125;
        return compiler.compile(code, classLoader);
    &#125;
</code></pre><p>上面首先或获取 <code>ExtensionLoader</code>, 根据 <code>name</code> 判断去加载具体的扩展实现,这里由于name为空,所以会调用 <code>org.apache.dubbo.common.extension.ExtensionLoader#getDefaultExtension</code>,断点进入:  </p>
<pre><code> public T getDefaultExtension() &#123;
        // 获取扩展类
        // 上一步已经获取到并且放入缓存,如下:
        // jdk -&gt; &#123;Class@1244&#125; &quot;class org.apache.dubbo.common.compiler.support.JdkCompiler&quot;
        // javassist -&gt; &#123;Class@1245&#125; &quot;class org.apache.dubbo.common.compiler.support.JavassistCompiler&quot;
        // 
        getExtensionClasses();
        if (StringUtils.isBlank(cachedDefaultName) || &quot;true&quot;.equals(cachedDefaultName)) &#123;
            return null;
        &#125;
        // 默认获取 javassist
        return getExtension(cachedDefaultName);
    &#125;
</code></pre><p><code>org.apache.dubbo.common.extension.ExtensionLoader#getExtension</code> 的具体实现不作分析,上文已经分析过,经过该方法后,可以得到<br><code>org.apache.dubbo.common.compiler.support.JavassistCompiler</code> 实例.<br>然后回到  <code>org.apache.dubbo.common.compiler.support.AdaptiveCompiler#compile</code> 方法内,执行 <code>org.apache.dubbo.common.compiler.support.AbstractCompiler#compile</code> 方法,该方法是父类方法,做一些检验处理,然后再调用模版方法 <code>doCompile</code> 由子类  <code>AdaptiveCompiler#doCompile</code> 去处理,底层由 <code>Javassist</code> 生成类 <code>Protocol$Adaptive</code>,到此自适应扩展类的生成已分析完毕.但是生成完如何使用呢?  </p>
<h4 id="自适应扩展按需加载"><a href="#自适应扩展按需加载" class="headerlink" title="自适应扩展按需加载"></a>自适应扩展按需加载</h4><p>回到<code>org.apache.dubbo.config.ServiceConfig</code>中,在此处打上断点:  </p>
<pre><code>Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);
</code></pre><p>wrapperInvoker对象包装着invoker,具体可以看截图:  </p>
<p><center> <img src="http://ww1.sinaimg.cn/thumbnail/ed2b6246ly1g72g7qib07j224w0se49f.jpg" alt="http://ww1.sinaimg.cn/thumbnail/ed2b6246ly1g72g7qib07j224w0se49f.jpg"></center><br>我们主要关注URL对象里的 <code>string</code> :</p>
<pre><code>registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;export=dubbo%3A%2F%2F10.200.190.156%3A20880%2Forg.apache.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-demo-api-provider%26bind.ip%3D10.200.190.156%26bind.port%3D20880%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dorg.apache.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D21663%26release%3D%26side%3Dprovider%26timestamp%3D1568697592181&amp;pid=21663&amp;registry=zookeeper&amp;timestamp=1568697592172
</code></pre><p>很明显使用的协议: <code>registry</code>,回到生成的自适应扩展类 <code>Protocol$Adaptive</code> 中的 <code>export</code> 方法:</p>
<pre><code>public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException &#123;
            if (arg0 == null) &#123;
                throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;);
            &#125;
            if (arg0.getUrl() == null) &#123;
                throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;);
            &#125;
            org.apache.dubbo.common.URL url = arg0.getUrl();
            String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
            if (extName == null) &#123;
                throw new IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
            &#125;
            org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
            return extension.export(arg0);
        &#125;
</code></pre><p>首先会判断传入参数是否为空,然后再判断 <code>org.apache.dubbo.common.URL</code> 是否为空, 然后获取协议, 所以这里<code>extName</code> 为 <code>registry</code>,后面就是根据  <code>extName</code> 获取具体的自适应扩展类,很明显 <code>extension</code> 会被 <code>org.apache.dubbo.registry.integration.RegistryProtocol</code> 初始化.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DUBBO SPI解决了什么问题呢,官方文档给出了解释:  </p>
<ul>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点</li>
</ul>
<blockquote>
<p>参考文章  </p>
</blockquote>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html</a>  </li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html</a>  </li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html">http://dubbo.apache.org/zh-cn/docs/dev/SPI.html</a>  </li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html</a>  </li>
<li><a href="https://cxis.me/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">https://cxis.me/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</a>  </li>
<li><a href="https://kexianjun.github.io/2019/08/19/spi/#more">https://kexianjun.github.io/2019/08/19/spi/#more</a></li>
</ol>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>元素枚举判断思考</title>
    <url>/2019/09/10/%E5%85%83%E7%B4%A0%E6%9E%9A%E4%B8%BE%E5%88%A4%E6%96%AD%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>开发中会遇到,判断某个值是否在枚举中,通常情况下可以这么做:</p>
<pre><code>@Getter
@AllArgsConstructor
public enum OrderStatusEnum &#123;
    STATUS_1(1, &quot;初始化&quot;),
    STATUS_2(2, &quot;状态2&quot;),
    STATUS_3(4, &quot;状态3&quot;),
    STATUS_4(8, &quot;状态4&quot;),
    STATUS_5(16, &quot;状态5&quot;),
    STATUS_6(32, &quot;状态6&quot;),
    STATUS_7(64, &quot;状态7&quot;),
    STATUS_8(128, &quot;状态8&quot;);

    private int status;

    private String desc;

    // 循环
    public static boolean isOrderStatus(int status) &#123;
        for (OrderStatusEnum c : values()) &#123;
            if (c.status.equals(status)) &#123;
                return Boolean.TRUE;
            &#125;
        &#125;
        return Boolean.FALSE;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(OrderStatusEnum.isOrderStatus(32));
    &#125;
&#125;
</code></pre><p>有没有其他方法呢,可以使用java8特性处理:</p>
<pre><code>@Getter
@AllArgsConstructor
public enum OrderStatusEnum &#123;
    STATUS_1(1, &quot;初始化&quot;),
    STATUS_2(2, &quot;状态2&quot;),
    STATUS_3(4, &quot;状态3&quot;),
    STATUS_4(8, &quot;状态4&quot;),
    STATUS_5(16, &quot;状态5&quot;),
    STATUS_6(32, &quot;状态6&quot;),
    STATUS_7(64, &quot;状态7&quot;),
    STATUS_8(128, &quot;状态8&quot;);

    private int status;

    private String desc;

    public static boolean isOrderStatus(int status) &#123;
        return Arrays.asList(values()).stream().anyMatch(p -&gt; &#123;
            return p.getStatus() == status;
        &#125;);
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(OrderStatusEnum.isOrderStatus(32));
    &#125;
&#125;
</code></pre><p>除了上面的两种方法,当然还有很多方法处理,下面使用运算符<code>&gt;&gt;</code>、<code>&amp;</code>更优雅的处理:</p>
<pre><code>
@Getter
@AllArgsConstructor
public enum OrderStatusEnum &#123;
    STATUS_1(0, 1, &quot;初始化&quot;),
    STATUS_2(1, 2, &quot;状态2&quot;),
    STATUS_22(1, 3, &quot;状态22&quot;),
    STATUS_3(2, 4, &quot;状态3&quot;),
    STATUS_4(3, 8, &quot;状态4&quot;),
    STATUS_5(4, 16, &quot;状态5&quot;),
    STATUS_6(5, 32, &quot;状态6&quot;),
    STATUS_7(6, 64, &quot;状态7&quot;),
    STATUS_8(7, 128, &quot;状态8&quot;);

    private int offset;

    private int status;

    private String desc;

    // 使用时,需要知道与具体哪个枚举值比较
    public boolean isOrderStatus(int status) &#123;
        return ((status &gt;&gt; (getStatus())) &amp; 1) == 1;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(OrderStatusEnum.STATUS_3.isOrderStatus(4));
    &#125;
&#125;
</code></pre><p>由于java int数据类型最大存储4个字节,一个字节占8位,对于第三种方法分析如下:</p>
<pre><code>    /**
     * 1
     * 0000 0000 0000 0000 0000 0000 0000 0001
     * 1 &gt;&gt; 0 右移0位 --》 0000 0000 0000 0000 0000 0000 0000 0001
     * (1 &gt;&gt; 1) &amp; 1 --》 (0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) --》0000 0000 0000 0000 0000 0000 0000 0001 结果为1
     *
     * 2
     * 0000 0000 0000 0000 0000 0000 0000 0010
     * 2 &gt;&gt; 1 右移1位 --》 0000 0000 0000 0000 0000 0000 0000 0001  高位由0补齐
     * (2 &gt;&gt; 1) &amp; 1 --》 (0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 3
     * 0000 0000 0000 0000 0000 0000 0000 0011
     * 3 &gt;&gt; 1 右移1位 --》 0000 0000 0000 0000 0000 0000 0000 0001  高位由0补齐
     * (3 &gt;&gt; 1) &amp; 1 --》 (0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 4
     * 0000 0000 0000 0000 0000 0000 0000 0100  高位由0补齐
     * 4 &gt;&gt; 2 右移2位 --》0000 0000 0000 0000 0000 0000 0000 0001
     * (4 &gt;&gt; 2) &amp; 1 --》(0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 8
     * 0000 0000 0000 0000 0000 0000 0000 1000
     * 8 &gt;&gt; 3 右移3位 --》0000 0000 0000 0000 0000 0000 0000 0001
     * (8 &gt;&gt; 3) &amp; 1 --》(0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 16
     * 0000 0000 0000 0000 0000 0000 0001 0000
     * 16 &gt;&gt; 4 右移4位 --》0000 0000 0000 0000 0000 0000 0000 0001
     * (16 &gt;&gt; 4) &amp; 1 --》(0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 32
     * 0000 0000 0000 0000 0000 0000 0010 0000
     * 32 &gt;&gt; 5 右移5位 --》0000 0000 0000 0000 0000 0000 0000 0001
     * (32 &gt;&gt; 5) &amp; 1 --》(0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 64
     * 0000 0000 0000 0000 0000 0000 0100 0000
     * 64 &gt;&gt; 6 右移6位 --》0000 0000 0000 0000 0000 0000 0000 0001
     * (64 &gt;&gt; 6) &amp; 1 --》(0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     *
     * 128
     * 0000 0000 0000 0000 0000 0000 1000 0000
     * 128 &gt;&gt; 7 右移7位 --》0000 0000 0000 0000 0000 0000 0000 0001
     * (128 &gt;&gt; 7) &amp; 1 --》(0000 0000 0000 0000 0000 0000 0000 0001) &amp; (0000 0000 0000 0000 0000 0000 0000 0001) 结果为1
     */
</code></pre><p>上面很清晰了具体过程,java中位运算符有左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;)、位与(&amp;)、位或(|)、位非(~)、位异或(^),介绍下<code>&amp;</code>运算过程:</p>
<pre><code>int a = 3
int b = 4
a &amp; b
a转化成二进制: 0000 0000 0000 0000 0000 0000 0000 0011
b转化成二进制: 0000 0000 0000 0000 0000 0000 0000 0100
      结果值: 0000 0000 0000 0000 0000 0000 0000 0000
      所以 a &amp; b = 0
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>构建tomcat镜像</title>
    <url>/2019/09/07/%E6%9E%84%E5%BB%BAtomcat%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>如果使用tomcat镜像非常简单,到镜像仓库pull现有的就可以满足,为了个人后面的学习,本文介绍下如何构建简单的tomcat镜像.</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>以<code>hub.c.163.com/library/tomcat:latest</code>为父镜像，生成容器  </li>
<li>在容器中安装<code>jdk-8u221-linux-x64.tar.gz</code>、<code>apache-tomcat-8.5.45.tar.gz</code>,具体配置可google  </li>
<li>根据容器生成镜像  </li>
<li>根据新镜像运行容器  </li>
<li>把新镜像push到远程仓库中  </li>
</ol>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>步骤1</code>中根据镜像生成容器，很简单:<code>docker run -i -t --name ubuntu e64071ee23c7</code>,<br>得到容器之后,进入容器，使用<code>exec</code>命令进入:<br><code>docker exec -it d6b7d20148aa bash</code>,<br>进入之后可以按部就班按照jdk、tomcat,完成之后,根据该容器生成镜像<code>步骤3</code>,使用commit命令:<br><code>docker commit d6b7d20148aa tomcat:0.1</code><br>虽然得到了一个拥有web容器的镜像,但是当我们运行起容器时,如果自动启动tomcat程序呢?所以需要结合Dockerfile根据得到的<code>tomcat:0.1</code>的镜像再生成一个镜像,Dockerfile内容如下:  </p>
<pre><code># 指定源镜像
FROM hub.c.163.com/lioswang/tomcat:0.1
MAINTAINER diy_os diy_os@163.com
# 设置JAVA环境
ENV JAVA_HOME /usr/dev/jdk1.8.0_221
ENV JAVA_BIN=/usr/dev/jdk1.8.0_221/bin
ENV PATH $PATH:$JAVA_BIN:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
# 运行tomcat程序
CMD [&quot;sh&quot;,&quot;/usr/dev/tomcat8/bin/catalina.sh&quot;,&quot;run&quot;]
</code></pre><p>然后在Dockerfile文件当前目录下,执行:<br><code>docker build -t tomcat:0.3 .</code><br>得到了新的镜像<code>tomcat:0.3</code>,为了验证当容器启动时,tomcat程序启动,可以在宿主机上copy一个测试web包到容器中:<br><code>docker cp ./web.war tomcat_1:/usr/dev/tomcat8/webapps</code><br>重启容器发现,可以直接访问到了我们的web资源.<br><code>步骤5</code>可根据使用的镜像仓库服务,由于我使用的网易蜂巢镜像仓库,可参考官方文档即可:<br><code>https://www.163yun.com/help/documents/15587826830438400</code></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>镜像</tag>
        <tag>容器</tag>
        <tag>tomcat镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>删除docker镜像失败</title>
    <url>/2019/09/06/%E5%88%A0%E9%99%A4docker%E9%95%9C%E5%83%8F%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ol>
<li>MacBook Pro</li>
<li>Docker version 19.03.1, build 74b1e89</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>MacdeMacBook-Pro:war lioswong$ docker rmi 620cdd31d76f5
Error response from daemon: conflict: unable to delete 620cdd31d76f (cannot be forced) - image has dependent child images
</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>参考网上的方法，找出依赖的镜像:</p>
<pre><code>docker image inspect --format=&#39;&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;&#39; $(docker image ls -q --filter since=620cdd31d76f)
</code></pre><p>发现还是删除不了，然后停止所有容器、删除所有容器、删除所有none容器，还是不行,具体命令如下:</p>
<pre><code># 停止所有容器
docker ps -a | grep &quot;Exited&quot; | awk &#39;&#123;print $1 &#125;&#39;|xargs docker stop
# 删除所有容器
docker ps -a | grep &quot;Exited&quot; | awk &#39;&#123;print $1 &#125;&#39;|xargs docker rm
# 删除所有none容器
docker images|grep none|awk &#39;&#123;print $3 &#125;&#39;|xargs docker rmi
</code></pre><p>也尝试了给镜像修改tag,也失败了，最后根据<code>REPOSITORY:TAG</code>删除成功了，具体原因不清楚</p>
<pre><code>MacdeMacBook-Pro:war lioswong$ docker rmi hub.c.163.com/public/ubuntu:16.04-tools
Untagged: hub.c.163.com/public/ubuntu:16.04-tools
Untagged: hub.c.163.com/public/ubuntu@sha256:0fc4a48462a92b0a5a53b35540b8ca33a68606c6cd23c21df54c5f54bccbf33a
</code></pre><blockquote>
<p>参考文章  </p>
</blockquote>
<ol>
<li><a href="https://blog.csdn.net/renzhewudi77/article/details/82858280">https://blog.csdn.net/renzhewudi77/article/details/82858280</a>  </li>
<li><a href="https://blog.csdn.net/u010483897/article/details/80940561">https://blog.csdn.net/u010483897/article/details/80940561</a></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>镜像</tag>
        <tag>容器</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>java8 Optional使用</title>
    <url>/2019/09/02/java8%20Optional%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Optional类是Java8进行空值判断处理的工具类,下面是该类提供的方法:</p>
<pre><code>empty: 返回一个空的 Optional实例
filter: 如果一个值存在，并且该值给定的谓词相匹配时，返回一个 Optional描述的值，否则返回一个空的 Optional 
flatMap: 如果一个值存在，应用提供的 Optional映射函数给它，返回该结果，否则返回一个空的 Optional
get: 如果 Optional中有一个值，返回值，否则抛出 NoSuchElementException
isPresent(): 返回 true如果存在值，否则为 false
ifPresent(Consumer&lt;? super T&gt; consumer): 如果存在值，则使用该值调用指定的消费者，否则不执行任何操作
map: 如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个 Optional结果的 Optional 
of: 返回具有 Optional的当前非空值的Optional
ofNullable: 返回一个 Optional指定值的Optional，如果非空，则返回一个空的 Optional 
orElse: 如果值存在返回，否则返回 other 
orElseGet: 如果值存在返回，否则调用 other并返回该调用的结果
orElseThrow: 如果值存在返回，否则抛出由提供的供应商创建的异常
</code></pre><p>示例:</p>
<pre><code>       Boolean b = null;

        // 返回空的Option实例
        Optional empty = Optional.empty();

        b  = empty.isPresent();

        // b为空报错
        Optional option = Optional.of(b);

        // filter过滤
        Optional&lt;Boolean&gt; optional = Optional.ofNullable(b).filter(p-&gt;&#123;
            return p.equals(Boolean.TRUE);
        &#125;);

        TestAEntity testAEntity = new TestAEntity();

        // map
        Optional&lt;TestBEntity&gt; optionalMap = Optional.ofNullable(testAEntity).map(p -&gt; new TestBEntity().setId(1));

        // flatMap
        Optional&lt;TestBEntity&gt; optionalFlatMap = Optional.ofNullable(testAEntity).flatMap(p -&gt; Optional.of(new TestBEntity().setId(2)));

        // orElse
        b = Optional.ofNullable(b).orElse(Boolean.FALSE);

        b = null;

        // orElseGet
        b = Optional.ofNullable(b).orElseGet(() -&gt; &#123;
            if (Boolean.TRUE) &#123;
                return Boolean.TRUE;
            &#125;
            ;
            return Boolean.FALSE;
        &#125;);

        // orElseThrow
        b = Optional.ofNullable(b).orElseThrow(() -&gt; &#123;
            throw new RuntimeException();
        &#125;);

        // ifPresent
        Optional.ofNullable(testAEntity).ifPresent(p -&gt; &#123;
            System.out.println(p.getName());
        &#125;);

        // 过滤后组装
        Optional options = Optional.ofNullable(testAEntity).filter(p -&gt; &#123;
            return Objects.nonNull(p.getId());
        &#125;).map(p -&gt; new TestBEntity().setId(3));
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Vavr学习</title>
    <url>/2019/09/01/Vavr%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Vavr是java8函数式库，提供了非常丰富的API，便于开发使用。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.vavr&lt;/groupId&gt;
    &lt;artifactId&gt;vavr&lt;/artifactId&gt;
    &lt;version&gt;0.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>下面通过case简单介绍Option、Tuple(元组)、Try、Function、Collections、Lazy、Match。</p>
<ul>
<li>Option:  用来解决空指针异常，减少ifelse语句</li>
<li>Tuple(元组): Tuple是不可变的，用于保存不同类型对象的数据结构</li>
<li>Try: 用于包装可能产生异常的代码</li>
<li>Function: Java8的函数式接口最多有两个参数，Vavr最多可有8个参数</li>
<li>Collections: Vavr可创建集合，且提供更多的功能操作集合</li>
<li>Lazy: Lazy是一个容器，表示一个延迟计算的值。计算被推迟，直到需要时才计算。此外，计算的值被缓存或存储起来，当需要时被返回，而不需要重复计算。</li>
<li>模式匹配Matching: 通过过Match方法替换switch块。每个条件检查都通过Case方法调用来替换。 $()来替换条件并完成表达式计算得到结果。</li>
</ul>
<pre><code>package com.lios;

import io.vavr.*;
import io.vavr.control.Option;
import io.vavr.control.Try;

import java.util.Arrays;
import java.util.List;
import java.util.UUID;

public class VavrTest &#123;

    static Integer[] l = &#123;3, 4, 5, 1, 2&#125;;

    public static void main(String[] args) &#123;
        lazy();

        list(l);

        func();

        try1();

        tuple();

        option(l);
    &#125;


    /**
     * 模式匹配
     *
     * @param key
     * @return
     */
    private static String match(String key) &#123;
        String result = API.Match(key).of(
                API.Case(API.$(&quot;1&quot;), &quot;one&quot;),
                API.Case(API.$(&quot;2&quot;), &quot;two&quot;),
                API.Case(API.$(&quot;3&quot;), &quot;three&quot;)
        );
        return result;
    &#125;

    /**
     * 延迟计算
     */
    private static void lazy() &#123;
        Lazy lazy = Lazy.of(UUID::randomUUID);
        // 两次拿到结果值一样
        System.out.println(lazy.get());
        System.out.println(lazy.get());
    &#125;

    /**
     * 集合操作
     *
     * @param array
     */
    private static void list(Integer[] array) &#123;
        List&lt;Integer&gt; list = io.vavr.collection.List.of(array).toJavaList();

        Integer sum = io.vavr.collection.List.of(array).sum().intValue();

    &#125;

    /**
     * 函数式接口
     */
    private static void func() &#123;
        Function3&lt;String, String, String, String&gt; function3 = (a, b, c) -&gt; a + b + c + &quot;hello&quot;;

        String result = function3.apply(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);

        System.out.println(result);
    &#125;

    /**
     * try
     */
    private static void try1() &#123;
        Try r = Try.of(() -&gt; &#123;
            return 0 / 1;
        &#125;);
        System.out.println(r.isSuccess() + &quot;;&quot; + r.get());
        r.andFinallyTry(() -&gt; &#123;
            System.out.println(&quot;finally处理&quot;);
        &#125;);
    &#125;

    /**
     * 元组Tuple
     */
    private static void tuple() &#123;
        Tuple3&lt;String, String, String&gt; tuple = Tuple.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        System.out.println(tuple._1 + &quot;;&quot; + tuple._1());
        System.out.println(tuple._2 + &quot;;&quot; + tuple._2());
        System.out.println(tuple._3 + &quot;;&quot; + tuple._3());
    &#125;

    /**
     * option
     *
     * @param array
     */
    private static void option(Integer[] array) &#123;
        array = null;
        // of会构造None或Some对象
        Option.of(array).forEach(p -&gt; &#123;
            Arrays.stream(p).forEach(q -&gt; &#123;
                System.out.println(q.intValue());
            &#125;);
        &#125;);
    &#125;

&#125;
</code></pre><blockquote>
<p>参考文章</p>
</blockquote>
<ol>
<li><p><a href="https://blog.csdn.net/liubenlong007/article/details/96730721">https://blog.csdn.net/liubenlong007/article/details/96730721</a></p>
</li>
<li><p><a href="https://www.baeldung.com/vavr">https://www.baeldung.com/vavr</a></p>
</li>
<li><a href="https://www.vavr.io/vavr-docs/">https://www.vavr.io/vavr-docs/</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
        <tag>Vavr</tag>
      </tags>
  </entry>
  <entry>
    <title>闲谈_2019_08_23</title>
    <url>/2019/08/23/%E9%97%B2%E8%B0%882019-08-23/</url>
    <content><![CDATA[<p>不知不觉来公司已经2年2个月,还差10天.时间仿佛回到两年前,2017/07/03,来公司上班的情形,当年是多么稚嫩,哈哈.时光飞快,天下没有不散的宴席.<br>今天是在公司的最后一天,心里有说不出的感觉,抽出时间简单的写下感受,毕竟是人生第一次正式工作后的离职.非常感谢公司的栽培,想想兄弟们在一起奋斗过的日子,仍历历在目!<br>从刚毕业的新手,在公司成长了很多,不管技术还是业务上,目前自我感觉技术还差很多,奋斗不止;有一些很棒的同事,相处的非常愉快,在团队中只要够厉害,都有大展身手的平台;也得到领导的赏识,自由发挥空间很大;在技术的广度上也有很大的提高…<br>不管怎样,作为程序员追求技术的心不止,不自满于当前,征途犹如星辰大海!最后祝大家各自安好!每天能开开心心工作,快快乐乐生活!</p>
<pre><code>                                                                            -- Lios 2019/08/23 15:03 中节能西溪首座
</code></pre>]]></content>
      <categories>
        <category>Lios</category>
      </categories>
      <tags>
        <tag>恰同学少年</tag>
      </tags>
  </entry>
  <entry>
    <title>Jrebel使用</title>
    <url>/2019/08/23/Jrebel%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>关于Jrebel就不多说了,开发中由于修改代码或者配置文件,导致服务重启,非常的耗时的,但是利用Jrebel可以大大提高效率.本文介绍的是<code>ilanyu大神</code>提供的反代理工具,可以免费使用Jrebel.  </p>
<blockquote>
<p>步骤</p>
</blockquote>
<ul>
<li>首先去docker远程仓库download镜像,地址<code>https://hub.docker.com/r/ilanyu/golang-reverseproxy/</code></li>
<li>根据镜像生成容器,<code>docker run -d -p 8888:8888 ilanyu/golang-reverseproxy</code></li>
<li>idea按照插件Jrebel,然后在Team URL里输入<code>http://localhost:8888/88414687-3b91-4286-89ba-2dc813b107ce</code>,<code>88414687-3b91-4286-89ba-2dc813b107ce</code>是GUID(生成即可),,邮箱可任意填写即可.至此就激活啦</li>
<li>建议Jrebel License离线工作</li>
</ul>
<blockquote>
<p>本地环境</p>
</blockquote>
<ol>
<li>MacBook Pro (Retina, 15-inch, Mid 2015)</li>
<li>idea 2019.1</li>
<li>docker mac 18.09.2</li>
</ol>
<blockquote>
<p>参考</p>
</blockquote>
<ol>
<li><a href="http://blog.lanyus.com/archives/317.html#comment-3803">http://blog.lanyus.com/archives/317.html#comment-3803</a></li>
<li><a href="http://blog.lanyus.com/archives/337.html">http://blog.lanyus.com/archives/337.html</a></li>
<li><a href="https://hub.docker.com/r/ilanyu/golang-reverseproxy/">https://hub.docker.com/r/ilanyu/golang-reverseproxy/</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>jrebel</tag>
      </tags>
  </entry>
  <entry>
    <title>CyclicBarrier</title>
    <url>/2019/08/19/CyclicBarrier/</url>
    <content><![CDATA[<p><code>java.util.concurrent.CyclicBarrier</code>字面意思是循环屏障,可实现一组线程等待至某种状态(屏障点)后,然后再一起同时执行,该屏障可循环使用,这一点和<code>CountDownLatch</code>不同,下面简单介绍下<code>CyclicBarrier</code>用法,对原理不作说明.  </p>
<blockquote>
<p>CyclicBarrier两个构造函数:</p>
</blockquote>
<pre><code>给定数量的线程（线程）等待栅栏,且当屏障跳闸时不执行预定义的动作
CyclicBarrier(int parties)
给定数量的线程（线程）等待栅栏,当屏障跳闸时执行给定的屏障动作,由最后一个进入屏障的线程执行
CyclicBarrier(int parties, Runnable barrierAction)
</code></pre><p>一个栗子:</p>
<pre><code>import java.util.concurrent.*;
/**
 * @author LiosWong
 * @description
 * @date 2019-08-12 23:49
 */
public class BarrierTest &#123;

    public static void main(String[] args) &#123;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;当前线程名:&quot; + Thread.currentThread().getName() + &quot;,&quot; + &quot;全部集合完毕:&quot; + +System.currentTimeMillis());
            &#125;
        &#125;);

        ExecutorService executorService = Executors.newFixedThreadPool(3);

        for (int i = 0; i &lt; cyclicBarrier.getParties(); i++) &#123;
            int finalI = i;
            executorService.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    System.out.println(&quot;当前线程名:&quot; + Thread.currentThread().getName() + &quot;,&quot; + finalI + &quot;就位啦&quot; + &quot;,time:&quot; + System.currentTimeMillis());
                    try &#123;
                        // 等待
                        cyclicBarrier.await();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125; catch (BrokenBarrierException e) &#123;
                        e.printStackTrace();
                    &#125;
                    System.out.println(&quot;当前线程名:&quot; + Thread.currentThread().getName() + &quot;,&quot; + finalI + &quot;出发啦&quot; + &quot;,time:&quot; + System.currentTimeMillis());
                &#125;

            &#125;);
        &#125;

    &#125;
&#125;
</code></pre><p>上面的三个线程全部到栅栏点时,然后一起往下继续运行,简单的修改上面的代码:</p>
<pre><code>import java.util.concurrent.*;

/**
 * @author LiosWong
 * @description
 * @date 2019-08-12 23:49
 */
public class BarrierTest &#123;

    public static void main(String[] args) &#123;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);

        ExecutorService executorService = Executors.newFixedThreadPool(3);

        for (int i = 0; i &lt; cyclicBarrier.getParties(); i++) &#123;
            int finalI = i;
            executorService.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    System.out.println(&quot;当前线程名:&quot; + Thread.currentThread().getName() + &quot;,&quot; + finalI + &quot;就位啦&quot; + &quot;,time:&quot; + System.currentTimeMillis());
                    try &#123;
                        if (finalI == 0) &#123;
                            Thread.sleep(200);
                        &#125;
                        // 栅栏等待超时时间为100毫秒,超时后不再等待未到达栅栏的线程,继续往下执行
                        cyclicBarrier.await(100, TimeUnit.MILLISECONDS);
=                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125; catch (BrokenBarrierException e) &#123;
                        e.printStackTrace();
                    &#125; catch (TimeoutException e) &#123;
                        e.printStackTrace();
                    &#125;
                    System.out.println(&quot;当前线程名:&quot; + Thread.currentThread().getName() + &quot;,&quot; + finalI + &quot;出发啦&quot; + &quot;,time:&quot; + System.currentTimeMillis());
                &#125;

            &#125;);
        &#125;

    &#125;
&#125;
</code></pre><p>上面执行结果报代码超时异常,发现finalI=0的线程是最后执行完成,也就是设置了栅栏等待超时后,如果有线程在超时时间内还未到达栅栏时,其他线程不再等待,继续往下执行</p>
]]></content>
      <categories>
        <category>并发包</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发包</tag>
      </tags>
  </entry>
  <entry>
    <title>Map元素排序</title>
    <url>/2019/08/17/Map%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>开发中会遇到对Map元素排序的问题,下面介绍下如何根据key、value排序.  </p>
<h5 id="key排序"><a href="#key排序" class="headerlink" title="key排序"></a>key排序</h5><ul>
<li><p>使用TreeMap的Comparator比较<br>TreeMap默认是升序的,如果需要自定义排序规则,可以使用Comparator:</p>
<pre><code>      Map&lt;String, Integer&gt; map = new TreeMap&lt;String, Integer&gt;(new Comparator&lt;String&gt;() &#123;
          // 按照key排序
          @Override
          public int compare(String o1, String o2) &#123;
              // 按照key降序排列
              return Integer.valueOf(o2).compareTo(Integer.valueOf(o1));
          &#125;
      &#125;) &#123;
          &#123;
              put(&quot;1&quot;, 9);
              put(&quot;3&quot;, 6);
              put(&quot;5&quot;, 2);
          &#125;
      &#125;;

      for (Map.Entry c : map.entrySet()) &#123;
          System.out.println(c.getKey() + &quot;=&quot; + c.getValue());
      &#125;
</code></pre></li>
<li><p><code>java.util.Collections</code>的sort方法  </p>
<pre><code>      Map&lt;String, Integer&gt; map = new TreeMap&lt;String, Integer&gt;() &#123;
          &#123;
              put(&quot;1&quot;, 9);
              put(&quot;3&quot;, 6);
              put(&quot;5&quot;, 2);
          &#125;
      &#125;;

      List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryList = new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());

      Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;
          @Override
          public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123;
              // 根据key降序排列
              return Integer.valueOf(o2.getKey()).compareTo(Integer.valueOf(o1.getKey()));
          &#125;
      &#125;);

      for (Map.Entry c : entryList) &#123;
          System.out.println(c.getKey() + &quot;=&quot; + c.getValue());
      &#125;
</code></pre></li>
</ul>
<h5 id="value排序"><a href="#value排序" class="headerlink" title="value排序"></a>value排序</h5><ul>
<li><p><code>java.util.Collections</code>的sort方法<br>由上可知,对value排序也很容易实现:</p>
<pre><code>      Map&lt;String, Integer&gt; map = new TreeMap&lt;String, Integer&gt;() &#123;
          &#123;
              put(&quot;1&quot;, 9);
              put(&quot;3&quot;, 6);
              put(&quot;5&quot;, 2);
          &#125;
      &#125;;

      List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryList = new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());

      Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;
          @Override
          public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123;
              // 根据value降序排列
              return o2.getValue().compareTo(o1.getValue());
          &#125;
      &#125;);

      for (Map.Entry c : entryList) &#123;
          System.out.println(c.getKey() + &quot;=&quot; + c.getValue());
      &#125;
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java实现双向链表</title>
    <url>/2019/08/16/java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。<a href="https://zh.wikipedia.org/wiki/双向链表">–维基百科</a><br>下面用Java实现不具有双端性质的双向链表.</p>
<pre><code>package com.lios.algorithm;
import java.util.Objects;
/**
 * @author LiosWong
 * @description 双向链表
 * @date 2019-08-15 17:00
 */
public class My2NodeList &#123;

    private Node head = null;

    class Node &#123;
        private Integer data;
        private Node preNode;
        private Node nextNode;

        public Node(Integer data) &#123;
            this.data = data;
        &#125;

        public Integer getData() &#123;
            return data;
        &#125;

        public Node setData(Integer data) &#123;
            this.data = data;
            return this;
        &#125;

        public Node getPreNode() &#123;
            return preNode;
        &#125;

        public Node setPreNode(Node preNode) &#123;
            this.preNode = preNode;
            return this;
        &#125;

        public Node getNextNode() &#123;
            return nextNode;
        &#125;

        public Node setNextNode(Node nextNode) &#123;
            this.nextNode = nextNode;
            return this;
        &#125;
    &#125;

    // 尾部插入节点
    public Node addNodeLast(Integer data) &#123;
        Node node = new Node(data);
        if (head == null) &#123;
            this.head = node;
            return head;
        &#125;

        Node temp = head;

        while (temp.nextNode != null) &#123;
            temp = temp.nextNode;
        &#125;

        temp.nextNode = node;
        node.preNode = temp;
        return node;
    &#125;

    // 首部插入节点,注意和尾插法的区别,尾插法需要根据head找到最后的节点,而首插法根据head就能操作
    public Node addNodeFirst(Integer data) &#123;
        Node node = new Node(data);
        if (head == null) &#123;
            head = node;
            return head;
        &#125;
        node.nextNode = head;
        head.preNode = node;
        head = node;
        return head;
    &#125;

    // 链表长度
    public Integer getNodeLength() &#123;
        Integer lenght = 0;
        Node temp = head;
        while (temp != null) &#123;
            temp = temp.nextNode;
            lenght++;
        &#125;
        return lenght;
    &#125;

    // 查找前驱元素
    public Integer queryPreNode(Integer data) &#123;
        Node temp = head;
        while (temp != null) &#123;
            if (temp.data.equals(data)) &#123;
                if (temp.preNode == null) &#123;
                    return null;
                &#125;
                return temp.preNode.data;
            &#125;
            temp = temp.nextNode;
        &#125;
        return null;
    &#125;

    // 查找后驱元素
    public Integer queryAfterNode(Integer data) &#123;
        Node temp = head;
        while (temp != null) &#123;
            if (temp.data.equals(data)) &#123;
                if (temp.nextNode == null) &#123;
                    return null;
                &#125;
                return temp.nextNode.data;
            &#125;
            temp = temp.nextNode;
        &#125;
        return null;
    &#125;

    // 删除第几个节点
    public void deleteByIndex(Integer index) &#123;
        if (index &lt; 1 || index &gt; getNodeLength()) &#123;
            return;
        &#125;

        Node temp = head;
        Integer flag = 1;

        while (temp != null) &#123;
            if (Objects.equals(flag, index)) &#123;

                // 删除首节点
                if (temp.preNode == null) &#123;
                    if (temp.nextNode != null) &#123;
                        head = temp.nextNode;
                        head.preNode = null;
                        temp = null;
                        break;
                    &#125;
                    temp = null;
                    break;
                &#125;

                if (temp.nextNode == null) &#123;
                    Node pre = temp.preNode;
                    pre.nextNode = null;
                    temp = null;
                    break;

                &#125;

                Node pre = temp.preNode;
                Node next = temp.nextNode;

                pre.nextNode = next;
                next.preNode = pre;

                temp = null;
            &#125;
            if (temp != null) &#123;
                temp = temp.nextNode;
            &#125;
            flag++;
        &#125;

    &#125;

    // 遍历链表打印所有节点
    public void printNodeList() &#123;
        Node temp = head;
        while (temp != null) &#123;
            System.out.println(&quot;元素:&quot; + temp.data);
            temp = temp.nextNode;
        &#125;
    &#125;

    public static void main(String[] args) &#123;

        My2NodeList my2NodeList = new My2NodeList();

        my2NodeList.addNodeLast(1);
        my2NodeList.addNodeLast(2);
        my2NodeList.addNodeLast(3);
        my2NodeList.addNodeLast(4);

//        my2NodeList.addNodeFirst(1);
//        my2NodeList.addNodeFirst(2);
//        my2NodeList.addNodeFirst(3);
//        my2NodeList.addNodeFirst(4);

        System.out.println(&quot;链表长度:&quot; + my2NodeList.getNodeLength());

        my2NodeList.printNodeList();

        System.out.println(&quot;查找前驱元素:&quot; + my2NodeList.queryPreNode(1));
        System.out.println(&quot;查找后驱元素:&quot; + my2NodeList.queryAfterNode(2));

        my2NodeList.deleteByIndex(3);

        my2NodeList.printNodeList();
    &#125;
&#125;
</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
        <tag>链表长度</tag>
      </tags>
  </entry>
  <entry>
    <title>java实现单向链表</title>
    <url>/2019/08/15/java%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。<br>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（”links”）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。–<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">维基百科</a><br>下面是关于单向链表的操作代码:</p>
<pre><code>package com.lios.algorithm;
import java.util.Objects;
/**
 * @author LiosWong
 * @description
 * @date 2019-08-15 10:55
 */
public class MyNodeList &#123;

    // 头节点
    private Node head = null;

    class Node &#123;
        // 节点数据
        private int data;
        // 下一个节点的引用地址
        private Node next = null;

        public Node(int data) &#123;
            this.data = data;
        &#125;
    &#125;

    // 增加节点,链尾插入
    public Node addNode(int data) &#123;
        Node node = new Node(data);
        if (head == null) &#123;
            head = node;
            return node;
        &#125;
        Node temp = head;
        while (temp.next != null) &#123;
            temp = temp.next;
        &#125;
        temp.next = node;
        return node;
    &#125;

    // 删除链表中第几个节点
    public void deleteNodeByIndex(int index) &#123;
        int lenght = getNodeListLenght();
        if (index &lt; 1 || index &gt; lenght) &#123;
            return;
        &#125;

        Node temp = head;
        Node preNode = null;
        int flag = 1;
        while (temp != null) &#123;
            if (Objects.equals(flag, index)) &#123;
                // 若删除的头节点
                if (index == 1) &#123;
                    head = temp.next;
                    temp = null;
                    return;
                &#125;

                if (temp.next != null) &#123;
                    preNode.next = temp.next;
                &#125; else &#123;
                    // 删除的尾节点
                    preNode.next = null;
                &#125;
                temp = null;

            &#125;
            if (temp != null) &#123;
                preNode = temp;
                temp = temp.next;
            &#125;
            flag++;
        &#125;
    &#125;

    // 删除指定节点
    public void deleteNodeByNode(Node node) &#123;
        Node temp = head;
        // 若删除头元素
        if ((temp.next == null) &amp;&amp; node.next == null) &#123;
            head = null;
            return;
        &#125;

        Node preNode = null;

        while (temp != null) &#123;
            if (temp.next == head.next) &#123;
                head = temp.next;
                temp = null;
                return;
            &#125;
            if ((temp.next == node.next)) &#123;
                preNode.next = temp.next;
                temp = null;
            &#125;
            if (temp != null) &#123;
                preNode = temp;
                temp = temp.next;
            &#125;
        &#125;
    &#125;


    // 打印所有节点
    public void printNodeList() &#123;
        Node temp = head;
        while (temp != null) &#123;
            System.out.println(&quot;节点数据:&quot; + temp.data);
            temp = temp.next;
        &#125;
    &#125;

    // 获取链表长度
    public int getNodeListLenght() &#123;
        int length = 0;
        Node temp = head;
        while (temp != null) &#123;
            ++length;
            temp = temp.next;
        &#125;
        return length;
    &#125;

    public static void main(String[] args) &#123;
        MyNodeList myNodeList = new MyNodeList();
        Node node = myNodeList.addNode(1);
        myNodeList.addNode(2);
        myNodeList.addNode(3);
        myNodeList.addNode(4);
        myNodeList.addNode(5);

        myNodeList.printNodeList();

        System.out.println(&quot;链表长度:&quot; + myNodeList.getNodeListLenght());

        myNodeList.deleteNodeByIndex(4);

        System.out.println(&quot;链表长度:&quot; + myNodeList.getNodeListLenght());

        myNodeList.printNodeList();

        myNodeList.deleteNodeByNode(node);

        System.out.println(&quot;链表长度:&quot; + myNodeList.getNodeListLenght());


        myNodeList.printNodeList();
    &#125;

&#125;
</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
        <tag>链表长度</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch</title>
    <url>/2019/08/12/CountDownLatch/</url>
    <content><![CDATA[<p>CountDownLatch是<code>java.util.concurrent</code>包下的线程同步类,并发环境下线程对计数值减1操作,当计数值为0时,被wait阻塞的线程将被唤醒,达到线程同步.<br>该类涉及到的主要方法:</p>
<pre><code>// 当前线程在计数值减到0之前一直等待,除非当前线程被中断
void await()
// 当前线程在计数值减到0之前一直等待,除非当前线程被中断或者超过了指定的等待时间
boolean await(long timeout, TimeUnit unit)
// 减少计数值,当计数值减到0时,释放所有的等待线程
void countDown()
// 返回当前计数值
long getCount()
</code></pre><p>示例:</p>
<pre><code>        CountDownLatch countDownLatch = new CountDownLatch(3);
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 3; i++) &#123;
            int finalI = i;
            executorService.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    System.out.println(&quot;任务执行结束啦,i:&quot; + finalI + &quot;,&quot; + &quot;时间t&quot; + finalI + &quot;:&quot; + System.currentTimeMillis());
                    countDownLatch.countDown();

                &#125;
            &#125;);
        &#125;
        try &#123;
            countDownLatch.await();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
</code></pre><p>通过控制台可发现,输出时间几乎一致,把上面的代码改动如下:</p>
<pre><code> CountDownLatch countDownLatch = new CountDownLatch(3);
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 3; i++) &#123;
            int finalI = i;
            executorService.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    if (finalI == 0 || finalI == 1) &#123;
                        try &#123;
                            Thread.sleep(1000);
                        &#125; catch (InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;
                    System.out.println(&quot;任务执行结束啦,i:&quot; + finalI + &quot;,&quot; + &quot;时间t&quot; + finalI + &quot;:&quot; + System.currentTimeMillis());
                    countDownLatch.countDown();
                &#125;
            &#125;);
        &#125;
        try &#123;
            System.out.println(&quot;==========start,时间t3:&quot; + System.currentTimeMillis());
            countDownLatch.await();
            System.out.println(&quot;==========end,,时间t4:&quot; + System.currentTimeMillis());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
</code></pre><p>当i=0或1时,线程休眠1mis,打印出来的时间 <code>t3&lt;t2&lt;t0&lt;=t1&lt;=t4</code>,t2小于t0、t1很好理解,由于t0、t1所在线程休眠导致值变大,而t2、t1、t0为何处于(t3,t4]之间呢,原来由于子线程中任务完成时计数值减1操作,但是线程0、1休眠了1mis才完成任务并计数值减1,所以主线程一致等到线程0、1完成后才继续执行.将上面代码改动如下:</p>
<pre><code>        CountDownLatch countDownLatch = new CountDownLatch(3);
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 3; i++) &#123;
            int finalI = i;
            executorService.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    if (finalI == 0 || finalI == 1) &#123;
                        try &#123;
                            Thread.sleep(1000);
                        &#125; catch (InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;

                    System.out.println(&quot;任务执行结束啦,i:&quot; + finalI + &quot;,&quot; + &quot;时间t&quot; + finalI + &quot;:&quot; + System.currentTimeMillis());
                    countDownLatch.countDown();

                &#125;
            &#125;);
        &#125;
        try &#123;
            System.out.println(&quot;==========start,时间t3:&quot; + System.currentTimeMillis());
            countDownLatch.await(100,TimeUnit.MILLISECONDS);
            System.out.println(&quot;==========end,,时间t4:&quot; + System.currentTimeMillis());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
</code></pre><p>执行后发现,<code>t3&lt;t2&lt;t4&lt;t0&lt;=t1</code>,t2、t3的大小不能确定,这个很好理解,但是t4肯定是小于t0、t1的,因为使用了带超时时间的<code>await</code>,由于主线程等待的超时阈值是100毫秒,而线程t0、t1的休眠时间大于超时时间,所以主线程不会继续等待,超时后主线程继续执行.</p>
<blockquote>
<p>本文参考</p>
</blockquote>
<p><a href="https://www.cnblogs.com/skywang12345/p/3533887.html">https://www.cnblogs.com/skywang12345/p/3533887.html</a><br><a href="https://www.jianshu.com/p/7c7a5df5bda6">https://www.jianshu.com/p/7c7a5df5bda6</a></p>
]]></content>
      <categories>
        <category>并发包</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM(6)——类加载器</title>
    <url>/2019/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-6-%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文转自 <a href="https://crowhawk.github.io/2017/08/21/jvm_6/">https://crowhawk.github.io/2017/08/21/jvm_6/</a></p>
</blockquote>
<p>虚拟机设计团队把类加载阶段中的<strong>“通过一个类的全限定名来获取描述此类的二进制字节流(即字节码)”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为<strong>“类加载器”</strong>。</p>
<p>一般来说，Java 虚拟机使用 Java 类的方式如下：</p>
<ol>
<li><strong>Java 源程序（.java 文件）</strong>在经过 Java 编译器<strong>编译</strong>之后就被转换成<strong>字节码（.class 文件）</strong>。</li>
<li>类加载器负责读取 Java 字节代码，并转换成 <code>java.lang.Class</code>类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 <code>newInstance()</code>方法就可以创建出该类的一个对象。</li>
</ol>
<p>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。更详细的内容可以参考上一篇文章中讲类加载过程中的加载阶段时介绍的几个例子（JAR包、Applet、动态代理、JSP等）。</p>
<h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><p>类加载器虽然只用于实现类的加载动作，但它在Java程序起到的作用却远大于类加载阶段。对于任意一个类，都需要由<strong>加载它的类加载器和这个类本身</strong>一同确立<strong>其在Java虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。通俗而言：比较两个类是否“相等”（这里所指的“相等”，包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof()关键字对做对象所属关系判定等情况），只有在这两个类时由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>从jvm的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>，这个类加载器用C++实现，是虚拟机自身的一部分；</li>
<li><strong>所有其他类的加载器</strong>，这些类由Java实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</li>
</ul>
<p>从Java开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong> 此类加载器负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong> 这个类加载器是由<code>ExtClassLoader（sun.misc.Launcher$ExtClassLoader）</code>实现的。它负责将<code>&lt;Java_Home&gt;/lib/ext</code>或者被 <code>java.ext.dir</code>系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong> 这个类加载器是由 <code>AppClassLoader（sun.misc.Launcher$AppClassLoader）</code>实现的。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值，因此一般称为<strong>系统类加载器</strong>。它负责加载<strong>用户类路径（ClassPath）</strong>上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>由开发人员开发的应用程序都是由这三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器的关系一般如下图所示：</p>
<p><img src="https://pic.yupoo.com/crowhawk/188f5d64/26536d6a.png" alt=""></p>
<p>上图展示的类加载器之间的层次关系，称为类加载器的<strong>双亲委派模型（Parents Delegation Model）</strong>。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过<strong>组合（Composition）</strong>关系来实现，而不是通过继承（Inheritance）的关系实现。</p>
<p><strong>工作过程</strong></p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归，因此所有的加载请求<strong>最终都应该传送到顶层的启动类加载器中</strong>，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。</p>
<p><strong>优点</strong></p>
<p>使用双亲委派模型来组织类加载器之间的关系，使得Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>。例如类<code>java.lang.Object</code>，它存放再<code>rt.jar</code>中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p>
<p>相反，如果没有双亲委派模型，由各个类加载器自行加载的话，如果用户编写了一个称为｀<code>java.lang.Object</code>的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，程序将变得一片混乱。如果开发者尝试编写一个与<code>rt.jar</code>类库中已有类重名的Java类，将会发现可以正常编译，但是永远无法被加载运行。</p>
<p>双亲委派模型的实现如下：</p>
<pre><code>protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException&#123;
    //check the class has been loaded or not
    Class c = findLoadedClass(name);
    if(c == null)&#123;
        try&#123;
            if(parent != null)&#123;
                c = parent.loadClass(name,false);
            &#125;else&#123;
                c = findBootstrapClassOrNull(name);
            &#125;
        &#125;catch(ClassNotFoundException e)&#123;
            //if throws the exception ,the father can not complete the load
        &#125;
        if(c == null)&#123;
            c = findClass(name);
        &#125;
    &#125;
    if(resolve)&#123;
        resolveClass(c);
    &#125;
    return c;
&#125;
</code></pre><h1 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h1><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>双亲委派模型并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多<strong>服务提供者接口（Service Provider Interface，SPI）</strong>，允许第三方为这些接口提供实现。常见的 SPI 有 <strong>JDBC、JCE、JNDI、JAXP 和 JBI</strong> 等。这些 <strong>SPI 的接口由 Java 核心库来提供</strong>，如 JAXP 的 SPI 接口定义包含在 <code>javax.xml.parsers</code>包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 <strong>jar 包</strong>被包含进来，可以通过类路径（ClassPath）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。<strong>SPI 接口中的代码经常需要加载具体的实现类。</strong>如 JAXP 中的 <code>javax.xml.parsers.DocumentBuilderFactory</code>类中的 <code>newInstance()</code> 方法用来生成一个新的 <code>DocumentBuilderFactory</code> 的实例。这里的实例的真正的类是继承自 <code>javax.xml.parsers.DocumentBuilderFactory</code>，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，<strong>SPI 的接口</strong>是<strong>Java 核心库</strong>的一部分，是<strong>由引导类加载器加载</strong>的，而<strong>SPI 实现的 Java 类</strong>一般是<strong>由系统类加载器加载</strong>的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能委派给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的双亲委派模型无法解决这个问题。</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。线程上下文类加载器是从 JDK 1.2 开始引入的。类 <code>java.lang.Thread</code>中的方法 <code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>用来获取和设置线程的上下文类加载器。如果没有通过 <code>setContextClassLoader(ClassLoader cl)</code>方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是应用程序类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
<p>有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载器的动作，这种行为实际上就是<strong>打通了双亲委派模型的层次结构来逆向使用类加载器</strong>，已经违背了双亲委派模型的一般性原则。</p>
<h3 id="追求程序动态性"><a href="#追求程序动态性" class="headerlink" title="追求程序动态性"></a>追求程序动态性</h3><p>这里所说的“动态性”指的是当前一些非常热门的名词：<strong>代码热替换（HotSwap）</strong>、<strong>模块热部署(Hot Deployment)</strong>等。即希望应用程序能像计算机的外设一样，接上鼠标、键盘，不用重启就能立即使用，鼠标出了问题或需要升级就换个鼠标，不用停机或重启。</p>
<p>当前业界“事实上”的Java模块化标准是OSGi，而OSGi实现代码热部署的关键则是它自定义的类机载器的实现。关于OSGi的细节将在稍后的案例分析中详细讲解。</p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p><strong>API</strong></p>
<p><img src="https://pic.yupoo.com/crowhawk/6c13f82d/1b25cd13.png" alt=""></p>
<p>其中有如下三个比较重要的方法</p>
<p>方法</p>
<p>说明</p>
<p><strong>defineClass(String name, byte[] b, int off, int len)</strong></p>
<p>把字节数组 b中的内容转换成 Java 类，该字节数组可以看成是二进制流字节组成的文件，返回的结果是<code>java.lang.Class</code>类的实例。这个方法被声明为 final的。</p>
<p><strong>loadClass(String name)</strong></p>
<p>上文中已贴出源码，实现了双亲委派模型，调用<code>findClass()</code>执行类加载动作,返回的是<code>java.lang.Class</code>类的实例。</p>
<p><strong>findClass(String name)</strong></p>
<p>通过传入的类全限定名name来获取对应的类，返回的是<code>java.lang.Class</code>类的实例，该类没有提供具体的实现，开发者在自定义类加载器时需重用此方法，在实现此方法时需调用<code>defineClass(String name, byte[] b, int off, int len)</code>方法。</p>
<p>在了解完上述内容后，我们可以容易地意识到自定义类加载器有以下两种方式：</p>
<ul>
<li><strong>采用双亲委派模型</strong>：继承ClassLoader类，只需重写其的<code>findClass(String name)</code>方法，而不需重写<code>loadClass(String name)</code>方法。</li>
<li><strong>破坏双亲委派模型</strong>：继承ClassLoader类，需要整个重写实现了双亲委派模型逻辑的<code>loadClass(String name)</code>方法。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面我们来实现一个自定义类加载器，用来加载存储在文件系统上的 Java 字节代码。</p>
<pre><code>public class FileSystemClassLoader extends ClassLoader &#123; 

   private String rootDir; 

   public FileSystemClassLoader(String rootDir) &#123; 
       this.rootDir = rootDir; 
   &#125; 

   @Override
   protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; 
       byte[] classData = getClassData(name); 
       if (classData == null) &#123; 
           throw new ClassNotFoundException(); 
       &#125; 
       else &#123; 
           return defineClass(name, classData, 0, classData.length); 
       &#125; 
   &#125; 

   private byte[] getClassData(String className) &#123; 
       String path = classNameToPath(className); 
       try &#123; 
           InputStream ins = new FileInputStream(path); 
           ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
           int bufferSize = 4096; 
           byte[] buffer = new byte[bufferSize]; 
           int bytesNumRead = 0; 
           while ((bytesNumRead = ins.read(buffer)) != -1) &#123; 
               baos.write(buffer, 0, bytesNumRead); 
           &#125; 
           return baos.toByteArray(); 
       &#125; catch (IOException e) &#123; 
           e.printStackTrace(); 
       &#125; 
       return null; 
   &#125; 

   private String classNameToPath(String className) &#123; 
       return rootDir + File.separatorChar 
               + className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;; 
   &#125; 
&#125;
</code></pre><p>类 FileSystemClassLoader的 <code>findClass()</code>方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 <code>java.lang.Class</code>类的实例。</p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h3 id="Tomcat：正统的类加载器架构"><a href="#Tomcat：正统的类加载器架构" class="headerlink" title="Tomcat：正统的类加载器架构"></a>Tomcat：正统的类加载器架构</h3><p>主流的Java Web服务器如Tomcat、Jetty、WebLogic、WebSphere等等，都实现了自己定义的类加载器（一般都不止一个）。因为一个功能健全的Web服务器，要解决以下问题：</p>
<ul>
<li><strong>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。</strong> 两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以互相独立使用。</li>
<li><strong>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以相互共享。</strong> 例如，用户可能有5个使用Spring组织的应用程序部署在同一台服务器上，如果把5份Spring分别放在各个应用程序的隔离目录中，库在使用时都要被加载到服务器内存中，JVM的方法区就会有过度膨胀的风险。</li>
<li><strong>服务器需要尽可能保证自身安全不受部署的Web应用程序影响。</strong> 很多Web服务器本身是用Java实现的，服务器使用的类库应该与应用程序的类库相互独立。</li>
<li><strong>支持JSP应用的服务器，大多数需要支持代码热替换（HotSwap）功能。</strong> JSP文件由于其纯文本存储的特性，运行时修改的概率远大于第三方类库或程序自身的Class文件，因此需要做到修改后无须重启。</li>
</ul>
<p>鉴于上述问题，各种Web服务器都不约而同地提供了数个ClassPath路径供用户存放第三方类库，这些路径一般以“lib”或“classes”命名。以Tomcat为例，有3组目录（“<strong>/common/<em> ”、“/server/</em> ”和“/shared/* ”</strong>）可以存放Java类库，另外还可以加上Web应用程序自身的目录<strong>“/WEB-INF/* ”</strong>，一共4组，把Java类库放置在这些目录中的含义分别如下：</p>
<ul>
<li><strong>/common</strong>目录：类库可被Tomcat和所有的Web应用程序共同使用。</li>
<li><strong>/server</strong>目录：类库可被Tomcat使用，对所有的Web应用程序都不可见。</li>
<li><strong>/shared</strong>目录：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li>
<li><strong>/WebApp/WEB-INF</strong>目录：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li>
</ul>
<p>为了支持这套目录结构，并对目录里的类库进行加载和隔离，Tomcat采用如下经典的双亲委派模型来实现了多个类加载器：</p>
<p><img src="https://pic.yupoo.com/crowhawk/1f37efef/99e7eaa6.png" alt=""></p>
<p><strong>CommonClassLoader</strong>、<strong>CatalinaClassLoader</strong>、<strong>SharedClassLoader</strong>和<strong>WebappClassLoader</strong>是Tomcat自己定义的类加载器，它们分别加载<strong>/common/<em> 、/server/</em>、/shared/</strong>和/WebApp/WEB-INF/***中的Java类库。其中WebApp类加载器和JSP类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个JSP类加载器。</p>
<p><strong>CommonClassLoader</strong>能加载的类都可以被<strong>CatalinaClassLoader</strong>和<strong>SharedClassLoader</strong>使用，而<strong>CatalinaClassLoader</strong>和<strong>SharedClassLoader</strong>自己能加载的类则与对方相互隔离。<strong>WebAppClassLoader</strong>可以使用<strong>SharedClassLoader</strong>加载到的类，但各个<strong>WebAppClassLoader</strong>实例之间相互隔离。而<strong>JasperLoader</strong>的加载范围仅是这个JSP文件编译出来的那一个Class，它出现的目的就是被丢弃。当服务器检测到JSP文件被修改时，会替换掉目前的<strong>JasperLoader</strong>的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。</p>
<p><strong>特殊场景</strong></p>
<p>前文提到过一个场景，如果有5个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放到<strong>Common</strong>或<strong>Shared</strong>目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户程序放在<strong>/WebApp/WEB-INF</strong>目录中，这时就需要破坏双亲委派模型，使用线程上下文类加载器来完成这一工作了。</p>
<h3 id="OSGi：类加载器的灵活运用"><a href="#OSGi：类加载器的灵活运用" class="headerlink" title="OSGi：类加载器的灵活运用"></a>OSGi：类加载器的灵活运用</h3><p><strong>OSGi（Open Service Gateway Initiative）</strong>是OSGi联盟制定的一个基于Java语言的动态模块化规范，现在成为了Java“事实上”的<strong>模块化标准</strong>。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持，其中最为著名的应用莫过于大家都很熟悉的Eclipse IDE。</p>
<p>OSGi 中的每个<strong>模块（bundle）</strong>都包含 <strong>Java Package和Class</strong>。模块可以声明它所依赖的需要<strong>导入（import）</strong>的其它模块的 Java 包和类（通过 <strong>Import-Package</strong>），也可以声明<strong>导出（export）</strong>自己的包和类，供其它模块使用（通过 <strong>Export-Package</strong>）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。</p>
<p><strong>OSGi 中的每个模块都有对应的一个类加载器</strong>，它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。<strong>当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。</strong>模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 <code>org.osgi.framework.bootdelegation</code>的值即可。</p>
<p>假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 ClassLoaderA 和 ClassLoaderB。在 bundleA 中包含类 com.bundleA.Sample，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 <code>com.bundleA.Sample</code>，并包含一个类 <code>com.bundleB.NewSample</code>继承自 <code>com.bundleA.Sample</code>。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 <code>com.bundleB.NewSample</code>，进而需要加载类 <code>com.bundleA.Sample</code>。由于 bundleB 声明了类 <code>com.bundleA.Sample</code>是导入的，classLoaderB 把加载类 <code>com.bundleA.Sample</code>的工作代理给导出该类的 bundleA 的类加载器 ClassLoaderA。ClassLoaderA 在其模块内部查找类 <code>com.bundleA.Sample</code>并定义它，所得到的类 <code>com.bundleA.Sample</code>实例就可以被所有声明导入了此类的模块使用。对于以 java开头的类，都是由父类加载器来加载的。如果声明了系统属性 <code>org.osgi.framework.bootdelegation=com.example.core.*</code>，那么对于包 <code>com.example.core</code>中的类，都是由父类加载器来完成的。 OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议：</p>
<ul>
<li>如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。</li>
<li>如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。</li>
<li>如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 <code>Thread.currentThread().getContextClassLoader()</code>就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 <code>class.getClassLoader()</code>来得到模块对应的类加载器，再通过 <code>Thread.currentThread().setContextClassLoader()</code>来设置当前线程的上下文类加载器。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/24722612/">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6">深入探讨 Java 类加载器－成富</a></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM(5)——虚拟机类加载机制</title>
    <url>/2019/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-5-%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>本文转自 <a href="https://crowhawk.github.io/2017/08/21/jvm_5/">https://crowhawk.github.io/2017/08/21/jvm_5/</a></p>
</blockquote>
<blockquote>
<p>在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机中，而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机中会发生什么变化？本文将逐步解答这些问题。</p>
</blockquote>
<h1 id="类加载过程概览"><a href="#类加载过程概览" class="headerlink" title="类加载过程概览"></a>类加载过程概览</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括以下7个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p>其中前五个阶段即为类加载的全过程。在后面会进行详细的介绍。而验证、准备、解析3个部分统称为<strong>连接（Linking）</strong>。这7个阶段的发生顺序如下图：</p>
<p><img src="https://pic.yupoo.com/crowhawk/2a1c6490/d926d9a2.png" alt=""></p>
<p>在上图中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（开始而不是完成，这些阶段是互相交叉着进行的，在一个阶段执行过程中就会激活另一个阶段），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的<strong>运行时绑定（也称为动态绑定或晚期绑定）</strong>。</p>
<h1 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h1><p>对于类加载过程的第一个阶段：加载，jvm规范中并没有进行强制约束其开始时机，可交由jvm的具体实现来自由把握。但是对于初始化阶段，jvm规范严格规定了有且只有下列5种情况必须对类进行<strong>“初始化”</strong>（很自然地，加载、验证、准备需要在此之前开始）：</p>
<ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这4条指令的场景是：<strong>使用new关键字实例化对象</strong>的时候；<strong>读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）</strong>的时候；以及<strong>调用一个类的静态方法</strong>的时候。</li>
<li>使用 <code>java.lang.reflect</code>包的方法对类进行<strong>反射调用</strong>的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要制定一个要执行的<strong>主类（包含main方法的那个类）</strong>，虚拟机会先初始化这个主类；</li>
<li>当使用jdk1.7 的<strong>动态语言支持</strong>时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic</code>, <code>REF_putStatic</code>, <code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<p>以上5种场景中的行为称为对一个类进行<strong>主动引用</strong>。除此之外，所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用<strong>父类的静态字段</strong>，不会导致子类初始化。</li>
<li>通过<strong>数组定义</strong>来引用类，不会触发此类的初始化，如<code>SuperClass[] sca = new SuperClass[10];</code>。</li>
<li><strong>常量</strong>在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<p><strong>接口的加载过程</strong>和类加载过程略有不同，它们真正的区别在于在前文提到的5种需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其<strong>父接口</strong>全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h1 id="类加载过程详解"><a href="#类加载过程详解" class="headerlink" title="类加载过程详解"></a>类加载过程详解</h1><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>加载</strong>是<strong>类加载（Class Loading）</strong>过程的一个阶段，两者不要混淆。虚拟机规范规定了在在加载阶段，jvm需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的<strong>二进制字节流</strong>。</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时存储结构</strong>。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种<strong>数据的访问入口</strong>。</li>
</ul>
<p>这三点要求不算具体，在jvm实现时灵活度很大。例如上面的第一条，它没有指明二进制字节流要从一个Class文件中获取，准确地说没有指明要从哪里获取、怎样获取。这也为许多Java技术提供了基础，例如：</p>
<ul>
<li>从ZIP包读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用是Applet。</li>
<li>运行时计算生成，这种场景使用得最多得就是<strong>动态代理</strong>技术，在<code>java.lang.reflect.Proxy</code>中，就是用了<code>ProxyGenerator.generateProxyClass</code>的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是<strong>JSP应用</strong>，即由JSP文件生成对应的Class类。</li>
<li>从数据库读取，这种场景相对少见，例如有些<strong>中间件服务器</strong>（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<p><strong>非数组类的加载</strong></p>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中<strong>获取类的二进制字节流的动作</strong>）是开发人员可控性最强的，因为加载阶段既可以使用<strong>系统提供的引导类加载器</strong>完成，也可以由<strong>用户自定义的类加载器</strong>完成，通过自定义类加载器去控制字节流的获取方式，即重写一个类加载器的<code>loadClass()</code>方法。关于类加载器的内容将在系列的下一篇文章中介绍。</p>
<p><strong>数组类的加载</strong></p>
<p><strong>数组类本身不通过类加载器创建，它是由jvm直接创建的。</strong>但数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数据类C的创建过程遵循以下规则：</p>
<ul>
<li>如果数组的<strong>组件类型</strong>（ComponentType，指的是数组去掉一个维度的类型）是<strong>引用类型</strong>，就递归采用本节中定义的加载过程去加载此组件类型，<strong>数组类将在加载该组件类型的类加载器的类名称空间上被标识</strong>（这很重要，在下一篇文章中会讲到，一个类必须与类加载器一起确定唯一性）。</li>
<li>如果数组的<strong>组件类型不是引用类型</strong>（例如int[]数组），Java虚拟机将会把数组类标记为与<strong>引导类加载器</strong>关联。</li>
<li>数组类的<strong>可见性</strong>与它的<strong>组件类型</strong>的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</li>
</ul>
<p><strong>加载阶段完成后</strong>，虚拟机<strong>外部的二进制字节流</strong>就按照虚拟机所需的格式<strong>存储在方法区之中</strong>，方法区的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中<strong>实例化一个<code>java.lang.Class</code>类的对象</strong>（并无明确规定是在Java 堆中，<strong>对于HotSpot虚拟机而言，Class对象比较特殊，它虽是对象，但存放在方法区里</strong>），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保<strong>输入的Class文件的字节流能正确地解析并存储于方法区之内</strong>，格式上符合描述一个Java类型信息的要求，并且不会危害虚拟机自身的安全。验证阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击。 从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<p><strong>1. 文件格式验证</strong></p>
<p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主次版本号是否在当前虚拟机的处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 ……</li>
</ul>
<p>这阶段的验证是<strong>基于二进制字节流</strong>进行的，只有通过了这个阶段的验证后，字节流才会<strong>进入方法区中进行存储</strong>，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p>
<p><strong>2. 元数据验证</strong></p>
<p>第二阶段是对<strong>字节码描述的信息（即类的元数据信息）</strong>进行<strong>语义分析</strong>，以保证其描述的信息符合Java语言规范的要求。例如下面这些验证点：</p>
<ul>
<li>该类是否有父类（除了<code>java.lang.Object</code>之外，所有的类都应有父类）</li>
<li>该类的父类是否继承了不允许被继承的类（final修饰的类）</li>
<li>若此类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法 ……</li>
</ul>
<p>该阶段的主要目的是对类的元数据信息进行<strong>语义检验</strong>，保证不存在不符合Java语言规范的元数据信息。</p>
<p><strong>3. 字节码验证</strong></p>
<p>第三阶段的主要目的是<strong>进行数据流和控制流分析</strong>，确定程序<strong>语义</strong>是合法的、符合逻辑的。在<strong>第二阶段</strong>对元数据信息中的<strong>数据类型</strong>做完校验之后，这个阶段将对<strong>类的方法体</strong>进行校验分析，以保证<strong>被校验类的方法</strong>在运行时不会做出危害虚拟机安全的行为。例如：</p>
<ul>
<li>保证任意时刻操作数栈的<strong>数据类型</strong>与<strong>指令代码序列</strong>都能配合工作。</li>
<li>保证<strong>跳转指令</strong>不会跳转到方法体以外的字节码指令上。</li>
<li>保证<strong>方法体中类型转换</strong>是有效的，例如子类对象可以赋值给父类数据类型，但父类对象赋值给子类数据类型是危险和不合法的。 ……</li>
</ul>
<p><strong>4. 符号引用验证</strong></p>
<p>最后一个阶段的校验发生在虚拟机将<strong>符号引用</strong>转化为<strong>直接引用</strong>的时候，<strong>这个转化动作将在连接的第三阶段——解析阶段中发生</strong>。符号引用验证可以看做是<strong>对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</strong>，通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>指定的类中是否存在符合描述符与简单名称描述的方法与字段。</li>
<li>符号引用中的类、字段、方法的<strong>访问性</strong>（private、protected、public、default）是否可被当前类访问。 ……</li>
</ul>
<p>符号引用的目的是<strong>确保解析动作能正常执行</strong>。</p>
<p>对于jvm的类加载机制来说，验证阶段是一个非常重要但不是一定必要（因为对运行期没有影响）的阶段。如果所运行的全部代码都已经被反复验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段的主要任务是如下两点：</p>
<ul>
<li><strong>为类变量分配内存</strong></li>
<li><strong>设置类变量初始值</strong></li>
</ul>
<p>这些变量所使用的内存都将在<strong>方法区</strong>中分配。</p>
<p>首先，在准备阶段进行内存分配的仅包括<strong>类变量（被static修饰的变量）</strong>，而不包括<strong>实例变量</strong>，实例变量将会在<strong>对象实例化</strong>时随着对象一起分配在Java堆中。</p>
<p>其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<pre><code>public static int value = 123;
</code></pre><p>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把value赋值为123的动作在初始化阶段才会执行。 值得注意的是，如果类字段的字段属性中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：</p>
<pre><code>public static final int value = 123;
</code></pre><p><strong>编译时</strong>Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将<strong>常量池</strong>内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。符号引用和直接引用的关联如下：</p>
<ul>
<li><strong>符号引用（Symbol References）</strong>： 符号引用<strong>以一组符号来描述所引用的目标</strong>，<strong>符号</strong>可以是<strong>任何形式的字面量</strong>，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关</strong>，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致，因为<strong>符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中</strong>。</li>
<li><strong>直接引用（Direct References）</strong>： 直接引用可以是<strong>直接目标的指针</strong>、<strong>相对偏移量</strong>或是一个<strong>能间接定位到目标的句柄</strong>。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在。</li>
</ul>
<p>虚拟机规范并未规定解析动作发生的具体时间，仅要求在执行anewarray、checkcast、getfield、getstatic、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<p><strong>对同一个符号引用进行多次解析请求</strong>是很常见的，除 invokedynamic 指令外（ invokedynamic指令是用于动态语言支持的，它所对应的引用称为<strong>“动态调用点限定符”</strong>，必须等到程序实际运行到这条指令的时候，解析动作才能进行）虚拟机实现可能会对第一次解析的结果进行<strong>缓存（将直接引用保存在运行时常量池中）</strong>，无论是否真正执行了多次解析动作，虚拟机实现必须保证在同一个实体中，如果一个符号引用之前已经被成功解析过，后续的引用解析请求就应当一直成功，反之亦然。</p>
<p>解析动作主要针对以下7类符号引用</p>
<ul>
<li>类或接口</li>
<li>字段</li>
<li>类方法（静态方法）</li>
<li>接口方法</li>
<li>方法类型</li>
<li>方法句柄</li>
<li>调用点限定符</li>
</ul>
<p>其中后三种与java的动态语言支持息息相关。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是“类加载过程”中最后一步，在之前的阶段，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其它动作完全由虚拟机主导和控制，直到初始化阶段，才真正开始<strong>执行类中定义的Java程序代码（或者说是字节码）</strong>。</p>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源，简单说，<strong>初始化阶段即虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</strong>。</p>
<p>下面来详细讲解<code>&lt;clinit&gt;()</code>方法是怎么生成的，首先来了解此方法执行过程中可能会影响到程序运行行为的特点和细节：</p>
<ul>
<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<p>public class Test {</p>
<pre><code>static &#123;
    i = 0;  //  给变量复制可以正常编译通过
    System.out.print(i);  // 这句编译器会提示“非法向前引用”  
&#125;
static int i = 1;
</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code> 方法）不同，不需要显式的调用父类的()方法。虚拟机会自动保证在子类的<code>&lt;clinit&gt;()</code>方法运行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行结束。因此虚拟机中第一个执行<code>&lt;clinit&gt;()</code>方法的类肯定为<code>java.lang.Object</code>。</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</p>
<p>static class Parent {</p>
<pre><code>    public static int A = 1;
    static &#123;
        A = 2;
    &#125;
</code></pre><p>}</p>
<p>static class Sub extends Parent {</p>
<pre><code>    public static int B = A;
</code></pre><p>}</p>
<p>public static void main(String[] args) {</p>
<pre><code>    System.out.println(Sub.B);//输出结果是父类中的静态变量值A，也就是2
</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><code>&lt;clinit&gt;()</code>方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其它线程都会阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/24722612/">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM(4)——如何优化Java GC「译」</title>
    <url>/2019/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-4-%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96Java-GC%E3%80%8C%E8%AF%91%E3%80%8D/</url>
    <content><![CDATA[<blockquote>
<p>本文转自 <a href="https://crowhawk.github.io/2017/08/21/jvm_4/">https://crowhawk.github.io/2017/08/21/jvm_4/</a></p>
</blockquote>
<p>本文翻译自Sangmin Lee发表在<a href="http://www.cubrid.org/blog">Cubrid</a>上的”Become a Java GC Expert”系列文章的第三篇<a href="http://www.cubrid.org/blog/how-to-tune-java-garbage-collection">《How to Tune Java Garbage Collection》</a>,本文的作者是韩国人，写在JDK 1.8发布之前，虽然有些地方有些许过时，但整体内容还是非常有价值的。译者此前也看到有人翻译了本文，发现其中有许多错漏生硬和语焉不详之处，因此决定自己翻译一份，供大家分享。<br>本文系本人独立翻译，转载请注明出处。</p>

<p>本文是“成为Java GC专家”系列文章的第三篇，在系列的第一篇文章<a href="http://www.cubrid.org/blog/understanding-java-garbage-collection">《理解Java GC》</a>中，我们了解到了不同GC算法的执行过程、GC的工作原理、新生代和老年代的概念、JDK 7中你需要了解的5种GC类型以及每一种GC对性能的影响。</p>

<p>在系列的第二篇文章<a href="http://www.cubrid.org/blog/how-to-monitor-java-garbage-collection">《如何监控Java GC》</a>中笔者已经解释了JVM进行实时GC的原理、监控GC的方法以及可以使这一过程更加迅速高效的工具。</p>

<p>在第三篇文章中，笔者将基于实际生产环境中的案例，介绍几个GC优化的最佳参数设置。在此我们假设你已经理解了本系列前两篇文章的内容，因此为了更深入的理解本文所讲内容，我建议你在阅读本篇文章之前先仔细阅读这两篇文章。</p><br><h1 id="gc优化是必要的吗">GC优化是必要的吗？</h1><br><p>或者更准确地说，GC优化对Java基础服务来说是必要的吗？答案是否定的，事实上GC优化对Java基础服务来说在有些场合是可以省去的，但前提是这些正在运行的Java系统，必须包含以下参数或行为：</p><br><ul><br>  <li>内存大小已经通过<strong>-Xms</strong>和<strong>-Xmx</strong>参数指定过</li><br>  <li>运行在server模式下（使用<strong>-server</strong>参数）</li><br>  <li>系统中没有残留超时日志之类的错误日志</li><br></ul><br><p>换句话说，如果你在运行时没有手动设置内存大小并且打印出了过多的超时日志，那你就需要对系统进行GC优化。</p>

<p>不过你需要时刻谨记一句话：<strong>GC tuning is the last task to be done.</strong></p>

<p>现在来想一想GC优化的最根本原因，垃圾收集器的工作就是清除Java创建的对象，垃圾收集器需要清理的对象数量以及要执行的GC数量均取决于已创建的对象数量。因此，为了使你的系统在GC上表现良好，首先需要减少创建对象的数量。</p>

<p>俗话说“冰冻三尺非一日之寒”，我们在编码时要首先要把下面这些小细节做好，否则一些琐碎的不良代码累积起来将让GC的工作变得繁重而难于管理：</p>

<ul><br>  <li>使用<code class="highlighter-rouge">StringBuilder</code>或<code class="highlighter-rouge">StringBuffer</code>来代替<code class="highlighter-rouge">String</code></li><br>  <li>尽量少输出日志</li><br></ul>

<p>尽管如此，仍然会有我们束手无策的情况。XML和JSON解析过程往往占用了最多的内存，即使我们已经尽可能地少用String、少输出日志，仍然会有大量的临时内存（大约10-100MB）被用来解析XML或JSON文件，但我们又很难弃用XML和JSON。在此，你只需要知道这一过程会占据大量内存即可。</p>

<p>如果在经过几次重复的优化后应用程序的内存用量情况有所改善，那么久可以启动GC优化了。</p>

<p>笔者总结了GC优化的两个目的：</p><br><ol><br>  <li><strong>将进入老年代的对象数量降到最低</strong></li><br>  <li><strong>减少Full GC的执行时间</strong></li><br></ol><br><br><h1 id="将进入老年代的对象数量降到最低">将进入老年代的对象数量降到最低</h1><br><br><p>除了可以在JDK 7及更高版本中使用的G1收集器以外，其他分代GC都是由Oracle JVM提供的。关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入老年代。也有一些对象由于占用内存过大，在Eden区被创建后会直接被传入老年代。老年代GC相对来说会比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率。你可能会以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。</p>

<h1 id="降低full-gc的时间">降低Full GC的时间</h1>

<p>Full GC的执行时间比Minor GC要长很多，因此，如果在Full GC上花费过多的时间（超过1s），将可能出现超时错误。</p><br><ul><br>  <li>如果<strong>通过减小老年代内存来减少Full GC时间</strong>，可能会引起<code class="highlighter-rouge">OutOfMemoryError</code>或者导致Full GC的频率升高。</li><br>  <li>另外，如果<strong>通过增加老年代内存来降低Full GC的频率</strong>，Full GC的时间可能因此增加。</li><br></ul><br><br><p>因此，<strong>你需要把老年代的大小设置成一个“合适”的值</strong>。</p>

<h1 id="影响gc性能的参数">影响GC性能的参数</h1>

<p>正如我在系列的第一篇文章<a href="http://www.cubrid.org/blog/understanding-java-garbage-collection">《理解Java GC》</a>末尾提到的，不要幻想着“如果有人用他设置的GC参数获取了不错的性能，我们为什么不复制他的参数设置呢？”，因为对于不用的Web服务，它们创建的对象大小和生命周期都不相同。</p>

<p>举一个简单的例子，如果一个任务的执行条件是A，B，C，D和E，另一个完全相同的任务执行条件只有A和B，那么哪一个任务执行速度更快呢？作为常识来讲，答案很明显是后者。</p>

<p>Java GC参数的设置也是这个道理，设置好几个参数并不会提升GC执行的速度，反而会使它变得更慢。<strong>GC优化的基本原则</strong>是将不同的GC参数应用到两个及以上的服务器上然后比较它们的性能，然后将那些被证明可以提高性能或减少GC执行时间的参数应用于最终的工作服务器上。</p>

<p>下面这张表展示了与内存大小相关且会影响GC性能的GC参数</p>

<center><strong>表1：GC优化需要考虑的JVM参数</strong></center>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆内存大小</td>
<td>-Xms</td>
<td>启动JVM时堆内存的大小</td>
</tr>
<tr>
<td>堆内存大小</td>
<td>-Xmx</td>
<td>堆内存最大限制</td>
</tr>
<tr>
<td>新生代空间大小</td>
<td>-XX:NewRatio</td>
<td>新生代和老年代的内存比</td>
</tr>
<tr>
<td></td>
<td>-XX:NewSize</td>
<td>新生代内存大小</td>
</tr>
<tr>
<td></td>
<td>-XX:SurvivorRatio</td>
<td>Eden区和Survivor区的内存比</td>
</tr>
</tbody>
</table>
<p>笔者在进行GC优化时最常用的参数是<code class="highlighter-rouge">-Xms</code>,<code class="highlighter-rouge">-Xmx</code>和<code class="highlighter-rouge">-XX:NewRatio</code>。<code class="highlighter-rouge">-Xms</code>和<code class="highlighter-rouge">-Xmx</code>参数通常是必须的，所以<code class="highlighter-rouge">NewRatio</code>的值将对GC性能产生重要的影响。</p>

<p>有些人可能会问<strong>如何设置永久代内存大小</strong>，你可以用<code class="highlighter-rouge">-XX:PermSize</code>和<code class="highlighter-rouge">-XX:MaxPermSize</code>参数来进行设置，但是要记住，只有当出现<code class="highlighter-rouge">OutOfMemoryError</code>错误时你才需要去设置永久代内存。</p>

<p>还有一个会影响GC性能的因素是<a href="https://crowhawk.github.io/2017/08/15/jvm_3/">垃圾收集器的类型</a>,下表展示了关于GC类型的可选参数（基于JDK 6.0）：</p>

<center><strong>表2：GC类型可选参数</strong></center>

<table>
<thead>
<tr>
<th>GC类型</th>
<th>参数</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial GC</td>
<td>-XX:+UseSerialGC</td>
<td></td>
</tr>
<tr>
<td>Parallel GC</td>
<td>-XX:+UseParallelGC</br>-XX:ParallelGCThreads=value</td>
<td></td>
</tr>
<tr>
<td>Parallel Compacting GC</td>
<td>-XX:+UseParallelOldGC</td>
<td></td>
</tr>
<tr>
<td>CMS GC</td>
<td>-XX:+UseConcMarkSweepGC</br>-XX:+UseParNewGC</br>-XX:+CMSParallelRemarkEnabled</br>-XX:CMSInitiatingOccupancyFraction=value</br>-XX:+UseCMSInitiatingOccupancyOnly</td>
<td></td>
</tr>
<tr>
<td>G1</td>
<td>-XX:+UnlockExperimentalVMOptions</br>-XX:+UseG1GC</td>
<td>在JDK 6中这两个参数必须配合使用</td>
</tr>
</tbody>
</table>
<p>除了G1收集器外，可以通过设置上表中每种类型第一行的参数来切换GC类型，最常见的非侵入式GC就是Serial GC，它针对客户端系统进行了特别的优化。</p><br><p>会影响GC性能的参数还有很多，但是上述的参数会带来最显著的效果，请切记，设置太多的参数并不一定会提升GC的性能。</p><br><h1 id="gc优化的过程">GC优化的过程</h1><br><p>GC优化的过程和大多数常见的提升性能的过程相似，下面是笔者使用的流程：</p><br><h4 id="1监控gc状态">1.监控GC状态</h4><br><p>你需要监控GC从而检查系统中运行的GC的各种状态，具体方法请查看系列的第二篇文章<a href="http://www.cubrid.org/blog/how-to-monitor-java-garbage-collection">《如何监控Java GC》</a></p><br><h4 id="2分析监控结果后决定是否需要优化gc">2.分析监控结果后决定是否需要优化GC</h4><br><p>在检查GC状态后，你需要分析监控结构并决定是否需要进行GC优化。如果分析结果显示运行GC的时间只有0.1-0.3秒，那么就不需要把时间浪费在GC优化上，但如果运行GC的时间达到1-3秒，甚至大于10秒，那么GC优化将是很有必要的。</p><br><p>但是，如果你已经分配了大约10GB内存给Java，并且这些内存无法省下，那么就无法进行GC优化了。在进行GC优化之前，你需要考虑为什么你需要分配这么大的内存空间，如果你分配了1GB或2GB大小的内存并且出现了<code class="highlighter-rouge">OutOfMemoryError</code>，那你就应该执行<strong>堆转储（heap dump）</strong>来消除导致异常的原因。</p><br><blockquote><br>  <p>注意：</p><br>  <p><strong>堆转储（heap dump）</strong>是一个用来检查Java内存中的对象和数据的内存文件。该文件可以通过执行JDK中的<code class="highlighter-rouge">jmap</code>命令来创建。在创建文件的过程中，所有Java程序都将暂停，因此，不要再系统执行过程中创建该文件。</p><br></blockquote><br><blockquote><br>  <p>你可以在互联网上搜索heap dump的详细说明。对于韩国读者，可以直接参考我去年发布的书：<a href="http://book.naver.com/bookdb/book_detail.nhn?bid=6654751">《The story of troubleshooting for Java developers and system operators》</a> (Sangmin Lee, Hanbit Media, 2011, 416 pages)</p><br></blockquote><br><h4 id="3设置gc类型内存大小">3.设置GC类型/内存大小</h4><br><p>如果你决定要进行GC优化，那么你需要选择一个GC类型并且为它设置内存大小。此时如果你有多个服务器，请如上文提到的那样，在每台机器上设置不同的GC参数并分析它们的区别。</p><br><h4 id="4分析结果">4.分析结果</h4><br><p>在设置完GC参数后就可以开始收集数据，请在收集至少24小时后再进行结果分析。如果你足够幸运，你可能会找到系统的最佳GC参数。如若不然，你还需要分析输出日志并检查分配的内存，然后需要通过不断调整GC类型/内存大小来找到系统的最佳参数。</p><br><h4 id="5如果结果令人满意将参数应用到所有服务器上并结束gc优化">5.如果结果令人满意，将参数应用到所有服务器上并结束GC优化</h4><br><p>如果GC优化的结果令人满意，就可以将参数应用到所有服务器上，并停止GC优化。</p><br><p>在下面的章节中，你将会看到上述每一步所做的具体工作。</p><br><h1 id="监控gc状态并分析结果">监控GC状态并分析结果</h1><br><p>在运行中的Web应用服务器（Web Application Server,WAS）上查看GC状态的最佳方式就是使用<code class="highlighter-rouge">jstat</code>命令。笔者在<a href="http://www.cubrid.org/blog/how-to-monitor-java-garbage-collection">《如何监控Java GC》</a>中已经介绍过了<code class="highlighter-rouge">jstat</code>命令，所以在本篇文章中我将着重关注数据部分。</p><br><p>下面的例子展示了某个还没有执行GC优化的JVM的状态（虽然它并不是运行服务器）。</p><br><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ jstat -gcutil 21719 1s<br>S0    S1    E    O    P    YGC    YGCT    FGC    FGCT GCT<br>48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673<br>48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673<br></code></pre></div></div><br><p>我们先看一下YGC（从应用程序启动到采样时发生 Young GC 的次数）和YGCT（从应用程序启动到采样时 Young GC 所用的时间(秒)），计算YGCT/YGC会得出，平均每次新生代的GC耗时50ms，这是一个很小的数字，通过这个结果可以看出，我们大可不必关注新生代GC对GC性能的影响。</p><br><p>现在来看一下FGC（   从应用程序启动到采样时发生 Full GC 的次数）和FGCT（从应用程序启动到采样时 Full GC 所用的时间(秒)），计算FGCT/FGC会得出，平均每次老年代的GC耗时19.68s。有可能是执行了三次Full GC，每次耗时19.68s，也有可能是有两次只花了1s,另一次花了58s。不管是哪一种情况，GC优化都是很有必要的。</p><br><p>使用<code class="highlighter-rouge">jstat</code>命令可以很容易地查看GC状态，但是分析GC的最佳方式是加上<code class="highlighter-rouge">-verbosegc</code>参数来生成日志。在之前的文章中笔者已经解释了如何分析这些日志。<strong>HPJMeter</strong>是笔者最喜欢的用于分析<code class="highlighter-rouge">-verbosegc</code>生成的日志的工具，它简单易用，使用HPJmeter可以很容易地查看GC执行时间以及GC发生频率。</p><br><p>此外，如果GC执行时间满足下列所有条件，就没有必要进行GC优化了：</p><br><ul><br>  <li>Minor GC执行非常迅速（50ms以内）</li><br>  <li>Minor GC没有频繁执行（大约10s执行一次）</li><br>  <li>Full GC执行非常迅速（1s以内）</li><br>  <li>Full GC没有频繁执行（大约10min执行一次）</li><br></ul><br><p>括号中的数字并不是绝对的，它们也随着服务的状态而变化。有些服务可能要求一次Full GC在0.9s以内，而有些则会放得更宽一些。因此，对于不同的服务，需要按照不同的标准考虑是否需要执行GC优化。</p><br><p>当检查GC状态时，不能只查看Minor GC和Full GC的时间，还必须要<strong>关注GC执行的次数</strong>。如果新生代空间太小，Minor GC将会非常频繁地执行（有时每秒会执行一次，甚至更多）。此外，传入老年代的对象数目会上升，从而导致Full GC的频率升高。因此，在执行<code class="highlighter-rouge">jstat</code>命令时，请使用<code class="highlighter-rouge">-gccapacity</code>参数来查看具体占用了多少空间。</p><br><h1 id="设置gc类型内存大小">设置GC类型/内存大小</h1><br><br><h4 id="设置gc类型">设置GC类型</h4><br><br><p>Oracle JVM有5种垃圾收集器，但是在JDK 7以前的版本中，你只能在Parallel GC, Parallel Compacting GC 和CMS GC之中选择，至于具体选择哪个，则没有具体的原则和规则。</p>

<p>既然这样的话，<strong>我们如何来选择GC呢？</strong>最好的方法是把三种都用上，但是有一点必须明确——CMS GC通常比其他并行（Parallel）GC都要快（这是因为CMS GC是并发的GC），如果确实如此，那只选择CMS GC就可以了，不过CMS GC也不总是更快，当出现<strong>concurrent mode failure</strong>时，CMS GC就会比并行GC更慢了。</p>

<p><big><strong>Concurrent mode failure</strong></big></p>

<p>现在让我们来深入地了解一下<strong>concurrent mode failure</strong>。</p>

<p>并行GC和CMS GC的最大区别是并行GC采用“标记-整理”(Mark-Compact)算法而CMS GC采用“标记-清除”(Mark-Sweep)算法（具体内容可参照译者的文章<a href="https://crowhawk.github.io/2017/08/10/jvm_2/">《GC算法与内存分配策略》</a>）,compact步骤就是通过移动内存来消除内存碎片，从而消除分配的内存之间的空白区域。</p>

<p>对于并行GC来说，无论何时执行Full GC，都会进行compact工作，这消耗了太多的时间。不过在执行完Full GC后，下次内存分配将会变得更快（因为直接顺序分配相邻的内存）。</p>

<p>相反，CMS GC没有compact的过程，因此CMS GC运行的速度更快。但是也是由于没有整理内存，在进行磁盘清理之前，内存中会有很多零碎的空白区域，这也导致没有足够的空间分配给大对象。例如，在老年代还有300MB可用空间，但是连一个10MB的对象都没有办法被顺序存储在老年代中，在这种情况下，会报出<strong>“concurrent mode failure”</strong>的warning，然后系统执行compact操作。但是CMS GC在这种情况下执行的compact操作耗时要比并行GC高很多，并且这还会导致另一个问题，关于<strong>“concurrent mode failure”</strong>的详细说明，可用参考Oracle工程师撰写的<a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs">《Understanding CMS GC Logs》</a>。</p>

<p>综上所述，你需要根据你的系统情况为其选择一个最适合的GC类型。</p>

<p>每个系统都有最适合它的GC类型等着你去寻找，如果你有6台服务器，我建议你每两个服务器设置相同的参数，然后加上<code class="highlighter-rouge">-verbosegc</code>参数再分析结果。</p>

<h4 id="设置内存大小">设置内存大小</h4>

<p>下面展示了内存大小、GC运行次数和GC运行时间之间的关系：</p>

<p><strong>大内存空间</strong></p><br><ul><br>  <li>减少了GC的次数</li><br>  <li>提高了GC的运行时间</li><br></ul><br><br><p><strong>小内存空间</strong></p><br><ul><br>  <li>增多了GC的次数</li><br>  <li>降低了GC的运行时间</li><br></ul><br><br><p>关于如何设置内存的大小，没有一个标准答案，如果服务器资源充足并且Full GC能在1s内完成，把内存设为10GB也是可以的，但是大部分服务器并不处在这种状态中，当内存设为10GB时，Full GC会耗时10-30s,具体的时间自然与对象的大小有关。</p>

<p>既然如此，<strong>我们该如何设置内存大小呢？</strong>通常我推荐设为500MB，这不是说你要通过<code class="highlighter-rouge">-Xms500m</code>和<code class="highlighter-rouge">-Xmx500m</code>参数来设置WAS内存。根据GC优化之前的状态，如果Full GC后还剩余300MB的空间，那么把内存设为1GB是一个不错的选择（300MB（默认程序占用）+ 500MB（老年代最小空间）+200MB（空闲内存））。这意味着你需要为老年代设置至少500MB空间，因此如果你有三个运行服务器，可以把它们的内存分别设置为1GB，1.5GB，2GB，然后检查结果。</p>

<p>理论上来说，GC执行速度应该遵循1GB&gt; 1.5GB&gt; 2GB，1GB内存时GC执行速度最快。然而，理论上的1GB内存Full GC消耗1s、2GB内存Full GC消耗2 s在现实里是无法保证的，实际的运行时间还依赖于服务器的性能和对象大小。因此，最好的方法是创建尽可能多的测量数据并监控它们。</p>

<p>在设置内存空间大小时，你还需要设置一个参数：<code class="highlighter-rouge">NewRatio</code>。<code class="highlighter-rouge">NewRatio</code>的值是新生代和老年代空间大小的比例。如果<code class="highlighter-rouge">XX:NewRatio=1</code>，则新生代空间:老年代空间=1:1，如果堆内存为1GB，则新生代:老年代=500MB:500MB。如果<code class="highlighter-rouge">NewRatio</code>等于2，则新生代:老年代=1:2，因此，<code class="highlighter-rouge">NewRatio</code>的值设置得越大，则老年代空间越大，新生代空间越小。</p><br><p>你可能会认为把<code class="highlighter-rouge">NewRatio</code>设为1会是最好的选择，然而事实并非如此，根据笔者的经验，当<code class="highlighter-rouge">NewRatio</code>设为2或3时，整个GC的状态表现得更好。</p><br><p><strong>完成GC优化最快地方法是什么？</strong>答案是比较性能测试的结果。为了给每台服务器设置不同的参数并监控它们，最好查看的是一或两天后的数据。当通过性能测试来进行GC优化时，你需要在不同的测试时保证它们有相同的负载和运行环境。然而，即使是专业的性能测试人员，想精确地控制负载也很困难，并且需要大量的时间准备。因此，更加方便容易的方式是直接设置参数来运行，然后等待运行的结果（即使这需要消耗更多的时间）。</p><br><h1 id="分析gc优化的结果">分析GC优化的结果</h1><br><p>在设置了GC参数和<code class="highlighter-rouge">-verbosegc</code>参数后，可以使用tail命令确保日志被正确地生成。如果参数设置得不正确或日志未生成，那你的时间就被白白浪费了。如果日志收集没有问题的话，在收集一或两天数据后再检查结果。最简单的方法是把日志从服务器移到你的本地PC上，然后用<strong>HPJMeter</strong>分析数据。</p><br><p>在分析结果时，请关注下列几点（这个优先级是笔者根据自己的经验拟定的，我认为选取GC参数时应考虑的最重要的因素是Full GC的运行时间。）：</p><br><ul><br>  <li>单次Full GC运行时间</li><br>  <li>单次Minor GC运行时间</li><br>  <li>Full GC运行间隔</li><br>  <li>Minor GC运行间隔</li><br>  <li>整个Full GC的时间</li><br>  <li>整个Minor GC的运行时间</li><br>  <li>整个GC的运行时间</li><br>  <li>Full GC的执行次数</li><br>  <li>Minor GC的执行次数</li><br></ul><br><p>找到最佳的GC参数是件非常幸运的，然而在大多数时候，我们并不会如此幸运，在进行GC优化时一定要小心谨慎，因为当你试图一次完成所有的优化工作时，可能会出现<code class="highlighter-rouge">OutOfMemoryError</code>错误。</p><br><h1 id="优化案例">优化案例</h1><br><p>到目前为止，我们一直在从理论上介绍GC优化，现在是时候将这些理论付诸实践了，我们将通过几个例子来更深入地理解GC优化。</p><br><h4 id="示例1">示例1</h4><br><p>下面这个例子是针对<strong>Service S</strong>的优化，对于最近刚开发出来的Service S，执行Full GC需要消耗过多的时间。</p><br><p>现在看一下执行<code class="highlighter-rouge">jstat -gcutil</code>的结果</p><br><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S0 S1 E O P YGC YGCT FGC FGCT GCT<br>12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993<br></code></pre></div></div><br><p>左边的Perm区的值对于最初的GC优化并不重要，而YGC参数的值更加对于这次优化更为重要。</p><br><p>平均执行一次Minor GC和Full GC消耗的时间如下表所示：</p>

<center><strong>表3：Service S的Minor GC 和Full GC的平均执行时间</strong></center>

<table>
<thead>
<tr>
<th>GC类型</th>
<th>GC执行次数</th>
<th>GC执行时间</th>
<th>平均值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minor GC</td>
<td>54</td>
<td>2.047s</td>
<td>37ms</td>
</tr>
<tr>
<td>Full GC</td>
<td>5</td>
<td>6.946s</td>
<td>1.389s</td>
</tr>
</tbody>
</table>
<p><strong>37ms</strong>对于Minor GC来说还不赖，但1.389s对于Full GC来说意味着当GC发生在数据库Timeout设置为1s的系统中时，可能会频繁出现超时现象。</p><br><p>首先，你需要检查开始GC优化前内存的使用情况。使用<code class="highlighter-rouge">jstat -gccapacity</code>命令可以检查内存用量情况。在笔者的服务器上查看到的结果如下：</p><br><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC PGCMN PGCMX PGC PC YGC FGC<br>212992.0 212992.0 212992.0 21248.0 21248.0 170496.0 1884160.0 1884160.0 1884160.0 1884160.0 262144.0 262144.0 262144.0 262144.0 54 5<br></code></pre></div></div><br><p>其中的关键值如下：</p><br><ul><br>  <li>新生代内存用量：212,992 KB</li><br>  <li>老年代内存用量：1,884,160 KB</li><br></ul><br><p>因此，除了永久代以外，被分配的内存空间加起来有2GB，并且新生代：老年代=1：9，为了得到比使用<code class="highlighter-rouge">jstat</code>更细致的结果，还需加上<code class="highlighter-rouge">-verbosegc</code>参数获取日志，并把三台服务器按照如下方式设置（除此以外没有使用任何其他参数）：</p><br><ul><br>  <li>NewRatio=2</li><br>  <li>NewRatio=3</li><br>  <li>NewRatio=4</li><br></ul><br><br><p>一天后我得到了系统的GC log，幸运的是，在设置完NewRatio后系统没有发生任何Full GC。</p>

<p><strong>这是为什么呢？</strong>这是因为大部分对象在创建后很快就被回收了，所有这些对象没有被传入老年代，而是在新生代就被销毁回收了。</p>

<p>在这样的情况下，就没有必要去改变其他的参数值了，只要选择一个最合适的<code class="highlighter-rouge">NewRatio</code>值即可。那么，<strong>如何确定最佳的NewRatio值呢？</strong>为此，我们分析一下每种<code class="highlighter-rouge">NewRatio</code>值下Minor GC的平均响应时间。</p>

<p>在每种参数下Minor GC的平均响应时间如下：</p><br><ul><br>  <li>NewRatio=2：45ms</li><br>  <li>NewRatio=3：34ms</li><br>  <li>NewRatio=4：30ms</li><br></ul><br><br><p>我们可以根据GC时间的长短得出NewRatio=4是最佳的参数值（尽管NewRatio=4时新生代空间是最小的）。在设置完GC参数后，服务器没有发生Full GC。</p>

<p>为了说明这个问题，下面是服务执行一段时间后执行<code class="highlighter-rouge">jstat –gcutil</code>的结果:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S0 S1 E O P YGC YGCT FGC FGCT GCT<br>8.61 0.00 30.67 24.62 22.38 2424 30.219 0 0.000 30.219<br></code></pre></div></div>

<p>你可能会认为是服务器接收的请求少才使得GC发生的频率较低，实际上，虽然Full GC没有执行过，但Minor GC被执行了2424次。</p>

<h4 id="示例2">示例2</h4>

<p>这是一个Service A的例子。我们通过公司内部的应用性能管理系统（APM）发现JVM暂停了相当长的时间（超过8秒），因此我们进行了GC优化。我们努力寻找JVM暂停的原因，后来发现是因为Full GC执行时间过长，因此我们决定进行GC优化。</p>

<p>在GC优化的开始阶段，我们加上了<code class="highlighter-rouge">-verbosegc</code>参数，结果如下图所示：</p>

<center><img src="https://pic.yupoo.com/crowhawk/ebb4b181/a24f4e9b.png" /></center>

<center><strong>图1：进行GC优化之前STW的时间</strong></center>

<p>上图是由HPJMeter生成的图片之一。横坐标表示JVM执行的时间，纵坐标表示每次GC的时间。CMS为绿点，表示Full GC的结果，而Parallel Scavenge为蓝点，表示Minor GC的结果。</p>

<p>之前我说过CMS GC是最快的GC，但是上面的结果显示在一些时候CMS耗时达到了15s。<strong>是什么导致了这一结果？</strong>请记住我之前说的：CMS在执行compact（整理）操作时会显著变慢。此外，服务的内存通过<code class="highlighter-rouge">-Xms1g</code>和<code class="highlighter-rouge">=Xmx4g</code>设置了，而分配的内存只有4GB。</p>

<p>因此笔者将GC类型从CMS GC改为了Parallel GC，把内存大小设为2GB，并把<code class="highlighter-rouge">NewRatio</code>设为3。在执行<code class="highlighter-rouge">jstat -gcutil</code>几小时后的结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S0 S1 E O P YGC YGCT FGC FGCT GCT<br>0.00 30.48 3.31 26.54 37.01 226 11.131 4 11.758 22.890<br></code></pre></div></div>

<p>Full GC的时间缩短了，变成了每次3s，跟15s比有了显著提升。但是3s依然不够快，为此笔者创建了以下6种情况：</p><br><ul><br>  <li>Case 1: <code class="highlighter-rouge">-XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=2</code></li><br>  <li>Case 2: <code class="highlighter-rouge">-XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=3</code></li><br>  <li>Case 3: <code class="highlighter-rouge">-XX:+UseParallelGC -Xms1g -Xmx1g -XX:NewRatio=3</code></li><br>  <li>Case 4: <code class="highlighter-rouge">-XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=2</code></li><br>  <li>Case 5: <code class="highlighter-rouge">-XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=3</code></li><br>  <li>Case 6: <code class="highlighter-rouge">-XX:+UseParallelOldGC -Xms1g -Xmx1g -XX:NewRatio=3</code></li><br></ul><br><br><p><strong>上面哪一种情况最快？</strong>结果显示，内存空间越小，运行结果最少。下图展示了性能最好的Case 6的结果图，它的最慢响应时间只有1.7s，并且响应时间的平均值已经被控制到了1s以内。</p>

<center><img src="https://pic.yupoo.com/crowhawk/026cb5ec/dd3bdbb9.png" /></center>

<center><strong>图2：Case 6的持续时间图</strong></center>

<p>基于上图的结果，按照Case 6调整了GC参数，但这却导致每晚都会发生<code class="highlighter-rouge">OutOfMemoryError</code>。很难解释发生异常的具体原因，简单地说，应该是批处理程序导致了内存泄漏，我们正在解决相关的问题。</p>

<p>如果只对GC日志做一些短时间的分析就将相关参数部署到所有服务器上来执行GC优化，这将是非常危险的。切记，只有当你同时仔细分析服务的执行情况和GC日志后，才能保证GC优化没有错误地执行。</p>

<p>在上文中，我们通过两个GC优化的例子来说明了GC优化是怎样执行的。正如上文中提到的，例子中设置的GC参数可以设置在相同的服务器之上，但前提是他们具有相同的CPU、操作系统、JDK版本并且运行着相同的服务。此外，不要把我使用的参数照搬到你的应用上，它们可能在你的机器上并不能起到同样良好的效果。</p>

<h1 id="总结">总结</h1>

<p>笔者没有执行heap dump并分析内存的详细内容，而是通过自己的经验进行GC优化。精确地分析内存可以得到更好的优化效果，不过这种分析一般只适用于内存使用量相对固定的场景。如果服务严重过载并占有了大量的内存，则建议你根据之前的经验进行GC优化。</p>

<p>笔者已经在一些服务上设置了G1 GC参数并进行了性能测试，但还没有应用于正式的生产环境。G1 GC的速度快于任何其他的GC类型，但是你必须要升级到JDK 7。此外，暂时还无法保证它的稳定性，没有人知道运行时是否会出现致命的错误，因此G1<br>GC暂时还不适合投入应用。</p>

<p>等未来JDK 7真正稳定了（这并不是说它现在不稳定），并且WAS针对JDK 7进行优化后，G1 GC最终能按照预期的那样来工作，等到那一天我们可能就不再需要GC优化了。</p>

<p>想了解关于GC优化的更多细节，请前往<a href="https://www.slideshare.net/">Slideshare.com</a> 查看相关资料。强烈推荐<a href="https://www.slideshare.net/aszegedi/everything-i-ever-learned-about-jvm-performance-tuning-twitter">Everything I Ever Learned About JVM Performance Tuning @Twitter</a>,作者是Attila Szegedi, 一名Twitter工程师，请花些时间好好阅读它。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM(3)——7种垃圾收集器</title>
    <url>/2019/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-%E2%80%94%E2%80%947%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文转自 <a href="https://crowhawk.github.io/2017/08/15/jvm_3/">https://crowhawk.github.io/2017/08/15/jvm_3/</a></p>
</blockquote>
<p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：</p></p>
<center><img src="https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg" /></center>

<p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。</p>

<h1 id="相关概念">相关概念</h1>

<h4 id="并行和并发">并行和并发</h4>

<ul><br>  <li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><br>  <li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li><br></ul>

<h4 id="吞吐量throughput">吞吐量（Throughput）</h4>

<p>吞吐量就是<strong>CPU用于运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值，即</p>

<p><strong>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</strong></p>

<p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>

<h4 id="minor-gc-和-full-gc">Minor GC 和 Full GC</h4>

<ul><br>  <li><strong>新生代GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。</li><br>  <li><strong>老年代GC（Major GC / Full GC）</strong>：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li><br></ul>

<h1 id="新生代收集器">新生代收集器</h1>

<h4 id="serial收集器">Serial收集器</h4>

<p><strong>Serial（串行）</strong>收集器是最基本、发展历史最悠久的收集器，它是采用<strong>复制算法</strong>的<strong>新生代收集器</strong>，曾经（JDK 1.3.1之前）是虚拟机<strong>新生代</strong>收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是<strong>它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）</strong>。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。</p>

<p>下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：</p>

<center><img src="https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png" /></center>

<p>为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是H<strong>otSpot虚拟机运行在Client模式下的默认的新生代收集器</strong>。它也有着优于其他收集器的地方：<strong>简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</strong></p>

<p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>

<h4 id="parnew-收集器">ParNew 收集器</h4>

<p><strong>ParNew</strong>收集器就是Serial收集器的多线程版本，它也是一个<strong>新生代收集器</strong>。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。</p>

<p>ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：</p>

<center><img src="https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png" /></center>

<p>ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，<strong>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作</strong>，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。</p>

<p>ParNew 收集器在<strong>单CPU的环境</strong>中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在<strong>多CPU环境</strong>下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用<strong>-XX:ParallerGCThreads</strong>参数设置。</p>

<h4 id="parallel-scavenge-收集器">Parallel Scavenge 收集器</h4>

<p><strong>Parallel Scavenge</strong>收集器也是一个<strong>并行</strong>的<strong>多线程新生代</strong>收集器，它也使用<strong>复制算法</strong>。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是<strong>达到一个可控制的吞吐量（Throughput）</strong>。</p>

<p><strong>停顿时间越短就越适合需要与用户交互的程序</strong>，良好的响应速度能提升用户体验。而<strong>高吞吐量</strong>则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合<strong>在后台运算而不需要太多交互的任务</strong>。</p>

<p>Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数<strong>-XX:+UseAdaptiveSizePolicy</strong>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为<strong>GC自适应的调节策略（GC Ergonomics）</strong>。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>

<p>另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</p>

<h1 id="老年代收集器">老年代收集器</h1>

<h4 id="serial-old收集器">Serial Old收集器</h4>

<p>Serial Old 是 Serial收集器的老年代版本，它同样是一个<strong>单线程收集器</strong>，使用<strong>“标记-整理”（Mark-Compact）</strong>算法。</p>

<p>此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</p>

<ul><br>  <li>在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li><br>  <li>作为CMS收集器的后备预案，在并发收集发生<strong>Concurrent Mode Failure</strong>时使用。</li><br></ul>

<p>它的工作流程与Serial收集器相同，这里再次给出Serial/Serial Old配合使用的工作流程图：</p>

<center><img src="https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png" /></center>

<h4 id="parallel-old收集器">Parallel Old收集器</h4>

<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和<strong>“标记-整理”</strong>算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，<strong>“吞吐量优先”收集器</strong>终于有了比较名副其实的应用组合，在<strong>注重吞吐量</strong>以及<strong>CPU资源敏感</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：</p>

<center><img src="https://pic.yupoo.com/crowhawk/9a6b1249/b1800d45.png" /></center>

<h4 id="cms收集器">CMS收集器</h4>

<p><strong>CMS（Concurrent Mark Sweep）</strong>收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于<strong>“标记-清除”</strong>算法实现的。</p>

<p>CMS收集器工作的整个流程分为以下4个步骤：</p><br><ul><br>  <li><strong>初始标记（CMS initial mark）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li><br>  <li><strong>并发标记（CMS concurrent mark）</strong>：进行<strong>GC Roots Tracing</strong>的过程，在整个过程中耗时最长。</li><br>  <li><strong>重新标记（CMS remark）</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li><br>  <li><strong>并发清除（CMS concurrent sweep）</strong></li><br></ul><br><br><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：</p>

<center><img src="https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png" /></center>

<p><big><strong>优点</strong></big></p>

<p>CMS是一款优秀的收集器，它的主要<strong>优点</strong>在名字上已经体现出来了：<strong>并发收集</strong>、<strong>低停顿</strong>，因此CMS收集器也被称为<strong>并发低停顿收集器（Concurrent Low Pause Collector）</strong>。</p>

<p><big><strong>缺点</strong></big></p>

<ul><br>  <li><strong>对CPU资源非常敏感</strong><br>其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。<strong>CMS默认启动的回收线程数是（CPU数量+3）/4</strong>，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是<strong>当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大</strong>，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li><br>  <li><strong>无法处理浮动垃圾（Floating Garbage）</strong><br>可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。<strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。</strong>这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为<strong>“浮动垃圾”</strong>。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li><br>  <li><strong>标记-清除算法导致的空间碎片</strong><br>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li><br></ul>

<h1 id="g1收集器">G1收集器</h1>

<p><strong>G1（Garbage-First）</strong>收集器是当今收集器技术发展最前沿的成果之一，它是一款<strong>面向服务端应用</strong>的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><br><ul><br>  <li><strong>并行与并发</strong><br>G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><br>  <li><strong>分代收集</strong><br>与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li><br>  <li><strong>空间整合</strong><br>G1从整体来看是基于<strong>“标记-整理”</strong>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>“复制”</strong>算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><br>  <li><strong>可预测的停顿</strong><br>这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li><br></ul><br><br><p><big><strong>横跨整个堆内存</strong></big></p>

<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它<strong>将整个Java堆划分为多个大小相等的独立区域（Region）</strong>，虽然还保留新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合</strong>。</p>

<p><big><strong>建立可预测的时间模型</strong></big></p>

<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的Region（这也就是Garbage-First名称的来由）</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>

<p><big><strong>避免全堆扫描——Remembered Set</strong></big></p>

<p>G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。</p>

<p>为了避免全堆扫描的发生，虚拟机<strong>为G1中每个Region维护了一个与之对应的Remembered Set</strong>。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable<strong>把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</strong>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>

<hr />

<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><br><ul><br>  <li><strong>初始标记（Initial Marking）</strong><br>仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改<strong>TAMS（Nest Top Mark Start）</strong>的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要<strong>停顿线程</strong>，但耗时很短。</li><br>  <li><strong>并发标记（Concurrent Marking）</strong><br>从GC Root 开始对堆中对象进行<strong>可达性分析</strong>，找到存活对象，此阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</li><br>  <li><strong>最终标记（Final Marking）</strong><br>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在<strong>线程的Remembered Set Logs</strong>里面，最终标记阶段需要<strong>把Remembered Set Logs的数据合并到Remembered Set中</strong>，这阶段需要<strong>停顿线程</strong>，但是<strong>可并行执行</strong>。</li><br>  <li><strong>筛选回收（Live Data Counting and Evacuation）</strong><br>首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li><br></ul><br><br><p>通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：</p>

<center><img src="https://pic.yupoo.com/crowhawk/53b7a589/0bce1667.png" /></center>

<h1 id="总结">总结</h1>

<table><br>  <thead><br>    <tr><br>      <th style="text-align: center">收集器</th><br>      <th style="text-align: center">串行、并行or并发</th><br>      <th style="text-align: center">新生代/老年代</th><br>      <th style="text-align: center">算法</th><br>      <th style="text-align: center">目标</th><br>      <th style="text-align: center">适用场景</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <td style="text-align: center"><strong>Serial</strong></td><br>      <td style="text-align: center">串行</td><br>      <td style="text-align: center">新生代</td><br>      <td style="text-align: center">复制算法</td><br>      <td style="text-align: center">响应速度优先</td><br>      <td style="text-align: center">单CPU环境下的Client模式</td><br>    </tr><br>    <tr><br>      <td style="text-align: center"><strong>Serial Old</strong></td><br>      <td style="text-align: center">串行</td><br>      <td style="text-align: center">老年代</td><br>      <td style="text-align: center">标记-整理</td><br>      <td style="text-align: center">响应速度优先</td><br>      <td style="text-align: center">单CPU环境下的Client模式、CMS的后备预案</td><br>    </tr><br>    <tr><br>      <td style="text-align: center"><strong>ParNew</strong></td><br>      <td style="text-align: center">并行</td><br>      <td style="text-align: center">新生代</td><br>      <td style="text-align: center">复制算法</td><br>      <td style="text-align: center">响应速度优先</td><br>      <td style="text-align: center">多CPU环境时在Server模式下与CMS配合</td><br>    </tr><br>    <tr><br>      <td style="text-align: center"><strong>Parallel Scavenge</strong></td><br>      <td style="text-align: center">并行</td><br>      <td style="text-align: center">新生代</td><br>      <td style="text-align: center">复制算法</td><br>      <td style="text-align: center">吞吐量优先</td><br>      <td style="text-align: center">在后台运算而不需要太多交互的任务</td><br>    </tr><br>    <tr><br>      <td style="text-align: center"><strong>Parallel Old</strong></td><br>      <td style="text-align: center">并行</td><br>      <td style="text-align: center">老年代</td><br>      <td style="text-align: center">标记-整理</td><br>      <td style="text-align: center">吞吐量优先</td><br>      <td style="text-align: center">在后台运算而不需要太多交互的任务</td><br>    </tr><br>    <tr><br>      <td style="text-align: center"><strong>CMS</strong></td><br>      <td style="text-align: center">并发</td><br>      <td style="text-align: center">老年代</td><br>      <td style="text-align: center">标记-清除</td><br>      <td style="text-align: center">响应速度优先</td><br>      <td style="text-align: center">集中在互联网站或B/S系统服务端上的Java应用</td><br>    </tr><br>    <tr><br>      <td style="text-align: center"><strong>G1</strong></td><br>      <td style="text-align: center">并发</td><br>      <td style="text-align: center">both</td><br>      <td style="text-align: center">标记-整理+复制算法</td><br>      <td style="text-align: center">响应速度优先</td><br>      <td style="text-align: center">面向服务端应用，将来替换CMS</td><br>    </tr><br>  </tbody><br></table>

<p>本文通过详细介绍HotSpot虚拟机的7种垃圾收集器回答了上一篇文章开头提出的三个问题中的第三个——“如何回收”，在下一篇文章中，我们将回答最后一个未被解答的问题——“什么时候回收”。</p>

<h1 id="参考资料">参考资料</h1>

<ul><br>  <li><a href="https://book.douban.com/subject/24722612/">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li><br></ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM(2)——GC算法与内存分配策略</title>
    <url>/2019/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-%E2%80%94%E2%80%94GC%E7%AE%97%E6%B3%95%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>本文转自 <a href="https://crowhawk.github.io/2017/08/10/jvm_2/">https://crowhawk.github.io/2017/08/10/jvm_2/</a></p>
</blockquote>
<p>说起<strong>垃圾收集（Garbage Collection, GC）</strong>，想必大家都不陌生，它是JVM实现里非常重要的一环，JVM成熟的内存动态分配与回收技术使Java（当然还有其他运行在JVM上的语言，如Scala等）程序员在提升开发效率上获得了惊人的便利。理解GC，对于理解JVM和Java语言有着非常重要的作用。并且当我们需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，只有深入理解GC和内存分配，才能对这些“自动化”的技术实施必要的监控和调节。</p></p>
<p>在Java的运行时数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而<strong>Java堆</strong>和<strong>方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这一块，尤其需要注意。</p><br><p>GC主要回答了以下三个问题：</p><br><ul><br>  <li>哪些内存需要回收？</li><br>  <li>什么时候回收？</li><br>  <li>如何回收？</li><br></ul><br><p>这三个问题的具体解决方案，也就是本文接下来要讲解的内容。</p>

<h1 id="对象存活判定算法">对象存活判定算法</h1>

<p>在堆里存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，首要的就是确定这些对象中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>

<h4 id="引用计数算法">引用计数算法</h4>

<p>引用计数算法是在JVM中被摒弃的一种对象存活判定算法，不过它也有一些知名的应用场景（如Python、FlashPlayer），因此在这里也简单介绍一下。</p>

<p>用引用计数器判断对象是否存活的过程是这样的：<strong>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</strong></p>

<p>引用计数算法的实现简单，判定效率也很高，大部分情况下是一个不错的算法。它没有被JVM采用的原因是<strong>它很难解决对象之间循环引用的问题</strong>。例如以下例子：<br><br><code>/** * testGC()方法执行后，objA和objB会不会被GC呢？*/
public class ReferenceCountingGC &#123;

    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    /** * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过 */
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() &#123;
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    &#125;
&#125;</code><br><p>在上面这段代码中，对象objA 和对象objB都有字段instance，赋值令<code class="highlighter-rouge">objA.instance = objB;</code>、<code class="highlighter-rouge">objB.instance = objA;</code>，除此之外，这两个对象再无引用。如果JVM采用引用计数算法来管理内存，<strong>这两个对象不可能再被访问，但是他们互相引用着对方，导致它们引用计数不为0，所以引用计数器无法通知GC收集器回收它们</strong>。</p>

<p>而事实上执行这段代码，objA和objB是可以被回收的，下面一节将介绍JVM实际使用的存活判定算法。</p>

<h4 id="可达性分析算法">可达性分析算法</h4>

<p>在主流商用程序语言的实现中，都是通过<strong>可达性分析（tracing GC）</strong>来判定对象是否存活的。此算法的基本思路是：通过一系列的称为<strong>“GC Roots”</strong>的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong>，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots 到这个对象不可达）时，则证明此对象时不可用的。用下图来加以说明：</p>

<center><img src="https://pic.yupoo.com/crowhawk/5d0246eb/0635cbe8.png)" /></center>

<p>上图中，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>

<p>可以看到，GC Roots在对象图之外，是特别定义的<strong>“起点”</strong>，不可能被对象图内的对象所引用。</p>

<p>准确地说，<strong>GC Roots其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针</strong>，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，这也是tracing GC算法不会出现循环引用问题的基本保证。因此也容易得出，<strong>只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots</strong>。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p>

<p>在Java中，可作为GC Roots的对象包括以下几种：</p><br><ul><br>  <li><strong>虚拟机栈（栈帧中的局部变量表，Local Variable Table）</strong>中引用的对象。</li><br>  <li><strong>方法区中<em>类静态属性</em></strong>引用的对象。</li><br>  <li><strong>方法区中<em>常量</em></strong>引用的对象。</li><br>  <li><strong>本地方法栈中JNI（即一般说的Native方法）</strong>引用的对象。</li><br></ul><br><br><p>看到这里你可能要问，选择这些对象的依据是什么呢？</p>

<p>可以概括得出，可作为GC Roots的节点主要在<strong>全局性的引用</strong>与<strong>执行上下文</strong>中。要明确的是，tracing gc必须<strong>以当前存活的对象集为Roots</strong>，因此必须选取确定存活的引用类型对象。GC管理的区域是Java堆，<strong>虚拟机栈</strong>、<strong>方法区</strong>和<strong>本地方法栈</strong>不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是<strong>不会被GC所回收</strong>的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p>

<h4 id="两次标记与-finalize方法">两次标记与 finalize()方法</h4>

<p>即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于<strong>“缓刑”</strong>阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程：</p>

<p>如果对象在进行可达性分析后发现没有与 GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是<strong>此对象是否有必要执行<code class="highlighter-rouge">finaliza()</code>方法</strong>。当对象没有覆盖<code class="highlighter-rouge">finaliza()</code>方法，或者<code class="highlighter-rouge">finaliza()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>

<p>如果这个对象被判定为有必要执行<code class="highlighter-rouge">finaliza()</code>方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发此方法，但并不承诺会等待它运行结束，原因是：如果一个对象在<code class="highlighter-rouge">finaliza()</code>方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p>

<p><code class="highlighter-rouge">finaliza()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行<strong>第二次小规模的标记</strong>。如果对象想在<code class="highlighter-rouge">finaliza()</code>方法中成功拯救自己，<strong>只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合</strong>；如果对象这时候还没有逃脱，基本上它就真的被回收了。</p>

<p>值得注意的是，如果代码中有两段一模一样的代码段，执行结果却是一次逃脱成功，一次失败。这是因为任何一个对象的<code class="highlighter-rouge">finalize()</code>方法都只会被系统调用一次，如果对象面临下一次回收，它的<code class="highlighter-rouge">finalize()</code>方法不会再被执行，因此第二次逃脱行动失败。</p>

<p>需要说明的是，使用<code class="highlighter-rouge">finalize()</code>方法来“拯救”对象是不值得提倡的，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。<strong>它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</strong><code class="highlighter-rouge">finalize() </code>能做的工作，使用<code class="highlighter-rouge">try-finally</code>或者其它方法都更适合、及时，所以笔者建议大家可以忘掉此方法存在。</p>

<h4 id="回收方法区">回收方法区</h4>

<p>很多人认为方法区没有垃圾回收，Java虚拟机规范中确实说过不要求，而且在方法区中进行垃圾收集的“性价比”较低：在堆中，尤其是新生代，常规应用进行一次垃圾收集可以回收70%~95%的空间，而方法区的效率远低于此。在JDK 1.8中，JVM摒弃了永久代，用元空间来作为方法区的实现，下面介绍的将是元空间的垃圾回收。</p>

<p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期</strong>和<strong>其对应的类加载器</strong>是相同的。话句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p>

<p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个<em>类加载器的存储区域</em>都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。</strong>当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>

<h1 id="垃圾收集算法">垃圾收集算法</h1>

<p>本节将介绍几种垃圾收集算法的思想及其发展过程，具体的实现将在稍后介绍。</p>

<h4 id="标记清除mark-sweep算法">标记－清除（Mark-Sweep）算法</h4>

<p><strong>标记－清除（Mark-Sweep）</strong>算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。顾名思义，算法分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程在前一节讲述对象标记判定时已经讲过了。</p>

<p>标记－清除算法的不足主要有以下两点：</p><br><ul><br>  <li><strong>空间问题</strong>，标记清除之后会产生大量不连续的<strong>内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li><br>  <li><strong>效率问题</strong>，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</li><br></ul><br><br><p>标记－清除算法的执行过程如下图所示：</p>

<center><img src="https://pic.yupoo.com/crowhawk/5a3494ae/efc6204a.png" /></center>

<h4 id="复制copying算法">复制（Copying）算法</h4>

<p>为了解决标记-清除算法的效率问题，一种称为<strong>“复制”（Copying）</strong>的收集算法出现了，思想为：它<strong>将可用内存按容量分成大小相等的两块</strong>，每次只使用其中的一块。<strong>当这一块内存用完，就将还存活着的对象复制到另一块上面</strong>，然后再把已使用过的内存空间一次清理掉。</p>

<p>这样做使得<strong>每次都是对整个半区进行内存回收</strong>，内存分配时也就<strong>不用考虑内存碎片</strong>等复杂情况，只要<strong>移动堆顶指针，按顺序分配内存</strong>即可，实现简单，运行高效。只是这种算法的代价是<strong>将内存缩小为原来的一半</strong>，代价可能过高了。复制算法的执行过程如下图所示：</p>

<center><img src="https://pic.yupoo.com/crowhawk/62b8a3a8/f1cada8a.png" /></center>

<p><big><strong>Minor GC与复制算法</strong></big></p>

<p><strong>现在的商业虚拟机都使用复制算法来回收新生代。</strong>新生代的GC又叫<strong>“Minor GC”</strong>，IBM公司的专门研究表明：新生代中的对象98%是<strong>“朝生夕死”</strong>的，所以Minor GC非常频繁，一般回收速度也比较快，同时<strong>“朝生夕死”</strong>的特性也使得Minor GC使用复制算法时不需要按照1:1的比例来划分新生代内存空间。</p>

<p><big><strong>Minor GC过程</strong></big></p>

<p>事实上，新生代将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间（From Survivor和To Survivor）</strong>，<strong>每次Minor GC都使用Eden和From Survivor</strong>，当回收时，<strong>将Eden和From Survivor中还存活着的对象都一次性地复制到另外一块To Survivor空间上</strong>，最后清理掉Eden和刚使用的Survivor空间。<strong>一次Minor GC结束的时候</strong>，<strong>Eden</strong>空间和<strong>From Survivor</strong>空间都是空的，而<strong>To Survivor</strong>空间里面存储着存活的对象。<strong>在下次MinorGC的时候</strong>，两个Survivor空间交换他们的标签，现在是空的<strong>“From” Survivor</strong>标记成为<strong>“To”</strong>，<strong>“To” Survivor</strong>标记为<strong>“From”</strong>。因此，在MinorGC结束的时候，Eden空间是空的，两个Survivor空间中的一个是空的，而另一个存储着存活的对象。</p>

<p>HotSpot虚拟机默认的<strong>Eden : Survivor</strong>的比例是<strong>8 : 1</strong>，由于一共有两块Survivor，所以<strong>每次新生代中可用内存空间为整个新生代容量的90%（80%＋10%）</strong>，只有10%的容量会被“浪费”。</p>

<p><big><strong>分配担保</strong></big></p>

<p>上文说的98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当Survivor空间不够用时</strong>，需要依赖<strong>老年代内存</strong>进行<strong>分配担保（Handle Promotion）</strong>。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>

<h5 id="标记整理mark-compact算法">标记－整理（Mark-Compact）算法</h5>

<p>复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是：如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在<strong>老年代一般不能直接选用复制算法</strong>。</p>

<p>根据老年代的特点，<strong>标记－整理（Mark-Compact）</strong>算法被提出来，主要思想为：此算法的标记过程与<strong>标记－清除</strong>算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</strong>具体示意图如下所示：</p>

<center><img src="https://pic.yupoo.com/crowhawk/d046244a/d3d3277f.png" /></center>

<h5 id="分代收集generational-collection算法">分代收集（Generational Collection）算法</h5>

<p>当前商业虚拟机的垃圾收集都采用<strong>分代收集（Generational Collection）算法</strong>，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：</p><br><ul><br>  <li><br>    <p><strong>新生代</strong><br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p><br>  </li><br>  <li><br>    <p><strong>老年代</strong><br>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>“标记-清除”</strong>或<strong>“标记-整理”</strong>算法来进行回收。</p><br>  </li><br></ul><br><br><h1 id="hotspot的算法实现">HotSpot的算法实现</h1><br><br><p>前面两大节主要从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p>

<h4 id="枚举根节点">枚举根节点</h4>

<p>从可达性分析中<strong>从GC Roots节点找引用链</strong>这个操作为例，可作为GC Roots的节点主要在<strong>全局性的引用</strong>（例如常量或类静态属性）与<strong>执行上下文</strong>（例如栈帧中的局部变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>

<p><big><strong>GC停顿（”Stop The World”）</strong></big></p>

<p>另外，可达性分析工作必须在一个<strong>能确保一致性的快照</strong>中进行——这里<strong>“一致性”</strong>的意思是指<strong>在整个分析期间整个执行系统看起来就像被冻结在某个时间点上</strong>，不可以出现分析过程中对象引用关系还在不断变化的情况，这是保证分析结果准确性的基础。这点是导致GC进行时必须<strong>停顿所有Java执行线程</strong>（Sun将这件事情称为<strong>“Stop The World”</strong>）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>

<p><big><strong>准确式GC与OopMap</strong></big></p>

<p>由于目前的主流Java虚拟机使用的都是<strong>准确式GC（即使用准确式内存管理，虚拟机可用知道内存中某个位置的数据具体是什么类型）</strong>，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把<strong>对象内什么偏移量上是什么类型的数据</strong>计算出来，在JIT编译过程中，也会在特定的位置记录下<strong>栈和寄存器中哪些位置是引用</strong>。这样，GC在扫描时就可以直接得知这些信息了。</p>

<h4 id="安全点safepoint进行gc时程序停顿的位置">安全点（Safepoint）——进行GC时程序停顿的位置</h4>

<p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，<strong>如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</strong></p>

<p>为此，HotSpot选择不为每条指令都生成OopMap，而是只在“特定的位置”记录这些信息，这些位置便被称为<strong>安全点（Safepoint）</strong>。也就是说，<strong>程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序<strong>“是否具有让程序长时间执行的特征”</strong>为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是<strong>指令序列复用</strong>，例如<strong>方法调用</strong>、<strong>循环跳转</strong>、<strong>异常跳转</strong>等，所以具有这些功能的指令才会产生Safepoint。</p>

<p>对于Sefepoint，另一个需要考虑的问题是如何<strong>在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来</strong>。这里有两种方案可供选择：</p><br><ul><br>  <li><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，<strong>在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。</strong>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li><br>  <li><strong>主动式中断（Voluntary Suspension）</strong>：<br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地<strong>设置一个标志</strong>，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外<strong>再加上创建对象需要分配内存的地方</strong>。</li><br></ul><br><br><h4 id="安全区域safe-region">安全区域（Safe Region）</h4><br><br><p><strong>Safepoint</strong>机制保证了<strong>程序执行时</strong>，在不太长的时间内就会遇到可进入GC的Safepoint。但是，<strong>程序“不执行”的时候（如线程处于Sleep状态或Blocked状态）</strong>，这时线程无法响应JVM的中断请求，“走到”安全的地方去中断挂起，这时候就需要<strong>安全区域（Safe Region）</strong>来解决。</p>

<p>安全区域是指<strong>在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</strong>我们也可以把Safe Region看做是被扩展了的Safepoint。</p>

<p>在线程执行到Safe Region中的代码时，首先<strong>标识自己已经进入了Safe Region</strong>，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。<strong>在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程）</strong>，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>

<h1 id="内存分配策略">内存分配策略</h1>

<p>Java的自动内存管理最终可以归结为自动化地解决了两个问题：</p>

<ul><br>  <li><strong>给对象分配内存</strong></li><br>  <li><strong>回收分配给对象的内存</strong></li><br></ul>

<p>对象的内存分配通常是在堆上分配（除此以外还有可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。</p>

<p>下面以使用Serial/Serial Old收集器（将在下一篇文章中讲解）为例，介绍内存分配的策略。</p>

<h4 id="对象优先在eden区分配">对象优先在Eden区分配</h4>

<p>大多数情况下，对象在新生代的Eden区中分配。<strong>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</strong></p>

<h4 id="大对象直接进入老年代">大对象直接进入老年代</h4>

<p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），<strong>经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来安置它们</strong>。</p>

<p>虚拟机提供了一个<strong>-XX:PretenureSizeThreshold</strong>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是<strong>避免在Eden区及两个Survivor区之间发生大量的内存复制</strong>（新生代采用复制算法回收内存）。</p>

<h4 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h4>

<p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。<strong>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</strong>对象晋升老年代的年龄阈值，可以通过参数<strong>-XX:MaxTenuringThreshold</strong>设置。</p>

<h4 id="动态对象年龄判定">动态对象年龄判定</h4>

<p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了<strong>MaxTenuringThreshold</strong>才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到<strong>MaxTenuringThreshold</strong>中要求的年龄。</p>

<h4 id="空间分配担保">空间分配担保</h4>

<p><strong>在发生Minor GC之前</strong>，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<strong>HandlePromotionFailure</strong>设置不允许冒险，那这时也要改为进行一次<strong>Full GC</strong>。</p>

<p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此<strong>当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</strong>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>

<p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致<strong>担保失败（Handle Promotion Failure）</strong>。如果出现了<strong>HandlePromotionFailure</strong>失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将<strong>HandlePromotionFailure</strong>开关打开，避免Full GC过于频繁。</p>

<h1 id="full-gc的触发条件">Full GC的触发条件</h1>

<p>对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍Full GC的触发条件。</p>

<h4 id="调用systemgc">调用System.gc()</h4>

<p>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过<strong>-XX:+ DisableExplicitGC</strong>来禁止RMI调用System.gc()。</p>

<h4 id="老年代空间不足">老年代空间不足</h4>

<p>老年代空间不足的常见场景为前文所讲的<strong>大对象直接进入老年代</strong>、<strong>长期存活的对象进入老年代</strong>等，当执行Full GC后空间仍然不足，则抛出如下错误：<br><code class="highlighter-rouge">Java.lang.OutOfMemoryError: Java heap space </code><br>为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>

<h4 id="空间分配担保失败">空间分配担保失败</h4>

<p>前文介绍过，使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了<strong>HandlePromotionFailure</strong>担保失败，则会触发Full GC。</p>

<h4 id="jdk-17及以前的永久代空间不足">JDK 1.7及以前的永久代空间不足</h4>

<p>在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<br><code class="highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code><br>为避免PermGen占满造成Full GC现象，可采用的方法为增大PermGen空间或转为使用CMS GC。</p>

<p>在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。</p>

<h4 id="concurrent-mode-failure">Concurrent Mode Failure</h4>

<p>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报<code class="highlighter-rouge">Concurrent Mode Failure</code>错误，并触发Full GC。</p>

<h1 id="小结">小结</h1>

<p>本文简要地介绍了HotSpot虚拟机如何去发起内存回收的问题，也解答了文章开头提出的三个问题中的前两个——“哪些内存需要回收”和“何时回收”，同时对于第三个问题——“如何回收”，在原理层面作出了解答。在下一篇文章中，笔者将通过介绍几种具体的垃圾收集器，来更深入地回答第三个问题。</p>

<h1 id="参考资料">参考资料</h1>

<p><ul><br>  <li><a href="https://book.douban.com/subject/24722612/">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM(1)——Java内存区域与Java对象</title>
    <url>/2019/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-1-%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8EJava%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>本文转自 <a href="https://crowhawk.github.io/2017/08/09/jvm_1/">https://crowhawk.github.io/2017/08/09/jvm_1/</a></p>
</blockquote>
<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM载执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。具体如下图所示：</p>
<p><img src="https://pic.yupoo.com/crowhawk/3d24df02/776c8d55.png" alt=""></p>
<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机概念模型中，<strong>字节码解释器</strong>工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>程序计数器是一块<strong>“线程私有”</strong>的内存，如上文的图所示，每条线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。这样设计使得在多线程环境下，线程切换后能恢复到正确的执行位置。</p>
<p>如果线程正在执行的是一个<strong>Java方法</strong>，这个计数器记录的是正在执行的<strong>虚拟机字节码指令的地址</strong>；若执行的是<strong>Native方法</strong>，则<strong>计数器为空（Undefined）</strong>（因为对于Native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“字节码指令的地址”的概念）。程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<strong>OutOfMemoryError</strong>情况的内存区域。</p>
<h4 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h4><p><strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>，栈帧中存储着<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。<strong>每一个方法从调用直至执行完成的过程，会对应一个栈帧在虚拟机栈中入栈到出栈的过程。</strong>与程序计数器一样，Java虚拟机栈也是<strong>线程私有</strong>的。</p>
<p>函数的调用有完美的嵌套关系——调用者的生命期总是长于被调用者的生命期，并且后者在前者的之内。这样，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以正好可以满足栈的LIFO顺序，选用栈这种数据结构来实现调用栈是一种很自然的选择。</p>
<p><strong>局部变量表</strong>中存放了编译期可知的各种：</p>
<ul>
<li><strong>基本数据类型</strong>(boolen、byte、char、short、int、 float、 long、double）</li>
<li><strong>对象引用</strong>（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</li>
<li><strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</li>
</ul>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>Java虚拟机规范中对这个区域规定了两种异常状况：</p>
<ul>
<li><strong>StackOverflowError</strong>：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。</li>
<li><strong>OutOfMemoryError</strong>：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。</li>
</ul>
<h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p><strong>本地方法栈（Native Method Stack）</strong>与Java虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<p>在虚拟机规范中对本地方法栈中使用的语言、方式和数据结构并无强制规定，因此具体的虚拟机可实现它。甚至<strong>有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机一样，本地方法栈会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p>
<h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><p>对于大多数应用而言，<strong>Java堆（Heap）</strong>是Java虚拟机所管理的内存中最大的一块，它<strong>被所有线程共享的</strong>，在虚拟机启动时创建。此内存区域<strong>唯一的目的</strong>是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存，且每次分配的空间是<strong>不定长</strong>的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存<strong>对象实例的属性值</strong>，<strong>属性的类型</strong>和<strong>对象本身的类型标记</strong>等，<strong>并不保存对象的方法（方法是指令，保存在Stack中）</strong>,在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。对象实例在Heap 中分配好以后，需要<strong>在Stack中保存一个4字节的Heap 内存地址</strong>，用来定位该对象实例在Heap 中的位置，便于找到该对象实例。</p>
<p>Java虚拟机规范中描述道：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都在堆上分配的定论也并不<strong>“绝对”</strong>了。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被称为<strong>“GC堆（Garbage Collected Heap）”</strong>。从内存回收的角度看内存空间可如下划分： <img src="https://pic.yupoo.com/crowhawk/5cf46998/fe5079d3.png" alt=""></p>
<ul>
<li><strong>新生代（Young）</strong>： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。新生代又可细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>，默认比例为8:1:1。它们的具体作用将在下一篇文章讲解GC时介绍。</li>
<li><strong>老年代（Tenured/Old）</strong>：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li>
<li><strong>永久代（Perm）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</li>
</ul>
<p>其中<strong>新生代和老年代组成了Java堆的全部内存区域</strong>，而<strong>永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong>，关于方法区的具体内容将在稍后介绍。</p>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域。<strong>Object Class Data(类定义数据)</strong>是存储在方法区的，此外，<strong>常量</strong>、<strong>静态变量</strong>、<strong>JIT编译后的代码</strong>也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 <strong>Non-Heap</strong>。</p>
<p><strong>JDK 1.8以前的永久代（PermGen）</strong></p>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，也就是说，Java虚拟机规范只是规定了方法区的概念和它的作用，并没有规定如何去实现它。<strong>对于JDK 1.8之前的版本，HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，即用永久代来实现方法区</strong>，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如<strong>Oracle JRockit</strong>、<strong>IBM J9</strong>等）来说是不存在永久代的概念的。</p>
<p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p>
<ul>
<li>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</li>
<li>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</li>
<li>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）。 ……</li>
</ul>
<p>这些都会导致方法区溢出，报出<code>java.lang.OutOfMemoryError: PermGen space</code>。</p>
<p><strong>JDK 1.8的元空间（Metaspace）</strong></p>
<p>在JDK 1.8中，HotSpot虚拟机设计团队为了促进<strong>HotSpot</strong>与 <strong>JRockit</strong>的融合，修改了方法区的实现，移除了永久代，选择使用<strong>本地化的内存空间</strong>（而不是JVM的内存空间）存放类的元数据，这个空间叫做<strong>元空间（Metaspace）</strong>。</p>
<p>做了这个改动以后，<code>java.lang.OutOfMemoryError: PermGen</code>的空间问题将不复存在，并且不再需要调整和监控这个内存空间。且虚拟机需要为方法区设计额外的GC策略：如果类元数据的空间占用达到参数<strong>“MaxMetaspaceSize”</strong>设置的值，将会触发对死亡对象和类加载器的垃圾回收。 为了限制垃圾回收的频率和延迟，适当的监控和调优<strong>元空间</strong>是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。</p>
<p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期</strong>和<strong>其对应的类加载器</strong>是相同的。话句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p>
<p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个<em>类加载器的存储区域</em>都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。</strong>当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>
<p><strong>元空间虚拟机</strong>负责元空间的分配，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块<strong>是线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p>
<p><img src="https://pic.yupoo.com/crowhawk/cdaea117/7bdf00c4.png" alt=""></p>
<p>上图展示的是虚拟内存映射区域如何进行元组块的分配。类加载器1和3表明使用了反射或者为匿名类加载器，他们使用了特定大小组块。 而类加载器2和4根据其内部条目的数量使用小型或者中型的组块。</p>
<p><strong>运行时常量池（Runtime Constant Pool）</strong></p>
<p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。<strong>Class文件</strong>中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后进入方法区的运行时常量池存放</strong>。</p>
<p>Java虚拟机对Class文件每一部分（自然包括常量池）的格式有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。但<strong>对于运行时常量池，Java虚拟机规范没有做任何有关细节的要求</strong>，不同的提供商实现的虚拟机可以按照自己的需求来实现此内存区域。不过一般而言，除了保存<strong>Class文件中的描述符号引用</strong>外，还会把<strong>翻译出的直接引用</strong>也存储在运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译器才能产生，也就是<strong>并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>，此特性被开发人员利用得比较多的便是String类的<code>intern()</code> 方法。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机<strong>运行时数据区</strong>的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致<strong>OutOfMemoryError</strong>异常出现，所以这里放到一起讲解。</p>
<p>以<strong>NIO（New Input/Output）</strong>类为例，NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。</p>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存（包括RAM以及SWAP区或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现<strong>OutOfMemoryError</strong>异常。</p>
<h1 id="HotSpot中的对象"><a href="#HotSpot中的对象" class="headerlink" title="HotSpot中的对象"></a>HotSpot中的对象</h1><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>Java的对象创建大致有如下四种方式：</p>
<ul>
<li><strong>new关键字</strong> 这应该是我们最常见和最常用最简单的创建对象的方式。</li>
<li><strong>使用<code>newInstance()</code>方法</strong> 这里包括<strong>Class</strong>类的<code>newInstance()</code>方法和<strong>Constructor</strong>类的<code>newInstance()</code>方法（前者其实也是调用的后者）。</li>
<li><strong>使用<code>clone()</code>方法</strong> 要使用<code>clone()</code>方法我们必须实现实现<strong>Cloneable</strong>接口，用<code>clone()</code>方法创建对象并不会调用任何构造函数。即我们所说的<strong>浅拷贝</strong>。</li>
<li><strong>反序列化</strong> 要实现反序列化我们需要让我们的类实现<strong>Serializable</strong>接口。当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。即我们所说的<strong>深拷贝</strong>。</li>
</ul>
<p>上面的四种创建对象的方法除了第一种使用new指令之外，其他三种都是使用<strong>invokespecial(构造函数的直接调用)</strong>。这里我们只说new创建对象的方式，关于invokespecial的内容将在后续文章中介绍。下面我们来看看当虚拟机遇到new指令的时候对象是如何创建的。</p>
<p><strong>1. 类加载检查</strong></p>
<p>虚拟机遇到一条new指令时，首先将去检查<strong>这个指令的参数是否能在常量池中定位到一个类的符号引用</strong>，并且检查<strong>这个符号引用代表的类是否已被加载、解析和初始化过的</strong>，如果没有，则必须先执行相应的类加载过程，关于类加载机制和类加载器的详细内容将在后续文章中介绍。</p>
<p><strong>2. 分配内存</strong></p>
<p>在类加载检查通过后，虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定在下一节对象内存布局时再详细讲解），为对象分配空间的任务具体便等同于<strong>从Java堆中划出一块大小确定的内存空间</strong>，可以分如下两种情况讨论：</p>
<ul>
<li><strong>Java堆中内存绝对规整</strong> 所有用过的内存都被放在一边，空闲的内存被放在另一边，<strong>中间放着一个指针作为分界点的指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为<strong>“指针碰撞”（Bump The Pointer）</strong>。</li>
<li><strong>Java堆中的内存不规整</strong> 已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须<strong>维护一个列表，记录哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>“空闲列表”（Free List）</strong>。</li>
</ul>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。因此在使用Serial、ParNew等带<strong>Compact</strong>过程的收集器时，系统采用的分配算法是<strong>指针碰撞</strong>，而使用CMS这种基于<strong>Mark-Sweep</strong>算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction来整理内存），就通常采用<strong>空闲列表</strong>。关于垃圾收集器的具体内容将在下一篇文章中介绍。</p>
<p>除如何划分可用空间之外，另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也<strong>并非线程安全</strong>的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有如下两个方案：</p>
<ul>
<li><strong>对分配内存空间的动作进行同步</strong> 实际上虚拟机是采用<strong>CAS</strong>配上<strong>失败重试</strong>的方式保证更新操作的原子性。</li>
<li><strong>把内存分配的动作按照线程划分在不同的空间之中进行</strong> 即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲（TLAB ，Thread Local Allocation Buffer）</strong>，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过<strong>-XX:+/-UseTLAB</strong>参数来设定。</li>
</ul>
<p><strong>3. 初始化</strong></p>
<p>内存分配完成之后，虚拟机需要<strong>将分配到的内存空间都初始化为零值（不包括对象头）</strong>，如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p>
<p><strong>4. 设置对象头</strong></p>
<p>接下来，虚拟机要<strong>设置对象的信息</strong>（如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息）并存放在对象的<strong>对象头（Object Header）</strong>中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，在下一节再详细介绍。</p>
<p><strong>5. 执行<code>&lt;init&gt;</code>方法</strong></p>
<p>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零值。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。</p>
<p><strong>1. 对象头</strong></p>
<p>HotSpot虚拟机的对象头包括两部分信息：</p>
<ul>
<li><strong>对象自身的运行时数据 “Mark Word”</strong> 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为<strong>“Mark Word”</strong>。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个<strong>非固定的数据结构</strong>以便在极小的空间内存储尽量多的信息，它会<strong>根据对象的状态复用自己的存储空间</strong>。例如在32位的HotSpot虚拟机中对象<strong>未被锁定</strong>的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下图所示：</li>
</ul>
<p><img src="https://pic.yupoo.com/crowhawk/4f006175/8be38542.png" alt=""></p>
<ul>
<li><strong>类型指针</strong> 类型指针即<strong>对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说<strong>查找对象的元数据信息并不一定要经过对象本身</strong>，这点我们在下一节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于<strong>记录数组长度</strong>的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</li>
</ul>
<p><strong>2. 实例数据</strong></p>
<p>实例数据是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p><strong>3. 对齐填充</strong></p>
<p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>我们的Java程序需要通过<strong>栈上的对象引用（reference）数据（存储在栈上的局部变量表中）</strong>来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面也只规定了是一个指向对象的引用，并没有定义这个引用的具体实现，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p>
<p><strong>1. 使用句柄访问</strong></p>
<p>如果使用句柄访问的话，<strong>Java堆中</strong>将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据</strong>的各自的<strong>具体地址信息</strong>。如下图所示：</p>
<p><img src="https://pic.yupoo.com/crowhawk/af3c02ef/bfd967c5.png" alt=""></p>
<p><strong>2. 使用直接指针访问</strong></p>
<p>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如下图所示：</p>
<p><img src="https://pic.yupoo.com/crowhawk/5c1acdb8/f5086a4d.png" alt=""></p>
<hr>
<p>这两种对象访问方式各有优势，下面分别来谈一谈：</p>
<ul>
<li><strong>句柄</strong> 使用句柄访问的最大好处就是<strong>reference中存储的是稳定的句柄地址</strong>，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时<strong>只会改变句柄中的实例数据指针，而reference本身不需要被修改</strong>。</li>
<li><strong>直接指针</strong> 使用直接指针来访问最大的好处就是<strong>速度更快</strong>，它<strong>节省了一次指针定位的时间开销</strong>，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项 非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，<strong>HotSpot是使用直接指针进行对象访问的</strong>，不过在整个软件开发的范围来 看，各种语言、框架中使用句柄来访问的情况也十分常见。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://book.douban.com/subject/24722612/">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>技术书籍</title>
    <url>/2019/05/24/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">书籍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">java</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Java核心技术 卷I：基础知识（原书第10版) [美 凯 S.霍斯特曼(Cay S. Horstmann)]</font><br>2. <font size="3" color="#00BFFF">Java核心技术卷II：高级特性（原书第10版）[美 凯 S.霍斯特曼(Cay S. Horstmann)]</font><br>3. <font size="3" color="#00BFFF">Java编程思想（第4版）[Bruce Eckel]</font><br>4. <font size="3" color="#00BFFF">Java 8实战  [英 厄马（Raoul-Gabriel Urma）意 弗斯科（Mario F)]</font><br>5. <font size="3" color="#00BFFF">Effective Java中文版(第2版)  [(美)布洛克 译者:杨春花//俞黎敏]</font><br>6. <font size="3" color="#00BFFF">Head First Java（中文版）[美 塞若（Sierra，K.）贝茨（Bates，B.） ]</font><br></td>
</tr>
<tr>
<td style="text-align:left">java并发</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Java并发编程的艺术 [方腾飞，魏鹏，程晓明]</font><br> 2. <font size="3" color="#00BFFF">Java并发编程实战  [(美)盖茨]</font><br>3. <font size="3" color="#00BFFF">Java高并发编程详解：多线程与架构设计 [汪文君]</font><br>4.  <font size="3" color="#00BFFF">实战Java高并发程序设计 [葛一鸣]</font></td>
</tr>
<tr>
<td style="text-align:left">jvm</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Java性能权威指南 [美 奥克斯（Oaks,S.）]</font><br>2. <font size="3" color="#00BFFF">深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）[周志明]</font><br>3. <font size="3" color="#00BFFF">Java程序性能优化——让你的Java程序更快、更稳定 [葛一鸣等]</font><br></td>
</tr>
<tr>
<td style="text-align:left">java web</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">深入分析Java Web技术内幕  [许令波]</font><br> 2.  <font size="3" color="#00BFFF">亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统  [张开涛] <br> 3.  <font size="3" color="#00BFFF">点石成金 访客至上的Web和移动可用性设计秘笈 原书第3版  [史蒂夫 克鲁格]</td>
</tr>
<tr>
<td style="text-align:left">netty</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Netty实战   [美 诺曼·毛瑞尔 马文·艾伦·沃尔夫泰尔]</font><br></td>
</tr>
<tr>
<td style="text-align:left">mybatis</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">深入浅出MyBatis技术原理与实战   [杨开振]</font><br></td>
</tr>
<tr>
<td style="text-align:left">spring</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Spring实战（第4版） [美 Craig Walls 沃尔斯]</font><br>2. <font size="3" color="#00BFFF">Spring源码深度解析 第2版 [郝佳]</font><br>3. <font size="3" color="#00BFFF">Spring技术内幕（第2版） [计文柯]</font><br></td>
</tr>
<tr>
<td style="text-align:left">springmvc</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Spring MVC学习指南 [美 戴克（Paul Deck）林仪明、崔毅译]</font><br></td>
</tr>
<tr>
<td style="text-align:left">springboot</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Spring Boot实战 [美 克雷格·沃斯（Craig Walls）]</font><br></td>
</tr>
<tr>
<td style="text-align:left">springcloud</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Spring Cloud微服务实战 [翟永超]</font><br>2. <font size="3" color="#00BFFF">Spring Cloud与Docker微服务架构实战（第2版) [周立]</font><br></td>
</tr>
<tr>
<td style="text-align:left">zookeeper</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">ZooKeeper：分布式过程协同技术详解 [美 Flavio Junqueira]</font></td>
</tr>
<tr>
<td style="text-align:left">redis</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Redis实战 [美 约西亚 L.卡尔森（Josiah L. Carlson]</font><br>2. <font size="3" color="#00BFFF">Redis in Action [Carlson, Josiah L.]</font><br>3. <font size="3" color="#00BFFF">Redis设计与实现 [黄健宏]</font><br></td>
</tr>
<tr>
<td style="text-align:left">docker</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">Docker进阶与实战 [华为Docker实践小组]</font> <br> 2. <font size="3" color="#00BFFF">Docker 容器与容器云 第2版 [浙江大学SEL实验室]</font></td>
</tr>
<tr>
<td style="text-align:left">设计模式</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">设计模式 可复用面向对象软件的基础  [伽玛　等著，李英军　等译]</font> <br>2. <font size="3" color="#00BFFF">Head First设计模式(中文版) [弗里曼 (作者), 等 (作者)]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">mysql</td>
<td style="text-align:left">1. <font size="3" color="#00BFFF">高性能MySQL（第3版）[(美)施瓦茨,(美)扎伊采夫,(美)特卡琴科]</font><br>2. <font size="3" color="#00BFFF">MySQL技术内幕：InnoDB存储引擎（第2版） [姜承尧]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">计算机网络</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">HTTP权威指南[美 David Gourley　Brian Totty　Marjorie Sayer　Sailu Reddy　Aushu Aggarwal</font> <br>  2. <font size="3" color="#00BFFF">TCP/IP详解 卷1：协议（原书第2版）[凯文 R.福尔]</font> <br>3. <font size="3" color="#00BFFF">计算机网络：自顶向下方法(原书第7版) [詹姆斯·F.库罗斯]</font> <br>4. <font size="3" color="#00BFFF">图解HTTP [日 上野宣　著,于均良　译]</font> <br>5. <font size="3" color="#00BFFF">计算机网络 [谢希仁]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">操作系统</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">现代操作系统（原书第4版）[Andrew S. Tanenbaum; Herbert Bos]</font> <br>2.  <font size="3" color="#00BFFF">深入理解计算机系统[Bryant OHallaron]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">计算机程序设计</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">代码大全 [史蒂夫·迈克康奈尔]</font> <br>2.  <font size="3" color="#00BFFF">程序员修炼之道 [美 亨特 美 托马斯]</font> <br>3.  <font size="3" color="#00BFFF">C程序设计语言(第2版•新版) [克尼汉 (作者), 等 (作者, 译者), 徐宝文 (译者)]</font> <br>4.  <font size="3" color="#00BFFF">重构:改善既有代码的设计 [福勒 (Martin Fowler) (作者), 熊节 (译者)]</font> <br>5.  <font size="3" color="#00BFFF">计算机程序设计艺术•卷1:基本算法 [高德纳 (Donald E.Knuth)]</font> <br>6.  <font size="3" color="#00BFFF">编译原理(第2版) [Alfred V. Aho (作者), Monica S.Lam (作者), 赵建华 (译者), 郑滔 (译者), 戴新宇 (译者)]</font> <br>7.  <font size="3" color="#00BFFF">Effective C++:改善程序与设计的55个具体做法(第3版)(中文版) [梅耶 (Scott Meyers) (作者), 侯捷 (译者)]</font> <br>8.  <font size="3" color="#00BFFF">More Effective C++:35个改善编程与设计的有效方法(中文版) [梅耶(Scott Meyers) (作者), 侯捷 (译者)]</font> <br>9.  <font size="3" color="#00BFFF">编程珠玑(第2版) [Jon Bentley (作者), 黄倩 (译者), 钱丽艳 (译者)]</font> <br>10.  <font size="3" color="#00BFFF">Unix编程艺术 [Eric S.Raymond 著 姜宏，何源，蔡晓骏 译]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">计算机科学</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">计算机程序的构造和解释：原书第2版）[Harold Abelson GeraldJaySussman等]</font> <br>2.  <font size="3" color="#00BFFF">哥德尔、艾舍尔、巴赫:集异璧之大成[美 侯世达]</font> <br>3.  <font size="3" color="#00BFFF">编码:隐匿在计算机软硬件背后的语言[佩措尔德(Charles Petzold) (作者), 左飞 (译者), 薛佟佟 (译者)]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">算法</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">算法导论(原书第2版) [科曼 (Cormen T.H.) (作者), 等 (作者, 译者), 潘金贵 (译者)]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">软件工程</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">人月神话 [弗雷德里克•布鲁克斯]</font> <br>2.  <font size="3" color="#00BFFF">代码整洁之道 [马丁 (Robert C. Martin) (作者), 韩磊 (译者)]</font> <br>3.  <font size="3" color="#00BFFF">人件集：人性化的软件开发 [康斯坦丁(Larry L. Constantine) (作者), 谢超 (译者), 刘颖 (译者), 谢卓凡 (译者), 等 (译者)]</font> <br>4.  <font size="3" color="#00BFFF">高效程序员的45个习惯:敏捷开发修炼之道 [苏帕拉马尼亚姆(Venkat Subramaniam) (作者), 亨特(Andy Hunt) (作者), 钱安川 (译者), 郑柯 (译者)]</font> <br>5.  <font size="3" color="#00BFFF">测试驱动开发的艺术 [科斯科拉(Lasse Koskela) (作者), 李贝 (译者)]</font> <br>6.  <font size="3" color="#00BFFF">快速软件开发 [史蒂夫 迈克康奈尔]</font> <br>7.  <font size="3" color="#00BFFF">设计心理学 [唐纳德A诺曼]</font> <br>8.  <font size="3" color="#00BFFF">About Face 4: 交互设计精髓 [Alan.cooper（艾伦.库伯） 著，倪卫国 刘松涛 薛菲 杭敏 译]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">编程人生</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">编程人生:15位软件先驱访谈录 [塞贝尔(Peter Seibel) (作者), 图灵俱乐部 (译者)]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">软件架构</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">架构即未来：现代企业可扩展的Web架构、流程和组织(原书第2版)</font> <br>2.  <font size="3" color="#00BFFF">架构整洁之道</font> <br>3.  <font size="3" color="#00BFFF">实现领域驱动设计</font> <br>4.  <font size="3" color="#00BFFF">领域驱动设计 软件核心复杂性应对之道</font> <br>5.  <font size="3" color="#00BFFF">企业应用架构模式 [福勒(Martin Fowler) (作者), UML China (合著者), 王怀民 (译者), 周斌 (译者)]</font> <br></td>
</tr>
<tr>
<td style="text-align:left">分布式系统设计</td>
<td style="text-align:left">1.  <font size="3" color="#00BFFF">数据密集型应用系统设计</font> <br>2.  <font size="3" color="#00BFFF">大规模分布式存储系统:原理解析与架构实战 [杨传辉]</font> <br></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术书籍</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>jvm</tag>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mysql</tag>
        <tag>mybatis</tag>
        <tag>zookeeper</tag>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>tomcat</tag>
        <tag>netty</tag>
        <tag>rocketmq</tag>
        <tag>计算机网络</tag>
        <tag>操作系统</tag>
        <tag>sql</tag>
        <tag>docket</tag>
        <tag>java并发</tag>
        <tag>java web</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper入门</title>
    <url>/2019/04/21/zookeeper%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Apache ZooKeeper是Apache软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。 ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。<br>ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。–<a href="https://zh.wikipedia.org/wiki/Apache_ZooKeeper">维基百科</a></p>
<h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><ul>
<li><p>单机配置  </p>
<pre><code>- 去官网上下载[https://archive.apache.org/dist/zookeeper/](https://archive.apache.org/dist/zookeeper/),然后解压  
- copy conf/zoo_sample.cfg文件重命名为zoo.cfg,并配置修改  
- /bin/zkServer.sh start  启动服务  

zoo.cfg配置文件如下:
</code></pre></li>
</ul>
<pre><code>        # The number of milliseconds of each tick
        tickTime=2000
        # The number of ticks that the initial 
        # synchronization phase can take
        initLimit=10
        # The number of ticks that can pass between 
        # sending a request and getting an acknowledgement
        syncLimit=5
        # the directory where the snapshot is stored.
        dataDir=/Users/wenchao.wang/dev/zookeeper/data
        dataLogDir=/Users/wenchao.wang/dev/zookeeper/logs

        # the port at which the clients will connect
        clientPort=2181
</code></pre><ul>
<li><p>集群配置<br>一般zookeeper集群由三台及以上机器组成,只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务.下面将安装三个节点的zookeeper集群,即一个leader、两个follower. </p>
<ul>
<li>下载安装包、解压(同上)  </li>
<li>把解压包copy三份,分别命名为zookeeper-node-1、zookeeper-node-2、zookeeper-node-3  </li>
<li>分别copy三个节点下conf/zoo_sample.cfg文件重命名为zoo.cfg,并修改配置  </li>
<li>然后在zookeeper-node-1、zookeeper-node-2、zookeeper-node-3同级目录下创建目录zookeeper-data/8001/data、zookeeper-data/8002/data、zookeeper-data/8003/data、zookeeper-data/8001/logs、zookeeper-data/8002/logs、zookeeper-data/8003/logs  </li>
<li>在zookeeper-data/8001/data、zookeeper-data/8002/data、zookeeper-data/8003/data目录下分别创建文件myid,分别在myid中写入1,2,3</li>
<li><p>/bin/zkServer.sh start 分别启动三台服务<br>zoo.cfg配置如下:</p>
<pre><code>  # The number of milliseconds of each tick
  # The number of milliseconds of each tick
  tickTime=2000
  # The number of ticks that the initial
  # synchronization phase can take
  initLimit=10
  # The number of ticks that can pass between
  # sending a request and getting an acknowledgement
  syncLimit=5
  # the directory where the snapshot is stored.
  dataDir=/Users/wenchao.wang/dev/zookeeper-cluster/zookeeper-data/8002/data
  # dataDir=/Users/wenchao.wang/dev/zookeeper-cluster/zookeeper-data/8001/data
  # dataDir=/Users/wenchao.wang/dev/zookeeper-cluster/zookeeper-data/8003/data
  dataLogDir=/Users/wenchao.wang/dev/zookeeper-cluster/zookeeper-data/8002/logs
  # dataLogDir=/Users/wenchao.wang/dev/zookeeper-cluster/zookeeper-data/8001/logs
  # dataLogDir=/Users/wenchao.wang/dev/zookeeper-cluster/zookeeper-data/8003/logs

  # the port at which the clients will connect
  clientPort=2182
  # clientPort=2181
  # clientPort=2183

  # server.number (number是1、2、3)分别对应myid中的内容，
  # zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端
  # 口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口
  server.1=127.0.0.1:8001:9001
  server.2=127.0.0.1:8002:9002
  server.3=127.0.0.1:8003:9003
</code></pre></li>
</ul>
</li>
</ul>
<p>下面是在本地机器上配置的zookeeper集群三级目录树状图:</p>
<pre><code>        /Users/wenchao.wang/dev/zookeeper-cluster
        ├── zookeeper-data
        │   ├── 8001
        │   │   ├── data
        │   │   └── logs
        │   ├── 8002
        │   │   ├── data
        │   │   └── logs
        │   └── 8003
        │       ├── data
        │       └── logs
        ├── zookeeper-node-1
        │   ├── bin
        │   ├── conf
        │   ├── contrib
        │   │   ├── ZooInspector
        │   │   ├── bookkeeper
        │   │   ├── fatjar
        │   │   ├── rest
        │   │   ├── zkfuse
        │   │   ├── zkperl
        │   │   ├── zkpython
        │   │   └── zktreeutil
        │   ├── data
        │   ├── dist-maven
        │   ├── docs
        │   │   ├── api
        │   │   ├── images
        │   │   ├── jdiff
        │   │   └── skin
        │   ├── lib
        │   │   ├── cobertura
        │   │   └── jdiff
        │   ├── recipes
        │   │   ├── lock
        │   │   └── queue
        │   └── src
        │       ├── c
        │       ├── contrib
        │       ├── docs
        │       ├── java
        │       └── recipes
        ├── zookeeper-node-2
        │   ├── bin
        │   ├── conf
        │   ├── contrib
        │   │   ├── ZooInspector
        │   │   ├── bookkeeper
        │   │   ├── fatjar
        │   │   ├── rest
        │   │   ├── zkfuse
        │   │   ├── zkperl
        │   │   ├── zkpython
        │   │   └── zktreeutil
        │   ├── data
        │   ├── dist-maven
        │   ├── docs
        │   │   ├── api
        │   │   ├── images
        │   │   ├── jdiff
        │   │   └── skin
        │   ├── lib
        │   │   ├── cobertura
        │   │   └── jdiff
        │   ├── recipes
        │   │   ├── lock
        │   │   └── queue
        │   └── src
        │       ├── c
        │       ├── contrib
        │       ├── docs
        │       ├── java
        │       └── recipes
        └── zookeeper-node-3
            ├── bin
            ├── conf
            ├── contrib
            │   ├── ZooInspector
            │   ├── bookkeeper
            │   ├── fatjar
            │   ├── rest
            │   ├── zkfuse
            │   ├── zkperl
            │   ├── zkpython
            │   └── zktreeutil
            ├── data
            ├── dist-maven
            ├── docs
            │   ├── api
            │   ├── images
            │   ├── jdiff
            │   └── skin
            ├── lib
            │   ├── cobertura
            │   └── jdiff
            ├── recipes
            │   ├── lock
            │   └── queue
            └── src
                ├── c
                ├── contrib
                ├── docs
                ├── java
                └── recipes
</code></pre><h4 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h4><p>在bin/目录下执行<code>./zkCli.sh</code>,登录客户端,输入任意字符回车,会看见命令提示,下面简单的介绍一些常用的命令:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stat path [watch]</td>
<td>查看节点状态,例:<code>stat /lios/server</code></td>
</tr>
<tr>
<td>set path data [version]</td>
<td>节点设值,例:<code>set /lios/server 3</code></td>
</tr>
<tr>
<td>ls path [watch]</td>
<td>查看节点子节点,例:<code>ls /lios/server</code></td>
</tr>
<tr>
<td>delete path [version]</td>
<td>删除节点,例:<code>delete /lios/server/f</code></td>
</tr>
<tr>
<td>get path [watch]</td>
<td>获取节点值,例:<code>get /lios/server</code></td>
</tr>
<tr>
<td>create [-s] [-e] path data acl</td>
<td>创建节点,例:<code>create /lios/server/f &quot;lios&quot;</code>,加上-e参数表示临时节点,重启会丢失数据;-s表示创建有序节点</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点 例子:<code>rmr /lios/server</code></td>
</tr>
<tr>
<td>ls2</td>
<td>查看节点及其他信息,例:<code>ls2 /lios/server</code></td>
</tr>
</tbody>
</table>
<h4 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h4><p>下面通过Java代码简单说明,服务端往zookeeper中添加节点信息,客户端订阅该节点,当节点发生变化时,刷新节点数据,首先添加依赖包:</p>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
     &lt;version&gt;3.4.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>ZookeeperServer:</p>
<pre><code>/**
 * @author LiosWong
 * @description
 * @date 2019/4/18 下午4:39
 */
public class ZookeeperServer extends AbstractZoo &#123;

    // 创建链接
    @Override
    protected ZooKeeper connect() &#123;
        try &#123;
            zooKeeper = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;
                @Override
                public void process(WatchedEvent event) &#123;
                    // 当连接状态时,处理逻辑.关于状态参考org.apache.zookeeper.Watcher.Event.KeeperState
                    if (Event.KeeperState.SyncConnected.equals(event.getState())) &#123;
                        System.out.println(&quot;====&gt;&quot; + event.getPath() + &quot;;&quot; + event.getType());
                    &#125;
                &#125;
            &#125;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return zooKeeper;
    &#125;

    // 创建节点
    public ZooKeeper serverRegister(Integer type, String data) &#123;
        try &#123;
            Stat stat = connect().exists(CREATE_SERVER_NODE, true);
            switch (type) &#123;
                case 1:
                    // 同步创建节点
                    if (Objects.isNull(stat)) &#123;
                        zooKeeper.create(CREATE_SERVER_NODE, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
//                        zooKeeper.create(CREATE_SERVER_NODE, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);  顺序节点
                    &#125;
                    break;
                case 2:
                    // 异步创建节点
                    zooKeeper.create(CREATE_SERVER_NODE, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new CallBack(), &quot;异步创建节点&quot;);
//                    zooKeeper.create(CREATE_SERVER_NODE, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, new CallBack(), &quot;异步创建节点&quot;);  顺序节点
                    break;
                default:
                    break;
            &#125;
        &#125; catch (KeeperException e) &#123;
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return zooKeeper;
    &#125;


    public static void main(String[] args) throws InterruptedException &#123;
        ZookeeperServer zoo = new ZookeeperServer();
        zoo.serverRegister(2, &quot;d,&quot;);
        Thread.sleep(999999);
    &#125;

    private static class CallBack implements AsyncCallback.StringCallback &#123;

        @Override
        public void processResult(int rc, String path, Object ctx, String name) &#123;
            System.out.println(&quot;rc=&quot; + rc + &quot;;&quot; + &quot;path=&quot; + path + &quot;;&quot; + &quot;ctx=&quot; + ctx + &quot;;&quot; + &quot;name=&quot; + name);
        &#125;
    &#125;
&#125;

public abstract class AbstractZoo &#123;
    protected static final String connectString = &quot;127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183&quot;;
    protected static final int sessionTimeout = 10000;
    protected static final String CREATE_SERVER_NODE = &quot;/lios/server/g&quot;;
    protected static final String GET_SERVER_NODE = &quot;/lios/server&quot;;
    protected static ZooKeeper zooKeeper = null;

    // 创建链接
    protected abstract ZooKeeper connect();

    // 获取节点
    protected void getNodeData() &#123;

    &#125;
&#125;

</code></pre><p>ZookeeperClient:</p>
<pre><code>public class ZookeeperClient extends AbstractZoo &#123;
    @Override
    protected ZooKeeper connect() &#123;
        try &#123;
            zooKeeper = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;
                @Override
                public void process(WatchedEvent event) &#123;
                    if (Event.KeeperState.SyncConnected.equals(event.getState())) &#123;
                        // 刷新节点
                        getNodeData();
                    &#125;
                &#125;
            &#125;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return zooKeeper;
    &#125;

    @Override
    protected void getNodeData() &#123;
        try &#123;
            List&lt;String&gt; childList = zooKeeper.getChildren(GET_SERVER_NODE, true);
            for (String addr : childList) &#123;
                byte[] data = zooKeeper.getData(GET_SERVER_NODE + &quot;/&quot; + addr, false, null);
                System.out.println(&quot;=======&gt;节点addr:&quot; + addr + &quot;;&quot; + &quot;data:&quot; + new String(data));
            &#125;
            System.out.println(&quot;==================&gt;刷新完成&quot;);
        &#125; catch (KeeperException e) &#123;
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        AbstractZoo client = new ZookeeperClient();
        client.connect();
        client.getNodeData();
        try &#123;
            Thread.sleep(99999999);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre><p>发现ZookeeperServer中只要在<code>/lios/server</code>下新增或删除,ZookeeperClient中都会刷新该节点下的列表,实际中可通过<code>./zkCli.sh</code>在命令下操作节点,观察ZookeeperClient下刷新状态.</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>zookeeper集群</tag>
      </tags>
  </entry>
  <entry>
    <title>java双重锁定检查</title>
    <url>/2019/04/01/java%E5%8F%8C%E9%87%8D%E9%94%81%E5%AE%9A%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>在阅读dubbo源码时,很多类似如下代码:</p>
<pre><code>        Object instance = holder.get();
        if (instance == null) &#123;
            synchronized (holder) &#123;
                instance = holder.get();
                if (instance == null) &#123;
                    instance = createExtension(name);
                    holder.set(instance);
                &#125;
            &#125;
        &#125;
</code></pre><p>上面的代码保证对象instance唯一,如果上面代码改写成:</p>
<pre><code>        Object instance = holder.get();
        instance = holder.get();
            if (instance == null) &#123;
                instance = createExtension(name);
                holder.set(instance);
            &#125;

</code></pre><p>这样显然是在多线程下非安全的,若两个线程A、B,A发现instance为空,然后执行createExtension方法创建对象,此时cpu分配给现场A的时间片已经用完了,线程A让出cpu,线程B也执行到该方法块,发现instance为空,也执行createExtension方法创建对象,这样会导致instance对象被重复创建.<br>再改写成:</p>
<pre><code>        Object instance = holder.get();
        synchronized (holder) &#123;
        instance = holder.get();
            if (instance == null) &#123;
                instance = createExtension(name);
                holder.set(instance);
            &#125;
        &#125;
</code></pre><p>这样虽然可以保证对象的唯一性,但是存在同步锁性能开销问题,因此人们想出”双重锁定检查(Double-checked locking)”来解决该问题:首先检查对象是否为空,不为空则不需要创建,若为空则待创建,然后通过加锁创建对象,这样可以大大降低同步锁带来的性能开销问题.</p>
<blockquote>
<p>参考文章  </p>
</blockquote>
<ol>
<li><a href="https://blog.csdn.net/tuhooo/article/details/84577996">https://blog.csdn.net/tuhooo/article/details/84577996</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2019/03/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">–维基百科</a><br>适配器模式包含如下角色:  </p>
<ol>
<li>Target(目标抽象类)  </li>
<li>Adapter(适配器类)  </li>
<li>Adaptee(适配者类)  </li>
<li>Client(客户类)  </li>
</ol>
<p>适配器UML类图如下(图片摘自<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html</a>):<br><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg" alt="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg"><br>生活中时常会有这样的场景,使用的电脑显示屏接口分为VGA、HDMI,有很多显示屏只支持VGA,若使用时需要连接支持VGA的接口的电脑,有一些显示屏只支持HDMI,若使用时只能连接支持HDMI的电脑,那如果用户买了一台只支持VGA接口的显示屏,而电脑只支持HDMI接口,此时只需要购买VGA、HDMI转换器即可,下面通过代码说明.<br>VgaScreenInterface(VGA屏幕接口):</p>
<pre><code>public interface VgaScreenInterface &#123;
    void vgaSocket();
&#125;
</code></pre><p>VgaComputer(只支持VGA接口的电脑):</p>
<pre><code>public class VgaComputer implements VgaScreenInterface &#123;
    @Override
    public void vgaSocket() &#123;
        System.out.println(&quot;VGA屏幕与VGA电脑已连接&quot;);
    &#125;
&#125;
</code></pre><p>HdmiScreenInterface(HDMI屏幕接口):</p>
<pre><code>public interface HdmiScreenInterface &#123;
    void hdmiSocket();
&#125;
</code></pre><p>HdmiComputer(只支持HDMI接口的电脑):</p>
<pre><code>public class HdmiComputer implements HdmiScreenInterface &#123;
    @Override
    public void hdmiSocket() &#123;
        System.out.println(&quot;Hdmi屏幕已经与电脑连接&quot;);
    &#125;
&#125;
</code></pre><p>此时由于购买的屏幕支持VGA接口,而电脑只支持HMDI接口,只需要通过转换器(适配器)即可:</p>
<pre><code>public class SocketAdapter implements VgaScreenInterface &#123;
    // 获取适配者类的引用
    HdmiScreenInterface hdmiScreenInterface;

    public SocketAdapter(HdmiScreenInterface hdmiScreenInterface) &#123;
        this.hdmiScreenInterface = hdmiScreenInterface;
    &#125;

    @Override
    public void vgaSocket() &#123;
        hdmiScreenInterface.hdmiSocket();
    &#125;
&#125;
</code></pre><p>User(用户类):</p>
<pre><code>public class User &#123;

    VgaScreenInterface vgaScreenInterface;

    public User setAdapter(VgaScreenInterface vgaScreenInterface) &#123;
        this.vgaScreenInterface = vgaScreenInterface;
        return this;
    &#125;

    public void use()&#123;
        vgaScreenInterface.vgaSocket();
    &#125;
&#125;
</code></pre><p>测试:</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        HdmiScreenInterface hdmiScreenInterface = new HdmiComputer();
        VgaScreenInterface vgaScreenInterface = new SocketAdapter(hdmiScreenInterface);
        User user = new User();
        user.setAdapter(vgaScreenInterface);
        user.use();
    &#125;
&#125;
</code></pre><p>以上User为:Client,VgaScreenInterface为:目标抽象类,SocketAdapter为:适配器类,HdmiComputer为:适配者类<br>适配器具有一下优点:  </p>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码  </li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性  </li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”  </li>
</ol>
<blockquote>
<p>文章参考</p>
</blockquote>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F</a></li>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2019/03/14/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>修饰模式(装饰者模式)，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。<a href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F">–维基百科</a><br>装饰者UML类图(摘自维基百科):<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Decorator_UML_class_diagram.svg/800px-Decorator_UML_class_diagram.svg.png" alt="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Decorator_UML_class_diagram.svg/800px-Decorator_UML_class_diagram.svg.png">  </p>
<ol>
<li><strong>Component(基类)</strong><br>它是被装饰者和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作  </li>
<li><strong>ConcreteComponent(被装饰者)</strong><br>它是Component的子类，用于定义具体的构件对象，实现了在抽象装饰类中声明的方法，装饰类可以给它增加额外的职责   </li>
<li><strong>Decorator(抽象装饰类)</strong><br>它也是Component的子类，用于给具体装饰者增加职责，同样是所有具体装饰者的共同的继承的抽象类,但是具体职责在其子类中实现。它维护一个指向Component对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的  </li>
<li><strong>ConcreteDecorator(具体装饰类)</strong><br>是具体的装饰者，由于它同时也是Component的子类，因此它能方便地拓展Component的状态（比如添加新的方法）。每个装饰者都应该有一个实例变量用以保存某个Component的引用，这也是利用了组合的特性。在持有Component的引用后，由于其自身也是Component的子类，那么，相当于ConcreteDecorator包裹了Component，不但有Component的特性，同时自身也可以有别的特性，也就是所谓的装饰  </li>
</ol>
<p>生活中的火锅,有多种锅底,比如牛油火锅、鸳鸯火锅、酸菜火锅…,以牛油火锅为例,牛油火锅里包含多种套餐,如套餐A、套餐B,若在套餐A、B外再加羊排、鸡排等菜品需要支付套餐额外的费用,若计算吃一顿火锅的花费,以上可把火锅可以看作Component(基类),牛油火锅为ConcreteComponent(被装饰者),套餐A、B为Decorator(抽象装饰类),添加羊排、鸡排看作成ConcreteDecorator(具体装饰类),下面通过代码说明:</p>
<p>Component:</p>
<pre><code>public interface HotPot &#123;
    float cost();
    String desc();
&#125;
</code></pre><p>ConcreteComponent:</p>
<pre><code>public class ButterHotPot implements HotPot&#123;
    @Override
    public float cost() &#123;
        return 50f;
    &#125;

    @Override
    public String desc() &#123;
        return &quot;&quot;;
    &#125;
&#125;
</code></pre><p>Decorator:</p>
<pre><code>public abstract class ApackageButterHopPot implements HotPot&#123;
    @Override
    public abstract float cost();
    public String desc()&#123;
        return &quot;套餐A&quot;;
    &#125;
&#125;
</code></pre><p>ConcreteDecorator:</p>
<pre><code>public class ChickenChops extends ApackageButterHopPot &#123;
    HotPot hotPot;

    public ChickenChops(HotPot hotPot) &#123;
        this.hotPot = hotPot;
    &#125;

    @Override
    public float cost() &#123;
        return hotPot.cost() + 20f;
    &#125;

    @Override
    public String desc() &#123;
        return hotPot.desc()+&quot;新增了鸡排&quot;;
    &#125;
&#125;

public class LambChops extends ApackageButterHopPot &#123;
    HotPot hotPot;

    public LambChops(HotPot hotPot) &#123;
        this.hotPot = hotPot;
    &#125;

    @Override
    public float cost() &#123;
        return hotPot.cost() + 50f;
    &#125;

    @Override
    public String desc() &#123;
        return hotPot.desc() + &quot;新增了羊排&quot;;
    &#125;
&#125;
</code></pre><p>测试:</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        HotPot hotPot = new ButterHotPot();
        hotPot = new LambChops(hotPot);
        hotPot = new ChickenChops(hotPot);
        System.out.println(&quot;总共消费了:&quot;+hotPot.cost()+&quot;元&quot;+&quot;,&quot;+hotPot.desc());

    &#125;
&#125;
</code></pre><p>以上通过简单的例子说明装饰模式的应用,其实不难发现装饰者、被装饰者都继承同一基类(Component),装饰类用来修饰被装饰类,但是被装饰类一般会作为构造函数的参数被装饰类所引用,用来获取被装饰者的状态信息,用来将自身的功能加强;装饰模式非常灵活,通过不同的装饰类使得被装饰类功能增强,JAVA里的Java I/O Streams是非常经典的装饰者模式.</p>
<blockquote>
<p>参考文章  </p>
</blockquote>
<ol>
<li><a href="https://blog.csdn.net/a553181867/article/details/52108423">https://blog.csdn.net/a553181867/article/details/52108423</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2019/03/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。<a href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">–维基百科</a><br>生活中,顾客(Customer)去商店购买电器,但是由于缺货,顾客留下手机号码,告知店主(Manager)有货时及时通知;即顾客(观察者)订阅了店主(被订阅者)的到货的服务,当有货时,店家立即通知顾客.<br>下面通过demo说明,观察者抽象类Observer:</p>
<pre><code>public abstract class Observer &#123;
    abstract void notice();
&#125;
</code></pre><p>观察者A、B:</p>
<pre><code>public class CustomerA extends Observer&#123;
    @Override
    void notice() &#123;
        System.out.println(&quot;CustomerA已经收到到货通知&quot;);
    &#125;
&#125;
public class CustomerB extends Observer&#123;
    @Override
    void notice() &#123;
        System.out.println(&quot;CustomerB已经收到到货通知&quot;);
    &#125;
&#125;
</code></pre><p>被观察者抽象类Observable:</p>
<pre><code>public abstract class Observable &#123;
    List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();
    // 添加观察者(注册观察者;观察者订阅通知)
    protected Observable addObserver(Observer observer)&#123;
        observers.add(observer);
        return this;
    &#125;
    // 删除观察者
    protected Observable delObserver(Observer observer)&#123;
        observers.remove(observer);
        return this;
    &#125;
    // 通知
    protected void notice()&#123;
        observers.forEach(p-&gt;&#123;
            p.notice();
        &#125;);
    &#125;

&#125;
</code></pre><p>被观察者:</p>
<pre><code>public class Manager extends Observable&#123;
    @Override
    protected void notice() &#123;
        observers.forEach(p-&gt;&#123;
            p.notice();
        &#125;);
    &#125;
&#125;
</code></pre><p>测试:</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        Observer observerA = new CustomerA();
        Observer observerB = new CustomerB();
        Observable observable = new Manager();
        // 观察者订阅通知
        observable.addObserver(observerA)
                .addObserver(observerB);
        observable.notice();
    &#125;
&#125;
</code></pre><p>java.util包下的<code>Observer</code>、<code>Observable</code>,是java为观察者模式提供的支持类,上面的demo完全可以通过这两个类去完成:<br>观察者Customer:</p>
<pre><code>   public class Customer implements Observer &#123;
    @Override
    public void update(Observable o, Object arg) &#123;
        System.out.println(&quot;Customer已经收到消息&quot;);
        // 删除当前订阅者
        o.deleteObserver(this);
    &#125;
&#125;
</code></pre><p>被观察者Manager:</p>
<pre><code>public class Manager extends Observable&#123;
    public Manager() &#123;
        super();
    &#125;

    // 添加观察者
    @Override
    public synchronized void addObserver(Observer o) &#123;
        super.addObserver(o);
        // 标记被订阅者已改变,否则无法通知到观察者
        super.setChanged();
    &#125;
    // 删除观察者
    @Override
    public synchronized void deleteObserver(Observer o) &#123;
        super.deleteObserver(o);
    &#125;
    // 发送通知
    @Override
    public void notifyObservers() &#123;
        super.notifyObservers();
    &#125;

    @Override
    public void notifyObservers(Object arg) &#123;
        super.notifyObservers(arg);
    &#125;

    @Override
    public synchronized void deleteObservers() &#123;
        super.deleteObservers();
    &#125;

    @Override
    protected synchronized void setChanged() &#123;
        super.setChanged();
    &#125;

    @Override
    protected synchronized void clearChanged() &#123;
        super.clearChanged();
    &#125;

    @Override
    public synchronized boolean hasChanged() &#123;
        return super.hasChanged();
    &#125;

    @Override
    public synchronized int countObservers() &#123;
        return super.countObservers();
    &#125;
&#125;
</code></pre><p>测试:</p>
<pre><code>public class Test &#123;
    public static void main(String[] args) &#123;
        Observer observer = new Customer();
        Observable observable = new Manager();
        observable.addObserver(observer);
        observable.notifyObservers();
    &#125;
&#125;
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>GCP搭建V2ray服务</title>
    <url>/2019/03/06/GCP%E6%90%AD%E5%BB%BAV2ray%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>由于之前使用的virmach vps,搭建的v2ray服务,首先来看下配置:</p>
<pre><code>•   512MB RAM
•   20GB Disk
•   500GB Bandwidth @ 1 Gbps
•   Shared Intel HT CPU 2 Cores @ 1.5GHz
•   1x IPv4 Addresses
</code></pre><p>是最低配版的服务器,而且不够稳定,这次通过GCP搭建V2ray服务,首先得有google账号,然后在<a href="https://cloud.google.com/free/">https://cloud.google.com/free/</a>注册,可以获得300美金赠金,12月内可畅享GCP,再到<a href="https://console.cloud.google.com">https://console.cloud.google.com</a>新建<code>Project</code>并关联结算账户.由于我没有申请GCP服务,用的是同学的账号,省去了前面的一部分流程,下面简单介绍下配置、搭建流程.</p>
<h4 id="创建VM实例"><a href="#创建VM实例" class="headerlink" title="创建VM实例"></a>创建VM实例</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7368471975985095dcd0b25b92a94bb6?method=download&amp;shareKey=fc85e82ea39869353c28aa058bd46e5c" alt="https://note.youdao.com/yws/api/personal/file/WEB7368471975985095dcd0b25b92a94bb6?method=download&amp;shareKey=fc85e82ea39869353c28aa058bd46e5c"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB165db1e068be8d3e88f7af199b3ff17b?method=download&amp;shareKey=0206137fd63217f96266d1b42e839a72" alt="https://note.youdao.com/yws/api/personal/file/WEB165db1e068be8d3e88f7af199b3ff17b?method=download&amp;shareKey=0206137fd63217f96266d1b42e839a72"><br>服务器最好选择香港、台湾或者日本,离大陆较近,TTL较小,速度更快,然后再防火墙处勾选HTTP流量.创建完之后,回到首页会看到Project、实例:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBbaabf5d35d7dbb7e9fc95cce701dc06a?method=download&amp;shareKey=8cf7ca4496a370c96524734a1fffe985" alt="https://note.youdao.com/yws/api/personal/file/WEBbaabf5d35d7dbb7e9fc95cce701dc06a?method=download&amp;shareKey=8cf7ca4496a370c96524734a1fffe985"></p>
<h4 id="防火墙规则、外部IP地址"><a href="#防火墙规则、外部IP地址" class="headerlink" title="防火墙规则、外部IP地址"></a>防火墙规则、外部IP地址</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd0417df3e1a4d541e99717cbc41cb760?method=download&amp;shareKey=60cad63353b81075e15464104044f580" alt="https://note.youdao.com/yws/api/personal/file/WEBd0417df3e1a4d541e99717cbc41cb760?method=download&amp;shareKey=60cad63353b81075e15464104044f580"><br>注意在添加出站防火墙规则时,目标是所有实例<br><img src="https://note.youdao.com/yws/api/personal/file/WEB891d0bd5a2a5ba500ef54e0fb49c85ca?method=download&amp;shareKey=e9b9497f365c873baa1b577413d1a714" alt="https://note.youdao.com/yws/api/personal/file/WEB891d0bd5a2a5ba500ef54e0fb49c85ca?method=download&amp;shareKey=e9b9497f365c873baa1b577413d1a714"><br>在配置当前实例IP类型选择静态</p>
<h4 id="配置服务器、一键安装V2ray"><a href="#配置服务器、一键安装V2ray" class="headerlink" title="配置服务器、一键安装V2ray"></a>配置服务器、一键安装V2ray</h4><ul>
<li><p>配置<br>首先需要在网页打开SSH会话窗口,登录服务器后:</p>
<pre><code>sudo -i  #切换用户
vi /etc/ssh/sshd_config
</code></pre><p>修改sshd_config文件:</p>
<pre><code># Authentication:
PermitRootLogin yes //开启root用户访问
# Change to no to disable tunnelled clear text passwords
PasswordAuthentication yes //开启密码登陆
</code></pre><p>修改后执行<code>passwd root</code>重置root密码,然后再重启ssh服务:<br><code>/etc/init.d/ssh restart</code><br>此时可以ssh在本地通过密码登录服务器<br>可以安装ufw(<code>apt-get install ufw`)关闭防火墙(</code>ufw disable<code></code>),实际没有多大意义</p>
</li>
<li><p>安装V2ray服务<br>执行<code></code>source &lt;(curl -sL <a href="https://git.io/fNgqx)`,可以一键安装V2ray,完成后在终端输入V2ray,可以通过界面化操作,使用起来很方便,V2ray安装路径信息">https://git.io/fNgqx)`,可以一键安装V2ray,完成后在终端输入V2ray,可以通过界面化操作,使用起来很方便,V2ray安装路径信息</a>:</p>
<pre><code>/usr/bin/v2ray/v2ray：V2Ray 程序
/usr/bin/v2ray/v2ctl：V2Ray 工具
/etc/v2ray/config.json：配置文件
/usr/bin/v2ray/geoip.dat：IP 数据文件
/usr/bin/v2ray/geosite.dat：域名数据文件
</code></pre><p>其中<code>config.json</code>文件是服务配置文件,以上的一键化脚本来自<a href="https://github.com/Jrohy/multi-v2ray">https://github.com/Jrohy/multi-v2ray</a>,当然网上还有很多配置脚本.配置完成之后,还可以通过该界面化生成客户端配置json,把客户端配置json copy到客户端配置condig.json中即可,手机V2ray客户端:<a href="https://github.com/2dust/v2rayNG">v2rayNG</a>,mac客户端:<a href="https://github.com/v2ray/v2ray-core">v2ray-core</a><br>V2ray服务完全可以根据官方文档完成,而且网上有丰富的v2ray配置模板,可搭建出更快、更稳定的V2ray服务!最后感谢磊哥提供强大的GCP云服务器,让速度更快更稳定!</p>
</li>
</ul>
<blockquote>
<p>参考资料</p>
</blockquote>
<ol>
<li><a href="https://cloud.google.com/vpc/docs/">https://cloud.google.com/vpc/docs/</a></li>
<li><a href="https://www.flyzy2005.com/v2ray/how-to-build-v2ray/">https://www.flyzy2005.com/v2ray/how-to-build-v2ray/</a></li>
<li><a href="https://github.com/KiriKira/vTemplate">https://github.com/KiriKira/vTemplate</a></li>
<li><a href="https://www.v2ray.com/">https://www.v2ray.com/</a></li>
<li><a href="https://toutyrater.github.io/">https://toutyrater.github.io/</a></li>
<li><a href="https://github.com/2dust/v2rayNG/releases">https://github.com/2dust/v2rayNG/releases</a></li>
<li><a href="https://github.com/Jrohy/multi-v2ray">https://github.com/Jrohy/multi-v2ray</a></li>
<li><a href="https://blog1.jyzzj.online/?p=2000">https://blog1.jyzzj.online/?p=2000</a></li>
</ol>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>GCP</tag>
        <tag>V2ray</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/2019/03/04/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，重新定义算法中的某些步骤.在软件工程中，它是一种软件设计模式，和C++模板没有关连.–<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">维基百科</a></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>首先看一个最常见的模版方法,Spring中的<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>方法,它是IOC容器的入口,定义了初始化流程,其中公共的执行逻辑,在父类中实现,对于不同的实现,在子类中去实现即可,Spring中几乎所有的扩展都运用了模版方法.<br>麦子、水稻是人类主要的作物,它们大致的一生为<code>播种 --》灌溉 --》施肥 --》除草 --》收割 --》加工 --》食用</code>,其中播种、灌溉、加工、食用两者相差非常大,而施肥、除草、收割几乎相同,下面用代码说明,<br>首选定义FooldLife:</p>
<pre><code>public abstract class FooldLife &#123;
    public void fooldLife() &#123;
        sowing();
        irrigation();
        fertilization();
        weeding();
        harvest();
        machining();
        harvest();
        edible();
    &#125;

    // 播种
    protected void sowing() &#123;
        // 空方法,具体逻辑由子类实现
    &#125;

    // 灌溉
    protected void irrigation() &#123;
        // 空方法,具体逻辑由子类实现
    &#125;

    // 施肥 公共实现
    protected void fertilization() &#123;
        // ... 具体实现
        System.out.println(&quot;施肥---&quot;);
    &#125;

    // 除草 公共实现
    protected void weeding() &#123;
        // ... 具体实现
        System.out.println(&quot;除草---&quot;);
    &#125;

    // 收割 公共实现
    protected void harvest() &#123;
        // ... 具体实现
        System.out.println(&quot;收割---&quot;);
    &#125;

    // 加工
    protected void machining() &#123;
        // 空方法,具体逻辑由子类实现
    &#125;

    // 食用
    protected void edible() &#123;
        // 空方法,具体逻辑由子类实现
    &#125;

&#125;
</code></pre><p>子类RiceLife:</p>
<pre><code>public class RiceLife extends FooldLife &#123;
    @Override
    protected void sowing() &#123;
        // 具体实现
        System.out.println(&quot;播种---&quot;);
    &#125;

    @Override
    protected void irrigation() &#123;
        // 具体实现
        System.out.println(&quot;灌溉---&quot;);
    &#125;

    @Override
    protected void machining() &#123;
        // 具体实现
        System.out.println(&quot;加工---&quot;);
    &#125;

    @Override
    protected void edible() &#123;
        // 具体实现
        System.out.println(&quot;食用---&quot;);
    &#125;
&#125;
</code></pre><p>子类WheatLife:</p>
<pre><code>public class WheatLife extends FooldLife &#123;
    @Override
    protected void sowing() &#123;
        // 具体实现
        System.out.println(&quot;播种---&quot;);
    &#125;

    @Override
    protected void irrigation() &#123;
        // 具体实现
        System.out.println(&quot;灌溉---&quot;);
    &#125;

    @Override
    protected void machining() &#123;
        // 具体实现
        System.out.println(&quot;加工---&quot;);
    &#125;

    @Override
    protected void edible() &#123;
        // 具体实现
        System.out.println(&quot;食用---&quot;);
    &#125;
&#125;
</code></pre><p>FooldLife中的fooldLife方法描述了作物的一生,<code>fertilization</code>、<code>weeding</code>、<code>harvest</code>方法为公共方法;而其他方法需求子类去重写,也就是空方法(钩子),子类可以由该方法控制父类,通过以上总结下模版方法模式:</p>
<ol>
<li>代码复用性<br>公共代码由父类实现,子类复用</li>
<li>可扩展性<br>子类可以对父类方法扩展、功能加强</li>
</ol>
<blockquote>
<p>参考 </p>
</blockquote>
<ol>
<li><a href="https://blog.csdn.net/z69183787/article/details/65628166">https://blog.csdn.net/z69183787/article/details/65628166</a>  </li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%92%A9%E5%AD%90%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/%E9%92%A9%E5%AD%90%E7%BC%96%E7%A8%8B</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模版方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2019/03/03/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。–<a href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">维基百科</a><br>在项目中时常会用到策略模式的场景,比如业务中需要支付,但是有多个支付渠道,那如何对上层业务暴露”统一口径”(接口)呢,下面结合代码说明,<br>首先定义支付接口:</p>
<pre><code>public interface Pay&#123;
    // 具体支付业务逻辑
    public void toPay();
    // 支付类型
    public Integer payType();
&#125;
</code></pre><p>AliPay:</p>
<pre><code>public class AliPay implements Pay&#123;
    public void toPay()&#123;
        ...
    &#125;
    public Integer payType()&#123;
        // 返回支付类型枚举
        return 1;
    &#125;
&#125;
</code></pre><p>WxPay:</p>
<pre><code>public class WxPay implements Pay&#123;
    public void toPay()&#123;
        ...
    &#125;
    public Integer payType()&#123;
        // 返回支付类型枚举
        return 2;
    &#125;
&#125;
</code></pre><p>不同的实现已经好了,需要在上层业务中传入不同的支付类型,调用具体的实现,结合在Spring项目中使用方式:</p>
<pre><code>@Component
public class PayTypeUtil implements InitializingBean&#123;
    @Autowired
    private List&lt;Pay&gt; payList;
    private static final Map&lt;Integer,Pay&gt; payMap = Maps.newHashMap();
    @Override
    public void afterPropertiesSet() throws Exception &#123;
        for (Pay pay : payList) &#123;
            payMap.put(pay.payType(),pay);
        &#125;
    &#125;
    public Pay getPayService(Integer payType)&#123;
        return payMap.get(payType);
    &#125;
    public static void putService(Pay pay)&#123;
        payMap.put(pay.payType(),pay);
    &#125;
&#125;
</code></pre><p>直接使用<code>PayTypeUtil</code>的getPayService方法传入不同的支付类型便可得到具体的实现,上面借助了Spring中的<code>InitializingBean</code>接口实现了在bean初始化时,加载<code>Pay</code>所有的实现类(InitializingBean可参考文章<a href="https://blog.csdn.net/BAT_os/article/details/81844985">https://blog.csdn.net/BAT_os/article/details/81844985</a>),难道只有这种方法才可以实现么,当然不是,下面再介绍两种方法:  </p>
<ul>
<li>SPI<br>SPI的用法参考文章<a href="https://blog.csdn.net/BAT_os/article/details/83042569">https://blog.csdn.net/BAT_os/article/details/83042569</a>,下面用代码说明:<br><code>`</code></li>
</ul>
<ol>
<li>在META-INF/services中添加文件com.xxx.BaseApplication,并写入com.xxx.AliPay,com.xxx.WxPay</li>
<li>获取Pay所有实现,并注册<br>ServiceLoader<Pay> payLoader = ServiceLoader.load(Pay.class);<br>for(Pay pay:payLoader){<br> PayTypeUtil.putService(pay);<br>}<br><code>`</code></li>
</ol>
<ul>
<li>@PostConstruct<br>Java EE5引入了<code>@PostConstruct</code>(与之对应的是@PreDestroy),作用于Servlet生命周期的注解,实现Bean初始化之前的自定义操作,关于<code>@PostConstruct</code>可参考<a href="https://docs.oracle.com/javaee/5/api/javax/annotation/PostConstruct.html">https://docs.oracle.com/javaee/5/api/javax/annotation/PostConstruct.html</a>,具体代码:<pre><code>public class AliPay implements Pay&#123;
  @PostConstruct
  public void init()&#123;
     PayTypeUtil.putService(this); 
  &#125;
  public void toPay()&#123;
      ...
  &#125;
  public Integer payType()&#123;
      // 返回支付类型枚举
      return 1;
  &#125;
&#125;
public class WxPay implements Pay&#123;
  @PostConstruct
  public void init()&#123;
     PayTypeUtil.putService(this); 
  &#125;
  public void toPay()&#123;
      ...
  &#125;
  public Integer payType()&#123;
      // 返回支付类型枚举
      return 2;
  &#125;
&#125;
</code></pre>以上简单说明策略模式的用法,根据实际的业务场景结合使用.</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac Sublime Text3 Nodejs环境搭建</title>
    <url>/2019/02/28/Mac-Sublime-Text3-Nodejs%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>工作中会接触到管理后台的页面开发,之前用的IDE工具是IntelliJ IDEA,虽然功能强大,本身却很沉重,今天介绍使用sublimetext3搭建Nodejs运行环境.</p>
<h5 id="安装插件SublimeText-Nodejs及配置"><a href="#安装插件SublimeText-Nodejs及配置" class="headerlink" title="安装插件SublimeText-Nodejs及配置"></a>安装插件SublimeText-Nodejs及配置</h5><p>关于node、npm、sublimetext3的安装不做介绍,下载SublimeText-Nodejs(<a href="https://github.com/tanepiper/SublimeText-Nodejs">https://github.com/tanepiper/SublimeText-Nodejs </a>),并解压到Packages目录中,通过查找node、npm的路径,在<code>/Packages/SublimeText-Nodejs/Nodejs.sublime-settings</code>中配置:</p>
<pre><code>&#123;
  // if present, use this command instead of plain &quot;node&quot;
  // e.g. &quot;/usr/bin/node&quot; or &quot;C:\bin\node.exe&quot;
  &quot;node_command&quot;: &quot;/usr/local/bin/node&quot;,
  // Same for NPM command
  &quot;npm_command&quot;: &quot;/usr/local/bin/npm&quot;
&#125;
</code></pre><p>通过<code>Tools -&gt; Build System -&gt; New Build System</code>创建Nodejs.sublime-settings文件,并copy<code>/Packages/SublimeText-Nodejs/Nodejs.sublime-settings/Nodejs.sublime-settings</code>中的配置信息,修改:</p>
<pre><code>&#123;
  ...
  &quot;encoding&quot;: &quot;utf8&quot;,
  ...
    &quot;osx&quot;:
    &#123;
     ## &quot;shell_cmd&quot;: &quot;killall node; /usr/local/bin/node  $file&quot; 也可以这样配置
    &quot;shell_cmd&quot;: &quot;killall node; /usr/local/bin/npm start $file&quot;
    &#125;
&#125;
</code></pre><h5 id="导入项目-并执行"><a href="#导入项目-并执行" class="headerlink" title="导入项目,并执行"></a>导入项目,并执行</h5><p>sublimetext可以建立多个project,不同project可以快速切换,非常棒的功能,通过<code>File -&gt; open</code>打开项目,然后<code>Project -&gt; Save Project As</code>,这时会新建<code>*.sublime-project</code>文件,保存在该Project中,然后需要在<code>*.sublime-project</code>中配置Project的目录信息:</p>
<pre><code>
&#123;
    &quot;folders&quot;:
    [
        &#123;
            &quot;path&quot;: &quot;/Users/wenchao.wang/IdeaProjects/work/hzfd-dashboard&quot;
        &#125;,
        &#123;
            &quot;path&quot;: &quot;/Users/wenchao.wang/IdeaProjects/work/hzfd-dashboard&quot;
        &#125;
    ]
&#125;
</code></pre><p>项目已经添加好了,此时可以通过<code>control+command+p</code>切换Project啦,通过<code>control+b</code>执行,会选择build文件,选择<code>Nodejs.sublime-settings</code>即可,如图:<br><img src="https://img-blog.csdnimg.cn/20190228005934486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JBVF9vcw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>sublimetext提供大量的插件,用起来十分方便,笔者是一名sublimetext控,sublimetext不仅仅是文本编辑器,可以打造出强大功能的IDE,后续会继续分享sublimetext相关用法.</p>
<blockquote>
<p>参考文章  </p>
</blockquote>
<p><a href="https://www.jianshu.com/p/032a9867b3cb">https://www.jianshu.com/p/032a9867b3cb</a></p>
]]></content>
      <categories>
        <category>Sublime Text3</category>
      </categories>
      <tags>
        <tag>Sublime Text3</tag>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据类型及命令</title>
    <url>/2019/02/24/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性（英语：Durability_(database_systems)）的键值对存储数据库（英语：Key-value database）</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul>
<li>strings(字符串)<br>字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象。一个字符串类型的值最多能存储512M字节的内容。  </li>
<li>hashes(哈希)<br>Redis Hashes是字符串字段和字符串值之间的映射，所以它们是完美的表示对象（eg:一个有名，姓，年龄等属性的用户）的数据类型。  </li>
<li>lists(列表)<br>Redis列表是简单的字符串列表，按照插入顺序排序。 你可以添加一个元素到列表的头部（左边）或者尾部（右边）。LPUSH 命令插入一个新元素到列表头部，而RPUSH命令 插入一个新元素到列表的尾部。当 对一个空key执行其中某个命令时，将会创建一个新表。 类似的，如果一个操作要清空列表，那么key会从对应的key空间删除。这是个非常便利的语义，因为如果使用一个不存在的key作为参数，所有的列表命令都会像在对一个空表操作一样。  </li>
<li>sets(集合)<br>Redis集合是一个无序的字符串合集。你可以以O(1) 的时间复杂度（无论集合中有多少元素时间复杂度都为常量）完成 添加，删除以及测试元素是否存在的操作。<br>Redis集合有着不允许相同成员存在的优秀特性。向集合中多次添加同一元素，在集合中最终只会存在一个此元素。实际上这就意味着，在添加元素前，你并不需要事先进行检验此元素是否已经存在的操作。  </li>
<li>zset(有序集合)<br>Redis集合是一个无序的字符串合集。你可以以O(1) 的时间复杂度（无论集合中有多少元素时间复杂度都为常量）完成 添加，删除以及测试元素是否存在的操作。<br>Redis集合有着不允许相同成员存在的优秀特性。向集合中多次添加同一元素，在集合中最终只会存在一个此元素。实际上这就意味着，在添加元素前，你并不需要事先进行检验此元素是否已经存在的操作。  </li>
</ul>
<h5 id="命令-参考http-redis-cn-commands-html-string"><a href="#命令-参考http-redis-cn-commands-html-string" class="headerlink" title="命令(参考http://redis.cn/commands.html#string)"></a>命令(参考<a href="http://redis.cn/commands.html#string">http://redis.cn/commands.html#string</a>)</h5><ul>
<li>strings</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>APPEND key value</td>
<td>APPEND key value</td>
</tr>
<tr>
<td>BITCOUNT key [start end]</td>
<td>统计字符串指定起始位置的字节数</td>
</tr>
<tr>
<td>BITFIELD key[GET type offset][SET type offset value][INCRBY type offset increment][OVERFLOW WRAP、SAT、FAIL]</td>
<td>Perform arbitrary bitfield integer operations on strings</td>
</tr>
<tr>
<td>BITOP operation destkey key [key …]</td>
<td>Perform bitwise operations between strings</td>
</tr>
<tr>
<td>BITPOS key bit [start] [end]</td>
<td>Find first bit set or clear in a string</td>
</tr>
<tr>
<td>DECR key</td>
<td>整数原子减1</td>
</tr>
<tr>
<td>DECRBY key decrement</td>
<td>原子减指定的整数</td>
</tr>
<tr>
<td>GET key</td>
<td>返回key的value</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>返回位的值存储在关键的字符串值的偏移量。</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>获取存储在key上的值的一个子字符串</td>
</tr>
<tr>
<td>GETSET key value</td>
<td>设置一个key的value，并获取设置前的值</td>
</tr>
<tr>
<td>INCR key</td>
<td>执行原子加1操作</td>
</tr>
<tr>
<td>INCRBY key increment</td>
<td>执行原子增加一个整数</td>
</tr>
<tr>
<td>INCRBYFLOAT key increment</td>
<td>执行原子增加一个浮点数</td>
</tr>
<tr>
<td>MGET key [key …]</td>
<td>获得所有key的值</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>设置多个key value</td>
</tr>
<tr>
<td>MSETNX key value [key value …]</td>
<td>设置多个key value,仅当key存在时</td>
</tr>
<tr>
<td>PSETEX key milliseconds value</td>
<td>Set the value and expiration in milliseconds of a key</td>
</tr>
<tr>
<td>SET key value [EX seconds] [PX milliseconds] [NX</td>
<td>XX]</td>
<td>设置一个key的value值</td>
</tr>
<tr>
<td>SETBIT key offset value</td>
<td>Sets or clears the bit at offset in the string value stored at key</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>设置key-value并设置过期时间（单位：秒）</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>设置的一个关键的价值，只有当该键不存在</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>Overwrite part of a string at key starting at the specified offset</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>获取指定key值的长度</td>
</tr>
</tbody>
</table>
<ul>
<li>hashes</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HDEL key field [field …]</td>
<td>删除一个或多个Hash的field</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>判断field是否存在于hash中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取hash中field的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>从hash中读取全部的域和值</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>将hash中指定域的值增加给定的数字</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment</td>
<td>将hash中指定域的值增加给定的浮点数</td>
</tr>
<tr>
<td>HKEYS key</td>
<td>获取hash的所有字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取hash里所有字段的数量</td>
</tr>
<tr>
<td>HMGET key field [field …]</td>
<td>获取hash里面指定字段的值</td>
</tr>
<tr>
<td>HMSET key field value [field value …]</td>
<td>设置hash字段值</td>
</tr>
<tr>
<td>HSET key field value</td>
<td>设置hash里面一个字段的值</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>设置hash的一个字段，只有当这个字段不存在时有效</td>
</tr>
<tr>
<td>HSTRLEN key field</td>
<td>获取hash里面指定field的长度</td>
</tr>
<tr>
<td>HVALS key</td>
<td>获得hash的所有值</td>
</tr>
<tr>
<td>HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代hash里面的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>sets</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD key member [member …]</td>
<td>添加一个或者多个元素到集合(set)里</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取集合里面的元素数量</td>
</tr>
<tr>
<td>SDIFF key [key …]</td>
<td>获得队列不存在的元素</td>
</tr>
<tr>
<td>SDIFFSTORE destination key [key …]</td>
<td>获得队列不存在的元素，并存储在一个关键的结果集</td>
</tr>
<tr>
<td>SINTER key [key …]</td>
<td>获得两个集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key [key …]</td>
<td>获得两个集合的交集，并存储在一个关键的结果集</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>确定一个给定的值是一个集合的成员</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>获取集合里面的所有元素</td>
</tr>
<tr>
<td>SMOVE source destination member</td>
<td>移动集合里面的一个元素到另一个集合</td>
</tr>
<tr>
<td>SPOP key [count]</td>
<td>删除并获取一个集合里面的元素</td>
</tr>
<tr>
<td>SRANDMEMBER key [count]</td>
<td>从集合里面随机获取一个元素</td>
</tr>
<tr>
<td>SREM key member [member …]</td>
<td>从集合里删除一个或多个元素</td>
</tr>
<tr>
<td>SUNION key [key …]</td>
<td>添加多个set元素</td>
</tr>
<tr>
<td>SUNIONSTORE destination key [key …]</td>
<td>合并set元素，并将结果存入新的set里面</td>
</tr>
<tr>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代set里面的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>zset</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD key [NX</td>
<td>XX] [CH] [INCR] score member [score member …]</td>
<td>添加到有序set的一个或多个成员，或更新的分数，如果它已经存在</td>
</tr>
<tr>
<td>ZCARD key</td>
<td>获取一个排序的集合中的成员数量</td>
</tr>
<tr>
<td>ZCOUNT key min max</td>
<td>返回分数范围内的成员数量</td>
</tr>
<tr>
<td>ZINCRBY key increment member</td>
<td>增量的一名成员在排序设置的评分</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM、MIN、MAX]</td>
<td>相交多个排序集，导致排序的设置存储在一个新的关键</td>
</tr>
<tr>
<td>ZLEXCOUNT key min max</td>
<td>返回成员之间的成员数量</td>
</tr>
<tr>
<td>ZPOPMAX key [count]</td>
<td>Remove and return members with the highest scores in a sorted set</td>
</tr>
<tr>
<td>ZPOPMIN key [count]</td>
<td>Remove and return members with the lowest scores in a sorted set</td>
</tr>
<tr>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>根据指定的index返回，返回sorted set的成员列表</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</td>
</tr>
<tr>
<td>ZREVRANGEBYLEX key max min [LIMIT offset count]</td>
<td>返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td>
<td>返回有序集合中指定分数区间内的成员，分数由低到高排序。</td>
</tr>
<tr>
<td>ZRANK key member</td>
<td>确定在排序集合成员的索引</td>
</tr>
<tr>
<td>ZREM key member [member …]</td>
<td>从排序的集合中删除一个或多个成员</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX key min max</td>
<td>删除名称按字典由低到高排序成员之间所有成员。</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK key start stop</td>
<td>在排序设置的所有成员在给定的索引中删除</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE key min max</td>
<td>删除一个排序的设置在给定的分数所有成员</td>
</tr>
<tr>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>在排序的设置返回的成员范围，通过索引，下令从分数高到低</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</td>
<td>返回有序集合中指定分数区间内的成员，分数由高到低排序。</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>确定指数在排序集的成员，下令从分数高到低</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取成员在排序设置相关的比分</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM、MIN、MAX]</td>
<td>添加多个排序集和导致排序的设置存储在一个新的关键</td>
</tr>
<tr>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代sorted sets里面的元素</td>
</tr>
</tbody>
</table>
<p>除了以上5种命令外,还有Cluster、Connection、Geo、HyperLogLog、Keys、Pub/Sub、Scripting、Server、Streams、Transactions等命令,具体参考<a href="https://redis.io/commands">https://redis.io/commands</a>.</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy爬取1024种子</title>
    <url>/2019/02/17/scrapy%E7%88%AC%E5%8F%961024%E7%A7%8D%E5%AD%90/</url>
    <content><![CDATA[<p>1024不必多说,老司机都懂,本文介绍scrapy爬取1024种子,代码不到50行!<em>Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。</em> 关于scrapy用下图来说明即可(图片来自<a href="https://cuiqingcai.com/3472.html">https://cuiqingcai.com/3472.html</a>  )</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB66810b6bcef1257b8ef71ff9bbbfe9b6?method=download&amp;shareKey=d2785fa786b89417a34819ad7c832bf6" alt="https://note.youdao.com/yws/api/personal/file/WEB66810b6bcef1257b8ef71ff9bbbfe9b6?method=download&amp;shareKey=d2785fa786b89417a34819ad7c832bf6"></p>
<p>scrapy最好的方式通过<a href="https://docs.scrapy.org/en/latest/">官方文档</a>,以及社区贡献的<a href="https://scrapy-chs.readthedocs.io/zh_CN/latest/">中文文档</a>去学习,使用起来也非常简单,当然功能非常强大!<br>首先创建scrapy项目、CaoliuSpider,下面是创建的爬虫代码:</p>
<pre><code># -*- coding: utf-8 -*-
import scrapy
import json
from LiosScrapy.items import CaoLiuItem
from scrapy.http.request import Request
import sys

class CaoliuSpider(scrapy.Spider):
    # 爬虫名称
    name = &#39;caoliu&#39;
    # 涉及到敏感网站地址
    allowed_domains = [&#39;网站地址&#39;]
    start_urls = [&#39;请求地址&#39;]
    # 列表解析
    def parse(self, response):
        # 通过xpath提取
        node_list = response.xpath(&quot;//td[@class=&#39;tal&#39;]&quot;)
        next_page = response.xpath(&quot;//a[text()=&#39;下一頁&#39;]/@href&quot;).extract()[0]
        # 遍历列表获取种子名称、详情页URL
        for node in node_list:
            if not len(node.xpath(&#39;./h3/a/text()&#39;).extract()) or not len(node.xpath(&#39;./h3/a/@href&#39;).extract()):
                continue
            fileName = node.xpath(&#39;./h3/a/text()&#39;).extract()[0]
            listUrl = node.xpath(&#39;./h3/a/@href&#39;).extract()[0]
            # 通过Request meta传递参数
            yield scrapy.Request(self.allowed_domains[0] + &quot;/&quot; + listUrl, callback=self.parseDetail, meta=&#123;&#39;fileName&#39;: fileName&#125;, dont_filter=True)
        if next_page not in self.allowed_domains[0]:
            yield scrapy.Request(self.allowed_domains[0] + &quot;/&quot; + next_page,callback=self.parse,dont_filter=True)

    # 解析详情页
    def parseDetail(self, response):
        fileName = response.meta[&#39;fileName&#39;]
        node_list = response.xpath(
            &#39;//a[@style=&quot;cursor:pointer;color:#008000;&quot;]&#39;)
        for node in node_list:
            yield scrapy.Request(node.xpath(&#39;./@href&#39;).extract()[0], callback=self.parseDownLoanUrl, meta=&#123;&#39;fileName&#39;: fileName&#125;, dont_filter=True)
            # 默认获取第一条种子下载地址
            break

    # 拼接种子、下载
    def parseDownLoanUrl(self, response):
        fileName = response.meta[&#39;fileName&#39;]
        refNode = response.xpath(&quot;//input[@type=&#39;hidden&#39; and @name=&#39;ref&#39;]/@value&quot;)[0].extract()
        reffNode = response.xpath(&quot;//input[@type=&#39;hidden&#39; and @name=&#39;reff&#39;]/@value&quot;)[0].extract()
        torrentUrl = &quot;http://www.rmdown.com/download.php?&quot; + &quot;ref=&quot;+str(refNode)+ &quot;&amp;reff=&quot;+str(reffNode)
        item = CaoLiuItem()
        item[&#39;file_urls&#39;] = torrentUrl
        item[&#39;file_name&#39;] = fileName+&quot;.torrent&quot;
        yield item
</code></pre><p>Item文件中的代码:</p>
<pre><code>class CaoLiuItem(scrapy.Item):
    # 文件名称
    file_name = scrapy.Field()
    # 指定文件下载的连接
    file_urls = scrapy.Field()
    #文件下载完成后会往里面写相关的信息
    files = scrapy.Field()
</code></pre><p>管道文件中的代码:</p>
<pre><code># 继承FilesPipeline,用于下载文件
class CaoLiuPipeline(FilesPipeline):
    def get_media_requests(self, item, info):
        file_url = item[&#39;file_urls&#39;]
        meta = &#123;&#39;filename&#39;: item[&#39;file_name&#39;]&#125;
        # 交给调度器发送请求
        yield Request(url=file_url, meta=meta)
    # 自定义下载文件的名称    
    def file_path(self, request, response=None, info=None):
        return request.meta.get(&#39;filename&#39;,&#39;&#39;)
</code></pre><p>记得再settings文件中添加管道、以及设置文件存储路径:</p>
<pre><code>ITEM_PIPELINES = &#123;
   # &#39;LiosScrapy.pipelines.LiosscrapyPipeline&#39;: 300,
   &#39;LiosScrapy.pipelines.CaoLiuPipeline&#39;: 2
&#125;
FILES_STORE = &#39;/Users/wenchao.wang/LiosWang/sublimetext/LiosScrapy/data/caoliu&#39;
</code></pre><p>然后执行命令:</p>
<pre><code>scrapy crawl caoliu
</code></pre><p>终端输出:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB99a50db27fab136be8085afc6fb1bdc8?method=download&amp;shareKey=cdf5c51f1ae1ac0d9bb56d97e3b5d6af" alt="https://note.youdao.com/yws/api/personal/file/WEB99a50db27fab136be8085afc6fb1bdc8?method=download&amp;shareKey=cdf5c51f1ae1ac0d9bb56d97e3b5d6af"><br>打开存储文件夹,发现种子源源不断下载:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBd6850c267e5c6705108f107032b9fddb?method=download&amp;shareKey=4b49e98d7022de6ee647ec613d29551b" alt="https://note.youdao.com/yws/api/personal/file/WEBd6850c267e5c6705108f107032b9fddb?method=download&amp;shareKey=4b49e98d7022de6ee647ec613d29551b"><br>scrapy的功能非常强大,以上运用其简单爬取网页信息,<strong>作者</strong>只用于学习.最后欢迎感兴趣的朋友欢迎一起讨论学习scrapy.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mybatis拦截器分表实现</title>
    <url>/2019/02/16/%E5%9F%BA%E4%BA%8Emybatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%88%86%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>mybatis提供了拦截器插件用来处理被拦截的方法的某些逻辑.下面会通过创建8张表,当用户注册时,根据对手机号取余数数据入不同的库.</p>
<h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEBfa5f294403e547b8de8f75ed5754a294?method=download&amp;shareKey=fdf0fdffda7b82a83c763977e2420bad" alt="https://note.youdao.com/yws/api/personal/file/WEBfa5f294403e547b8de8f75ed5754a294?method=download&amp;shareKey=fdf0fdffda7b82a83c763977e2420bad"></p>
<h4 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h4><pre><code>&lt;property name=&quot;plugins&quot;&gt;
    &lt;array&gt;
        &lt;bean id=&quot;sharingInterceptor&quot; class=&quot;com.lios.base.sharetable.SharingInterceptor&quot;/&gt;
    &lt;/array&gt;
&lt;/property&gt;
</code></pre><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>具体代码:</p>
<pre><code>/**
 * @author LiosWong
 * @description
 * @date 2018/7/31 下午7:05
 */
@Intercepts(@Signature(type = StatementHandler.class,method = &quot;prepare&quot;,args = &#123;Connection.class,Integer.class&#125;))
public class SharingInterceptor implements Interceptor&#123;
    Logger logger = LoggerFactory.getLogger(SharingInterceptor.class);
    @Override
    public Object intercept(Invocation invocation) throws Throwable &#123;
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        ReflectorFactory reflectorFactory = new DefaultReflectorFactory();
        MetaObject metaObject = MetaObject.forObject(statementHandler,SystemMetaObject.DEFAULT_OBJECT_FACTORY,SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,reflectorFactory);
        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(&quot;delegate.mappedStatement&quot;);
        String id = mappedStatement.getId();
        id = id.substring(0,id.lastIndexOf(&quot;.&quot;));
        Class cls = Class.forName(id);
        SegmentTable segmentTable = (SegmentTable) cls.getAnnotation(SegmentTable.class);
        if(segmentTable!=null)&#123;
            String sql = (String) metaObject.getValue(&quot;delegate.boundSql.sql&quot;);
            BoundSql boundSql = statementHandler.getBoundSql();
            String tableKey = StrategyFactory.createShareStrategy(segmentTable.shareType()).setSegmentTable(segmentTable).setBoundSql(boundSql).getRouteValue();
            metaObject.setValue(&quot;delegate.boundSql.sql&quot;,sql.replaceFirst(segmentTable.tableName(),segmentTable.tableName()+tableKey));
        &#125;
        return invocation.proceed();
    &#125;
    @Override
    public Object plugin(Object target) &#123;
        if(target instanceof StatementHandler)&#123;
            return Plugin.wrap(target,this);
        &#125;
        return target;
    &#125;
    @Override
    public void setProperties(Properties properties) &#123;

    &#125;
&#125;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface SegmentTable &#123;
    /**
     * 表名称
     * @return
     */
    String tableName()  default &quot;&quot;;


    /**
     * 分表策略
     * @return
     */
    ShareType shareType() default ShareType.MOD;


    /**
     * 分表数量
     * @return
     */
    int tableNum() default 0;

    /**
     * 分表数量
     * @return
     */
    String shareBy() default &quot;&quot;;
&#125;
@Repository
@DataSource(value = DynamicDataSourceGlobal.LOCAL)
@SegmentTable(tableName = &quot;user&quot;,shareType = ShareType.MOD,tableNum = 8,shareBy = &quot;mobile&quot;)
public class UserInfoDaoImpl extends AbstractBaseMapper&lt;UserInfoEntity&gt; implements UserInfoDao&#123;
    @Override
    public UserInfoEntity selectById(Long id) &#123;
        return this.getSqlSession().selectOne(this.getStatement(&quot;.selectById&quot;),id);
    &#125;
    @Override
    public UserInfoEntity selectByMobile(String mobile) &#123;
        return this.getSqlSession().selectOne(this.getStatement(&quot;.selectByMobile&quot;),mobile);
    &#125;
    @Override
    public UserInfoEntity insert(UserInfoEntity userInfoEntity)&#123;
        this.getSqlSession().insert(this.getStatement(&quot;.insert&quot;),userInfoEntity);
        return null;
    &#125;
&#125;
</code></pre><p>StrategyFactory根据不同分表策略处理相应的逻辑,拦截器里主要思路就是拦截需要处理的方法,然后对拦截参数、拦截结果集处理,然后重新构建sql语句并执行.</p>
<h4 id="数据录入"><a href="#数据录入" class="headerlink" title="数据录入"></a>数据录入</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4410d0e711f9f67487e43c97e7ac3d15?method=download&amp;shareKey=e8ad78d0c2b9049391037b13738a955e" alt="https://note.youdao.com/yws/api/personal/file/WEB4410d0e711f9f67487e43c97e7ac3d15?method=download&amp;shareKey=e8ad78d0c2b9049391037b13738a955e"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义参数解析器</title>
    <url>/2019/02/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>开发中，app端给服务端会传基础参数、其他参数，一般基础参数app端都会传给服务端，其他参数则是根据不同接口传不同参数。若以表单的形式提交的数据:<br><img src="https://mmbiz.qpic.cn/mmbiz_png/AFibVNx7tNjI6iah1lcv3setn2hk2lMqXvc51mOk17TsibZbic5RfE00xXIllUTZp3r3UoyCJTmm6RjGo5m6CibjCdQ/0?wx_fmt=png" alt="https://mmbiz.qpic.cn/mmbiz_png/AFibVNx7tNjI6iah1lcv3setn2hk2lMqXvc51mOk17TsibZbic5RfE00xXIllUTZp3r3UoyCJTmm6RjGo5m6CibjCdQ/0?wx_fmt=png"><br>其中请求参数params就是上文所说的其他参数，而除了它都是基本参数，param的值是json字符串，对于这种请求方式用@RequestParam、@RequestBody都不能满足要求，用spring中自定义的参数解析器恰好可以解决这个问题。</p>
<h4 id="首先定义映射参数的类"><a href="#首先定义映射参数的类" class="headerlink" title="首先定义映射参数的类"></a>首先定义映射参数的类</h4><p>UserParam:</p>
<pre><code>public class UserParam extends BaseParam&#123;
    private UserInfoEntity params;//其他参数映射类

    public UserInfoEntity getParams() &#123;
        return params;
    &#125;

    public void setParams(UserInfoEntity params) &#123;
        this.params = params;
    &#125;

    public void setParamsFromJson(String json)&#123;
        UserInfoEntity userInfoEntity = null;
        try &#123;
            userInfoEntity = JSONUtils.json2pojo(json,UserInfoEntity.class);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        setParams(userInfoEntity);
    &#125;
&#125;

</code></pre><p>BaseParam(基础参数类):</p>
<pre><code>public class BaseParam &#123;
    public String token;
    public String channel;
    public String clientId;


    public String getToken() &#123;
        return token;
    &#125;

    public void setToken(String token) &#123;
        this.token = token;
    &#125;

    public String getChannel() &#123;
        return channel;
    &#125;

    public void setChannel(String channel) &#123;
        this.channel = channel;
    &#125;

    public String getClientId() &#123;
        return clientId;
    &#125;

    public void setClientId(String clientId) &#123;
        this.clientId = clientId;
    &#125;
&#125;

</code></pre><h4 id="Controller类方法"><a href="#Controller类方法" class="headerlink" title="Controller类方法"></a>Controller类方法</h4><pre><code>@RestController
public class HelloController &#123;
    @Autowired
    UserInfoService userInfoService;
    @PostMapping(value = &quot;/lios/boot/ok&quot;,produces = &#123;&quot;application/json;charset=utf-8&quot;&#125;)
    public Object ok(UserParam param)&#123;
        return userInfoService.selectByMobile(param.getParams().getMobile());
    &#125;
&#125;
</code></pre><h4 id="自定义参数解析器类"><a href="#自定义参数解析器类" class="headerlink" title="自定义参数解析器类"></a>自定义参数解析器类</h4><pre><code>public class CustomArgumentResolver implements HandlerMethodArgumentResolver &#123;

    @Override
    public boolean supportsParameter(MethodParameter methodParameter) &#123;
        Class paramObjClass = methodParameter.getParameterType();
        if(BaseParam.class.isAssignableFrom(paramObjClass))&#123;
            return true; //参数为BaseParam.class类类型时,则执行resolveArgument方法
        &#125;
        return false;
    &#125;
    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;

        Class paramObjClass = parameter.getParameterType();//获取参数类类型

        Object paramObj = paramObjClass.newInstance();//根据class new 出对象

        Map&lt;String, String[]&gt; param = webRequest.getParameterMap();//获取所有请求参数
        for (Map.Entry&lt;String, String[]&gt; entry : param.entrySet()) &#123;
            String[] val = entry.getValue();
            if (val != null &amp;&amp; &quot;params&quot;.equals(entry.getKey())) &#123;
                Method method = paramObjClass.getMethod(&quot;setParamsFromJson&quot;, String.class);//获取到方法setParamsFromJson的对象
                method.invoke(paramObj, val[0]);//把params的值当作形参传入
            &#125; else if (val != null &amp;&amp; val.length == 1) &#123; //基础类参数处理
                Field field =null;
                if(paramObjClass.getName().equals(BaseParam.class.getName()))&#123;
                    field=paramObjClass.getDeclaredField(entry.getKey());
                &#125;else &#123;
                    field= paramObjClass.getSuperclass().getDeclaredField(entry.getKey());
                &#125;
                //把基础参数的值放入UserParam中
                if (field.getType().isAssignableFrom(String.class)) &#123;
                    field.set(paramObj, val[0]);
                &#125; else if (field.getType().isAssignableFrom(Integer.class)) &#123;
                    field.set(paramObj, Integer.valueOf(val[0]));
                &#125; else if (field.getType().isAssignableFrom(Long.class)) &#123;
                    field.set(paramObj, Long.valueOf(val[0]));
                &#125; 
            &#125;
        &#125;
        return paramObj;
    &#125;
&#125;

</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li><p>一般项目配置</p>
<pre><code>        &lt;mvc:annotation-driven&gt;
          &lt;mvc:argument-resolvers&gt;
              &lt;bean class=&quot;com.lios.api.resolver.CustomArgumentResolver&quot;/&gt;
          &lt;/mvc:argument-resolvers&gt;
      &lt;/mvc:annotation-driven&gt;
</code></pre><ul>
<li><p>springboot项目中配置</p>
<pre><code>@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@ImportResource(&#123;&quot;classpath*:dispatcher-servlet.xml&quot;&#125;)
public class LiosBootApplication extends WebMvcConfigurerAdapter &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(LiosBootApplication.class, args);
    &#125;
    @Override
    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123;
        super.addArgumentResolvers(argumentResolvers);
        argumentResolvers.add(new CustomArgumentResolver());
    &#125;
&#125;

</code></pre></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC启动加载、请求分析</title>
    <url>/2019/02/16/SpringMVC%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E3%80%81%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>springmvc项目会在web.xml文件中配置servlet:</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre><p>下面看下DispatcherServlet的继承关系:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBcbda6aa3e25fb29b50796b036cc5ebcf?method=download&amp;shareKey=2cfc5655b93a037fea8311c54e4c6416" alt="https://note.youdao.com/yws/api/personal/file/WEBcbda6aa3e25fb29b50796b036cc5ebcf?method=download&amp;shareKey=2cfc5655b93a037fea8311c54e4c6416"><br>DispatcherServlet其实是一个Servlet,用于初始化各个功能的实现类,比如异常处理、视图处理、请求映射等;且继承了FrameworkServlet类,FrameworkServlet是Spring的基础Servlet,提供集成一个基于JavaBean的整体解决方案的Spring上下文;FrameworkServlet又继承了HttpServletBean,HttpServletBean主要做一些初始化的工作,如将web.xml中的配置参数设置到Servlet中.<br>再直观感受下DispatcherServlet上下文层次结构关系:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBa8f04859417bba9bd52131d2567d6b73?method=download&amp;shareKey=c1c6ee425df9c89566c24d3546acacb7" alt="https://note.youdao.com/yws/api/personal/file/WEBa8f04859417bba9bd52131d2567d6b73?method=download&amp;shareKey=c1c6ee425df9c89566c24d3546acacb7"><br>该图有助于下面分析启动、请求的分析理解,图片来自<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc</a></p>
<h4 id="启动源码分析"><a href="#启动源码分析" class="headerlink" title="启动源码分析"></a>启动源码分析</h4><p>由于DispatcherServlet是一个Servlet,启动时初始化首先调用init方法,进入其父类的<code>org.springframework.web.servlet.HttpServletBean#init</code>方法中:</p>
<pre><code>PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
</code></pre><p>获取了配置文件dispatcher-servlet.xml,跟进<code>initServletBean()</code>方法,此处用了委派方式,具体实现交给子类FrameworkServlet去实现,主要看方法里这段代码:</p>
<pre><code>this.webApplicationContext = initWebApplicationContext();
initFrameworkServlet();
</code></pre><p>跟进第一段代码,由于第一次启动,wac为nul,再进入初始化方法代码,<code>org.springframework.web.servlet.FrameworkServlet#createWebApplicationContext(org.springframework.web.context.WebApplicationContext)</code>,再进入<code>org.springframework.web.servlet.FrameworkServlet#createWebApplicationContext(org.springframework.context.ApplicationContext)</code>方法:</p>
<pre><code>Class&lt;?&gt; contextClass = getContextClass();
if (this.logger.isDebugEnabled()) &#123;
    this.logger.debug(&quot;Servlet with name &#39;&quot; + getServletName() +
            &quot;&#39; will try to create custom WebApplicationContext context of class &#39;&quot; +
            contextClass.getName() + &quot;&#39;&quot; + &quot;, using parent context [&quot; + parent + &quot;]&quot;);
&#125;
if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;
    throw new ApplicationContextException(
            &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() +
            &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() +
            &quot;] is not of type ConfigurableWebApplicationContext&quot;);
&#125;
ConfigurableWebApplicationContext wac =
        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
wac.setEnvironment(getEnvironment());
wac.setParent(parent);
wac.setConfigLocation(getContextConfigLocation());
configureAndRefreshWebApplicationContext(wac);
</code></pre><p>上面主要创建了ConfigurableWebApplicationContext对象,然后调用了configureAndRefreshWebApplicationContext方法用来做初始化工作,再进入到<code>org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext</code>方法:</p>
<pre><code>if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;
    // The application context id is still set to its original default value
    // -&gt; assign a more useful id based on available information
    if (this.contextId != null) &#123;
        wac.setId(this.contextId);
    &#125;
    else &#123;
        // Generate default id...
        wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
                ObjectUtils.getDisplayString(getServletContext().getContextPath()) + &quot;/&quot; + getServletName());
    &#125;
&#125;
wac.setServletContext(getServletContext());
wac.setServletConfig(getServletConfig());
wac.setNamespace(getNamespace());
wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));
// The wac environment&#39;s #initPropertySources will be called in any case when the context
// is refreshed; do it eagerly here to ensure servlet property sources are in place for
// use in any post-processing or initialization that occurs below prior to #refresh
ConfigurableEnvironment env = wac.getEnvironment();
if (env instanceof ConfigurableWebEnvironment) &#123;
    ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());
&#125;
postProcessWebApplicationContext(wac);
applyInitializers(wac);
wac.refresh();
</code></pre><p>最后一句<code>wac.refresh()</code>代码,跟进去发现调用的是<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>的方法,ConfigurableWebApplicationContext没有重写refresh方法,所以调用了父类的默认实现方法,进入这个方法,正是spring解析配置文件、加载bean的方法,这里不作分析,具体可参考之前的文章.</p>
<h4 id="请求分析"><a href="#请求分析" class="headerlink" title="请求分析"></a>请求分析</h4><p>服务起来后,在浏览器中输入<code>http://localhost:8082/ok</code>,由于FrameworkServlet重写了Servlet的service方法,无疑会进入到该方法中:</p>
<pre><code>protected void service(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException &#123;

if (HttpMethod.PATCH.matches(request.getMethod())) &#123;
    processRequest(request, response);
&#125;
else &#123;
    super.service(request, response);
&#125;
&#125;
</code></pre><p>该方法会判断请求的方式,无论哪种都会调用processRequest方法,进入该方法会看到这么一段代码:</p>
<pre><code>doService(request, response);
</code></pre><p>直觉告诉我们,这个方法就是用来处理请求的,再跟进去,调用的是子类DispatcherServlet中的doService方法,该方法开始会设置请求头信息,下面有这么一段代码:</p>
<pre><code>doDispatch(request, response);
</code></pre><p>同上,直接跟进去,摘取部分代码:</p>
<pre><code>ModelAndView mv = null;
Exception dispatchException = null;
// Determine handler for the current request.
//获取MappedHandler
mappedHandler = getHandler(processedRequest);
// Determine handler adapter for the current request.
//获取HandlerAdapter
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
// Process last-modified header, if supported by the handler.
// Actually invoke the handler.
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
mappedHandler.applyPostHandle(processedRequest, response, mv);
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
</code></pre><p>进入HandlerAdapter的处理方法,<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>,发现这么一段代码:</p>
<pre><code>invocableMethod.invokeAndHandle(webRequest, mavContainer);
</code></pre><p>进入<code>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</code>:</p>
<pre><code>//根据HandlerMapping中请求路径使用反射调用Controller中的求方法
Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
setResponseStatus(webRequest);
if (returnValue == null) &#123;
    if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) &#123;
        mavContainer.setRequestHandled(true);
        return;
    &#125;
&#125;
else if (StringUtils.hasText(this.responseReason)) &#123;
    mavContainer.setRequestHandled(true);
    return;
&#125;
mavContainer.setRequestHandled(false);
try &#123;
    //处理返回结果
    this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
&#125;
catch (Exception ex) &#123;
    if (logger.isTraceEnabled()) &#123;
        logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
    &#125;
    throw ex;
&#125;
</code></pre><p>进入到<code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code>方法:</p>
<pre><code>// 
Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) &#123;
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
&#125;
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) &#123;
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
&#125;
return returnValue;
</code></pre><p>getMethodArgumentValues方法用于获取请求时所带的参数,doInvoke方法使用反射调用Controller中的方法,所以当断点执行到该方法中时,会调用OkController类中的ok方法,returnValue是ok方法的返回值,此时请求已经完成,下面再看响应.再回到<code>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</code>中,<code>this.returnValueHandlers.handleReturnValue(returnValue,getReturnValueType(returnValue),mavContainer,webRequest)</code>方法用于处理响应,进入该方法<code>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue</code>:</p>
<pre><code>//根据returnValue、returnType获取不同的HandlerMethodReturnValueHandler
HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
Assert.notNull(handler, &quot;Unknown return value type [&quot; + returnType.getParameterType().getName() + &quot;]&quot;);
//handler有很多子类,会调用不同的实现类
handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
</code></pre><p>由于OkController中的ok方法返回的是一个对象,所以进入到的handler的子类是<code>org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor#handleReturnValue</code>:</p>
<pre><code>ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
    throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;
mavContainer.setRequestHandled(true);
// Try even with null return value. ResponseBodyAdvice could get involved.
writeWithMessageConverters(returnValue, returnType, webRequest);
</code></pre><p>继续跟进writeWithMessageConverters方法,继续跟进<code>org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters(T, org.springframework.core.MethodParameter, org.springframework.http.server.ServletServerHttpRequest, org.springframework.http.server.ServletServerHttpResponse)</code>方法,在该方法中会把响应写入到流中返回给客户端.<br>至此服务端的响应也简单的介绍完毕.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实际的流程远比笔者介绍的复杂的太多,感兴趣的朋友可以打断点调试去探索,其中涉及到很多知识点都没有去过多的分析,后面的文章笔者会涉及;笔者非常想从tomcat容器启动,到Servlet的加载,再到Spring中bean初始化,然后tomcat容器处理请求,分配给Servlet去处理,再到DispatcherServlet前端控制器分发、处理,整个过程,限于笔者目前水平,没有把整个串联起来,形成一条完整的调用链,希望有朋友可以分享.</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>并行执行任务思考</title>
    <url>/2019/02/16/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这篇文章由之前的<a href="">并行执行任务</a>发展而来,如何生成task,在之前的文章中,生成task方式如下:</p>
<pre><code>Abstract Task: 
public abstract class BasicUserFilter implements Callable&lt;UserFilterDto&gt; &#123;
private static final Log logger = LogFactory.getLog(BasicUserFilter.class);
@Autowired
UserService userService;
public Long companyId;
public Long userId;
@Override
public UserFilterDto call() throws Exception &#123;
    try &#123;
        //每个执行任务调用同一个方法,只是入参不同
        Response&lt;Boolean&gt; response = userService.filter(getUserId(), getCompanyId());
        if (response.isSuccess() &amp;&amp; response.getResult()) &#123;
            return new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.TRUE);
        &#125;
    &#125; catch (Exception e) &#123;
        logger.error(e.getMessage(), e);
    &#125;
    return new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.FALSE);
&#125;
@PostConstruct
abstract void init();
// ... 篇幅关系,省略属性setter、getter方法
&#125;
&#125;

Task1:
public class Task1 extends BasicUserFilter&#123;
    @Override
    public void init() &#123;
        FilterConfigManager.register(CompanyAppIdEnum.GEI_NI_HUA.getCompanyId(),this);
    &#125;
    @Override
    public UserFilterDto call() throws Exception &#123;
        return super.call();
    &#125;
&#125;
</code></pre><p>上面生成任务类时，使用了策略模式,添加每一个任务都必须新增一个实体类,且实现BasicUserFilter或者重写自己的<code>call</code>方法,有木有比较好的方法解决这种繁琐的任务类构建呢。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>解决切入点，就是所有的任务类都执行了相同的逻辑，且调用了入参不同的方法而已，无疑使用代理模式去动态生成任务类,思路有了，代码实现也边的简单起来。下面使用java InvocationHandler创建动态代理类.</p>
<pre><code>ProxyHandler：
/**
 * @author LiosWong
 * @description
 * @date 2018/10/27 上午1:10
 */
public class ProxyHandler&lt;T&gt; implements InvocationHandler, Serializable &#123;
    private static final long serialVersionUID = -6424540398559729838L;
    private final ProxyInterface&lt;T&gt; proxyInterface;

    public ProxyHandler(ProxyInterface&lt;T&gt; proxyInterface) &#123;
        this.proxyInterface = proxyInterface;
    &#125;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        // 根据方法名,执行不同逻辑
        if (&quot;call&quot;.equals(method.getName())) &#123;
            return proxyInterface.call();
        &#125;
        return null;
    &#125;
&#125;
ProxyInterface：为了使代理模版通用,添加接口约束
/** 
 * @author LiosWong
 * @description 可扩展代理接入点
 * @date 2018/10/27 上午1:11
 */
public interface ProxyInterface&lt;T&gt; extends Callable&lt;T&gt; &#123;

&#125;
ProxyFactory：代理工厂
public class ProxyFactory&lt;T&gt; &#123;
private final Class&lt;T&gt; mapperInterface;

public ProxyFactory(Class&lt;T&gt; mapperInterface) &#123;
    this.mapperInterface = mapperInterface;
&#125;
public Class&lt;T&gt; getMapperInterface() &#123;
    return mapperInterface;
&#125;
@SuppressWarnings(&quot;unchecked&quot;)
protected T newInstance(ProxyHandler&lt;T&gt; mapperProxy) &#123;
    return (T) java.lang.reflect.Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]&#123;mapperInterface&#125;, mapperProxy);
&#125;
public T newInstance(ProxyInterface proxyInterface) &#123;
    final ProxyHandler&lt;T&gt; mapperProxy = new ProxyHandler&lt;T&gt;(proxyInterface);
    return newInstance(mapperProxy);
&#125;
&#125;
</code></pre><p>完成了上面的动态代理类构建，下面就是在业务代码中使用:</p>
<pre><code> ProxyFactory proxyFactory = new ProxyFactory&lt;Callable&gt;(Callable.class);
        List&lt;Callable&lt;UserFilterDto&gt;&gt; callableList = new ArrayList&lt;&gt;();
        List&lt;UserFilterDto&gt; filterDtosResult = new ArrayList&lt;&gt;();
        // 动态生成代理类
        list.forEach(p -&gt; &#123;
            Callable&lt;UserFilterDto&gt; callable = null;
            // 复用代理模版
            switch (concurrencyType) &#123;
                case FILTER:
                    callable = (Callable&lt;UserFilterDto&gt;) proxyFactory.newInstance(new ProxyFilterCallable(xjUserService, userId, p.getCompanyId()));
                    break;
                case SATISFY:
                    callable = (Callable&lt;UserFilterDto&gt;) proxyFactory.newInstance(new ProxySatisfyCallable(companyUserGroupService, userId, p.getCompanyId()));
                    break;
                default:
                    break;
            &#125;
            callableList.add(callable);
        &#125;);
</code></pre><p>ProxyFilterCallable:</p>
<pre><code>public class ProxyFilterCallable&lt;T&gt; implements ProxyInterface&lt;T&gt; &#123;
    private static final Log logger = LogFactory.getLog(ProxyFilterCallable.class);
    private UserService userService;
    private Long userId;
    private Long companyId;

    public ProxyFilterCallable(XjUserService xjUserService, Long userId, Long companyId) &#123;
        this.xjUserService = xjUserService;
        this.userId = userId;
        this.companyId = companyId;
    &#125;
    @Override
    public T call() throws Exception &#123;
        try &#123;
            Response&lt;Boolean&gt; response = userService.filter(getUserId(), getCompanyId());
            if (response.isSuccess() &amp;&amp; response.getResult()) &#123;
                return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.TRUE);
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage(), e);
        &#125;
        return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.FALSE);
    &#125;
    // ...
&#125;
</code></pre><p>ProxySatisfyCallable：</p>
<pre><code>public class ProxySatisfyCallable&lt;T&gt; implements ProxyInterface&lt;T&gt; &#123;
    private static final Log logger = LogFactory.getLog(ProxyFilterCallable.class);
    private CompanyUserGroupService companyUserGroupService;
    private Long userId;
    private Long companyId;

    public ProxySatisfyCallable(CompanyUserGroupService companyUserGroupService, Long userId, Long companyId) &#123;
        this.companyUserGroupService = companyUserGroupService;
        this.userId = userId;
        this.companyId = companyId;
    &#125;

    @Override
    public T call() throws Exception &#123;
        try &#123;
            XjFilterUserResultVo xjFilterUserResultVo = companyUserGroupService.checkUserInfoIsSatisfyCompany(getUserId(), getCompanyId());
            if (Objects.nonNull(xjFilterUserResultVo) &amp;&amp; xjFilterUserResultVo.getResult()) &#123;
                return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.TRUE);
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage(), e);
        &#125;
        return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.FALSE);
    &#125;
    // ...
&#125;

</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI概念及使用方法</title>
    <url>/2019/02/16/SPI%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SPI全称Service Provider Interfaces,用于发现接口的实现。在jdbc、日志、dubbo的设计中都使用SPI用于服务的发现。简单的以jdbc为例:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBbb7de4288a145ced6178308fe32d133b?method=download&amp;shareKey=228a0e1b38725147810291fd9e72ba5a" alt="https://note.youdao.com/yws/api/personal/file/WEBbb7de4288a145ced6178308fe32d133b?method=download&amp;shareKey=228a0e1b38725147810291fd9e72ba5a"><br>jdbc Driver实现了java.sql.Driver接口，实现具体的功能,也就是Java SQL framework定义了用于数据库连接接口规范,不同的数据库厂商要想使用Java连接数据库必须实现该接口才可以，当厂商实现后，如何使用呢？也就是上图中的在<code>META-INF/services/</code>下,配置以接口<code>java.sql.Driver</code>为名称的文件，文件里加上具体的实现<code>com.mysql.jdbc.Driver</code>即可,在程序中注册注册驱动即可使用,如在使用jdbc时:</p>
<pre><code>// Register JDBC driver
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
</code></pre><p>加载该jdbc驱动时,会执行静态块,并使用SPI机制在<code>java.sql.DriverManager</code>中加载<code>java.sql.Driver</code>的实现类:</p>
<pre><code>// Register ourselves with the DriverManager
static &#123;
    try &#123;
        java.sql.DriverManager.registerDriver(new Driver());
    &#125; catch (SQLException E) &#123;
        throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);
    &#125;
&#125;
static &#123;
    loadInitialDrivers();
    println(&quot;JDBC DriverManager initialized&quot;);
&#125;
private static void loadInitialDrivers() &#123;
    String drivers;
    try &#123;
        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;
            public String run() &#123;
                return System.getProperty(&quot;jdbc.drivers&quot;);
            &#125;
        &#125;);
    &#125; catch (Exception ex) &#123;
        drivers = null;
    &#125;
    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;
        public Void run() &#123;
            try&#123;
                while(driversIterator.hasNext()) &#123;
                    driversIterator.next();
                &#125;
            &#125; catch(Throwable t) &#123;
            // Do nothing
            &#125;
            return null;
        &#125;
    &#125;);

    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);
    ...
&#125;
</code></pre><h3 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h3><p>在项目中我们会对外提供接口,为了在controller内内减少接口数量,使用SPI机制去实现相应的功能。</p>
<h5 id="首先定义接口"><a href="#首先定义接口" class="headerlink" title="首先定义接口"></a>首先定义接口</h5><pre><code>/**
 * @author wenchao.wang
 * @description
 * @date 2018/1/20 下午10:53
 */
public interface BaseApplication &#123;
&#125;
</code></pre><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><pre><code>@Component
public class OpenOrderApplication implements BaseApplication &#123;

    @MethodMapping(&quot;com.lios.test1&quot;)
    public ApiResponse filter(OpenApiJsonObject openApiJsonObject, String appId) &#123;
        return null;
    &#125;
    @MethodMapping(&quot;com.lios.test2&quot;)
    @CheckField(value = CheckEnum.JSON_OBJECT)
    public ApiResponse&lt;DataVO&gt; orderPush(OpenApiJsonObject openApiJsonObject, String appId) &#123;
        return null;
    &#125;

    @MethodMapping(&quot;com.lios.test3&quot;)
    public ApiResponse&lt;DataVO&gt; orderfeedback(OpenApiJsonObject openApiJsonObject, String appId) &#123;
      return null;
    &#125;

&#125;
</code></pre><h5 id="使用SPI机制获取接口实现-并把注解值与方法绑定注册"><a href="#使用SPI机制获取接口实现-并把注解值与方法绑定注册" class="headerlink" title="使用SPI机制获取接口实现,并把注解值与方法绑定注册"></a>使用SPI机制获取接口实现,并把注解值与方法绑定注册</h5><pre><code>public class MappingFactory &#123;
private static ConcurrentHashMap&lt;String, MethodApplication&gt; methodMappings = new ConcurrentHashMap&lt;String, MethodApplication&gt;();
private volatile static boolean init = false;
private MappingFactory() &#123;
&#125;
private static void initHandlerMethod() &#123;
    ServiceLoader&lt;BaseApplication&gt; applications = ServiceLoader.load(BaseApplication.class);
    for (BaseApplication application : applications) &#123;
        Method[] methods = application.getClass().getDeclaredMethods();
        for (Method method : methods) &#123;
            MethodMapping methodMapping = method.getAnnotation(MethodMapping.class);
            if (methodMapping != null &amp;&amp; methodMapping.value() != null) &#123;

                String mapping = methodMapping.value();
                addMethodMapping(mapping, new MethodApplication(StringUtils.uncapitalize(application.getClass().getSimpleName()), method));
            &#125;
        &#125;
    &#125;
&#125;
private static void addMethodMapping(String mapping, MethodApplication methodApplication) &#123;
    methodMappings.put(mapping, methodApplication);
&#125;
public static MethodApplication getMethodMapping(String url) &#123;
    if (!init) &#123;
        initHandlerMethod();
        init = true;
    &#125;
    return methodMappings.get(url);
 &#125;
&#125;
</code></pre><h5 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h5><p>在META-INF/services中添加文件com.lios.base.application.BaseApplication,写入:</p>
<pre><code>com.lios.api.application.OpenApplication
</code></pre><h5 id="controller中调用"><a href="#controller中调用" class="headerlink" title="controller中调用"></a>controller中调用</h5><pre><code>@RestController
public class OpenController &#123;
    private static final Logger LOGGER = LoggerFactory.getLogger(OpenController.class);
    @Autowired
    private Map&lt;String, BaseApplication&gt; baseApplications;
    @RequestMapping(value = &quot;/open/gateway/&#123;method:.+&#125;&quot;, method = RequestMethod.POST)
    @ResponseBody
    public OpenApiResponse dispatcher(@PathVariable String method, @RequestBody OpenApiJsonObject openApiJsonObject) &#123;
        ...
        MethodApplication methodApplication = MappingFactory.getMethodMapping(method);
        if (methodApplication != null &amp;&amp; baseApplications.get(methodApplication.getApplicationName()) != null) &#123;
            try &#123;
                return (OpenApiResponse) methodApplication.getMethod().invoke(baseApplications.get(methodApplication.getApplicationName()), openApiJsonObject, appId);
            &#125; catch (Exception e) &#123;
               LOGGER.error(e.getMessage(), e);
            &#125;
        &#125;
        ...
    &#125;
&#125;
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT</title>
    <url>/2019/02/16/JWT/</url>
    <content><![CDATA[<p><img src="https://note.youdao.com/yws/api/personal/file/WEBff086a9673fbfd80034914abfb78b656?method=download&amp;shareKey=58577f840ca558fcb3d378123e53640d" alt="https://note.youdao.com/yws/api/personal/file/WEBff086a9673fbfd80034914abfb78b656?method=download&amp;shareKey=58577f840ca558fcb3d378123e53640d"><br>上图文字来自<a href="https://jwt.io/introduction/">https://jwt.io/introduction/</a><br>现项目中的JWT来解析如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEBffd386ebffa4fa1b2aafc2ec086f332f?method=download&amp;shareKey=9bc3aea3ffb8508f2093bf7d862a9513" alt="https://note.youdao.com/yws/api/personal/file/WEBffd386ebffa4fa1b2aafc2ec086f332f?method=download&amp;shareKey=9bc3aea3ffb8508f2093bf7d862a9513"><br>左边是生成的token,左边是其三部分的解析。<br>项目中的使用,</p>
<pre><code>public class JWTSignerUtil &#123;
    private static final String JWT_SECRET = &quot;密钥字符串&quot;;
    private static JWTSigner signer = new JWTSigner(JWT_SECRET);
    /**
    ** 生成JWT
    **/
    public static String shouldSignStringOrURICollection(String uri, String userId) throws Exception &#123;
        LinkedList&lt;String&gt; aud = new LinkedList&lt;String&gt;();
        aud.add(uri);
        aud.add(System.currentTimeMillis() + &quot;&quot;);
        aud.add(userId);
        HashMap&lt;String, Object&gt; claims = new HashMap&lt;String, Object&gt;();
        claims.put(&quot;aud&quot;, aud);
        return signer.sign(claims);
    &#125;
   /**
    ** 解析
    **/
    public static List verify(String token)&#123;
        Map&lt;String, Object&gt; decodedPayload;
        try &#123;
            decodedPayload = new JWTVerifier(JWT_SECRET).verify(token);
            List&lt;String&gt; list = (List&lt;String&gt;) decodedPayload.get(&quot;aud&quot;);
            return list;
        &#125; catch (Exception e) &#123;
            return null;
        &#125;
    &#125;

    public static void main(String[] args) throws Exception &#123;
        String token = JWTSignerUtil.shouldSignStringOrURICollection(
                &quot;/user/login&quot;,&quot;304914&quot;);
        System.out.println(token);
        List tokenList = JWTSignerUtil.verify(token);
        Long userId = Long.parseLong(tokenList.get(2) + &quot;&quot;);
        System.out.println(userId);
    &#125;
&#125;
</code></pre><p>交互流程如下：<br><img src="https://segmentfault.com/image?src=http://source.aicode.cc/markdown/jwt-diagram.png&amp;objectId=1190000005047525&amp;token=fc83f4c0cf107cabeafd6a449cd49762" alt="https://segmentfault.com/image?src=http://source.aicode.cc/markdown/jwt-diagram.png&amp;objectId=1190000005047525&amp;token=fc83f4c0cf107cabeafd6a449cd49762">(图来自参考文章)<br>客户端登录时，服务端根据JWT生成token,并返回给客户端，客户端再次请求时需要带上该token,服务端在拦截器中拿到token后使用JWT解析，如果拿到负载中的值后，会通过此次请求否则中断此次请求.<br>目前项目中还没有设置token失效；当客户端注销时，服务端目前什么操作都没做，只需客户端清除本地中的token。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>由于用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制;因为JWT并不使用Cookie，可以使用任何域名提供API服务而不需要担心跨域资源共享问题</li>
<li>由于JSON比XML简洁，因此在编码时它的大小也更小，使得JWT比SAML更紧凑。这使得JWT成为在HTML和HTTP环境中传递的不错选择</li>
<li>在安全方面，SWT只能使用HMAC算法通过共享密钥对称签名。但是，JWT和SAML令牌可以使用X.509证书形式的公钥/私钥对进行签名。与签名JSON的简单性相比，使用XML数字签名对XML进行签名而不会引入模糊的安全漏洞非常困难<blockquote>
<p>参考文章  </p>
</blockquote>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/2fdc20a42c41">https://www.jianshu.com/p/2fdc20a42c41</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>转发与重定向</title>
    <url>/2019/02/16/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<p><img src="https://note.youdao.com/yws/api/personal/file/WEB14fb30713392006f34c9cf828ec1e262?method=download&amp;shareKey=1f513ac73dc70b3fb7b8e09467f6cb01" alt="https://note.youdao.com/yws/api/personal/file/WEB14fb30713392006f34c9cf828ec1e262?method=download&amp;shareKey=1f513ac73dc70b3fb7b8e09467f6cb01"><br>平常开发中时常用到重定向，正好借此总结一下，上面的图在开发中以及参考网上文章总结出来的(参考文章见文末)。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>@RequestMapping(value = &quot;/redirect&quot;,method = RequestMethod.GET)
@ResponseBody
public String redirect(HttpServletResponse response)&#123;
    try &#123;
        response.sendRedirect(&quot;http://127.0.0.1:8080/api/redirect/test&quot;);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    return &quot;redirect&quot;;
&#125;
@RequestMapping(value = &quot;/redirect/test&quot;,method = RequestMethod.GET)
@ResponseBody
public String redirectTest(HttpServletRequest request, HttpServletResponse response)&#123;
    return &quot;redirect success&quot;;
&#125;
</code></pre><p>项目启动成功后,在浏览器输入<code>http://127.0.0.1:8080/api/redirect</code>,在chrome检查Network栏目下，可以看到:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB243a1a711e77999f1a4e92885d4cc180?method=download&amp;shareKey=44f35b431fdf7057b8e43aa9effc3af3" alt="https://note.youdao.com/yws/api/personal/file/WEB243a1a711e77999f1a4e92885d4cc180?method=download&amp;shareKey=44f35b431fdf7057b8e43aa9effc3af3"><br>客户端发生了两次接口请求,第一次是<code>http://127.0.0.1:8080/api/redirect</code>,第二次是<code>http://127.0.0.1:8080/api/redirect/test</code>;且第一次接口请求的响应状态码为302(重定向),从其请求、响应头中可以清晰交互流程：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB44f6b42a07762f378110c0beea29d9ad?method=download&amp;shareKey=49a69ce218418fdf3daa423cf4ade336" alt="https://note.youdao.com/yws/api/personal/file/WEB44f6b42a07762f378110c0beea29d9ad?method=download&amp;shareKey=49a69ce218418fdf3daa423cf4ade336"><br>从上面分析，重定向时，进行了两次接口请求;过程简单理解为浏览器首先请求接口A,接口A进行了重定向到B,接口A给浏览器的响应状态码为302,并且返回了目的接口地址B，然后浏览器再次发起请求，请求接口地址B.</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><pre><code>@RequestMapping(value = &quot;/forward&quot;,method = RequestMethod.GET)
@ResponseBody
public String forward(HttpServletRequest request, HttpServletResponse response)&#123;
    try &#123;
        request.getRequestDispatcher(&quot;/api/forward/test&quot;).forward(request,response);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; catch (ServletException e) &#123;
        e.printStackTrace();
    &#125;
    return &quot;index&quot;;
&#125;
@RequestMapping(value = &quot;/forward/test&quot;,method = RequestMethod.GET)
@ResponseBody
public String forwardTest(HttpServletRequest request, HttpServletResponse response)&#123;
    return &quot;forward success&quot;;
&#125;
</code></pre><p>在浏览器中访问<code>http://localhost:8080/api/forward</code>,会返回<code>forward success</code>,在chrome检查Network栏目下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB540a6c2c5faa49d3c420eb66ccdc250e?method=download&amp;shareKey=f6b2cbff4c4bba0ea214e9a02f9df38b" alt="https://note.youdao.com/yws/api/personal/file/WEB540a6c2c5faa49d3c420eb66ccdc250e?method=download&amp;shareKey=f6b2cbff4c4bba0ea214e9a02f9df38b"><br>浏览器只请求了一次接口,请求地址没有发生变化;而且只能转发给当前的WEB应用资源。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>重定向是客户端行为,转发是服务器行为</li>
<li>转发只发生一次请求;且只能转发到当前应用资源;请求地址不会发生变化</li>
<li>重定向发生两次请求;且能重定向到任何资源;地址栏会发生变化</li>
<li>转发速度快于重定向</li>
</ol>
<blockquote>
<p>参考文章</p>
</blockquote>
<ol>
<li><a href="https://blog.csdn.net/daochuwenziyao/article/details/54233496">https://blog.csdn.net/daochuwenziyao/article/details/54233496</a></li>
<li><a href="https://blog.csdn.net/webzhuce/article/details/54564608">https://blog.csdn.net/webzhuce/article/details/54564608</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2019/02/16/ThreadLocal/</url>
    <content><![CDATA[<h4 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h4><pre><code>* This class provides thread-local variables.  These variables differ from
 * their normal counterparts in that each thread that accesses one (via its
 * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized
 * copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private
 * static fields in classes that wish to associate state with a thread (e.g.,
 * a user ID or Transaction ID).
</code></pre><p>简单的说ThreadLocal是本地线程副本变量工具类</p>
<h4 id="ThreadLocal类图"><a href="#ThreadLocal类图" class="headerlink" title="ThreadLocal类图"></a>ThreadLocal类图</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB5ff6ccabc6d9ea2db3f3274a45e73eca?method=download&amp;shareKey=aa0a0cee764a2090798d2bbffc76e2d1" alt="https://note.youdao.com/yws/api/personal/file/WEB5ff6ccabc6d9ea2db3f3274a45e73eca?method=download&amp;shareKey=aa0a0cee764a2090798d2bbffc76e2d1"><br>上图可以看出ThreadLocal类中通过ThreadLocalMap去存储,ThreadLocalMap中的存储结构为Entry数组.</p>
<h4 id="ThreadLocal核心方法"><a href="#ThreadLocal核心方法" class="headerlink" title="ThreadLocal核心方法"></a>ThreadLocal核心方法</h4><ol>
<li><p>set(T value)</p>
<pre><code>public void set(T value) &#123;
Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null)
 map.set(this, value);
else
 createMap(t, value);
&#125;
</code></pre><p>该方法用来保存当前线程的副本所对应的变量值;首先通过<code>Thread.currentThread()</code>获取当前线程,然后获取ThreadLocalMap,调用ThreadLocalMap的set方法,把值存进去,key为ThreadLocal,再看ThreadLocalMap的set方法的代码:</p>
<pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;

 // We don&#39;t use a fast path as with get() because it is at
 // least as common to use set() to create new entries as
 // it is to replace existing ones, in which case, a fast
 // path would fail more often than not.

 Entry[] tab = table;
 int len = tab.length;
 int i = key.threadLocalHashCode &amp; (len-1);

 for (Entry e = tab[i];
      e != null;
      e = tab[i = nextIndex(i, len)]) &#123;
     ThreadLocal&lt;?&gt; k = e.get();

     if (k == key) &#123;
         e.value = value;
         return;
     &#125;

     if (k == null) &#123;
         replaceStaleEntry(key, value, i);
         return;
     &#125;
 &#125;

 tab[i] = new Entry(key, value);
 int sz = ++size;
 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
     rehash();
&#125;
</code></pre><p>通过传入的ThreadLocal获取hashCode,用作数组Entry的下标,<code>tab[i]!=null</code>时,则获取数组下一个位置也比较简单,就是下i+1:</p>
<pre><code>private static int nextIndex(int i, int len) &#123;
 return ((i + 1 &lt; len) ? i + 1 : 0);
&#125;
</code></pre></li>
<li>get()<pre><code>public T get() &#123;
Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null) &#123;
 ThreadLocalMap.Entry e = map.getEntry(this);
 if (e != null) &#123;
     @SuppressWarnings(&quot;unchecked&quot;)
     T result = (T)e.value;
     return result;
 &#125;
&#125;
return setInitialValue();
&#125;
</code></pre>get方法获取比较简单,通过当前线程获取到ThreadLocalMap,然后再获取Entry,就可以获取到变量了.</li>
<li>remove()<pre><code>public void remove() &#123;
ThreadLocalMap m = getMap(Thread.currentThread());
if (m != null)
  m.remove(this);
&#125;
</code></pre>remove方法用于移除当前线程的副本所对应的变量值,remove方法源码:<pre><code>private void remove(ThreadLocal&lt;?&gt; key) &#123;
 Entry[] tab = table;
 int len = tab.length;
 int i = key.threadLocalHashCode &amp; (len-1);
 for (Entry e = tab[i];
      e != null;
      e = tab[i = nextIndex(i, len)]) &#123;
     if (e.get() == key) &#123;
         e.clear();
         expungeStaleEntry(i);
         return;
     &#125;
 &#125;
&#125;
</code></pre>Entry调用了clear方法,用于清除该对象,继续跟进去,发现调用的clear方法是Reference的方法,Entry实现了WeakReference.关于ThreadLocal内存泄漏的问题指Entry是弱引用,当ThreadLocal没有被外部对象引用时,发生GC时会回收Entry,但是Entry中保存的值不会被回收,这个值随着该ThreadLocal线程一直存活着,占用内存,导致内存泄漏,解决的方法就是使用完ThreadLocal调用remove方法,清除变量值.</li>
</ol>
<p>参考:<br><a href="https://www.jianshu.com/p/98b68c97df9b">https://www.jianshu.com/p/98b68c97df9b</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码之解析并注册BeanDefinition(一)</title>
    <url>/2019/02/16/Spring%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%B3%A8%E5%86%8CBeanDefinition-%E4%B8%80/</url>
    <content><![CDATA[<p>最近有空把Spring加载bean流程复习了一下,也乘机可以做个整理.首先还是看下入口代码,本文主要讲解析及注册BeanDefinition整体加载流程:</p>
<pre><code>ClassPathXmlApplicationContext resource = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);
</code></pre><p>ClassPathXmlApplicationContext的类图继承关系如下:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB951df51be30c58c70a1d159bdfd9e037?method=download&amp;shareKey=9fb6c37f10d34fb28acf1a1313a4cf8c" alt="https://note.youdao.com/yws/api/personal/file/WEB951df51be30c58c70a1d159bdfd9e037?method=download&amp;shareKey=9fb6c37f10d34fb28acf1a1313a4cf8c"><br>类图可以方便的清楚该类的继承关系,利于阅读源码.<br>一步步跟进去,AbstractApplicationContext中的refresh()方法,便是IOC容器初始化的入口,该方法中调用的obtainFreshBeanFactory()方法,是载入Bean定义的资源文件,该文是分析该类的调用流程,本文使用spring版本为==4.2.4.RELEASE==,obtainFreshBeanFactory()中调用了AbstractApplicationContext子类AbstractRefreshableApplicationContext#refreshBeanFactory中的refreshBeanFactory()方法,这是<br>委派设计模式,具体实现由子类做.下面是整个调用层次关系图:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB3e9cb9f135000bc7dacc228a2197389b?method=download&amp;shareKey=9211e80a040a597bb89758af17de2f55" alt="https://note.youdao.com/yws/api/personal/file/WEB3e9cb9f135000bc7dacc228a2197389b?method=download&amp;shareKey=9211e80a040a597bb89758af17de2f55"><br>在DefaultListableBeanFactory类中的registerBeanDefinition方法内,注册了BeanDefinition信息:</p>
<pre><code>this.beanDefinitionMap.put(beanName, beanDefinition);
</code></pre><p>DefaultListableBeanFactory是Spring Bean加载中的核心类,现在不分析加载过程中细节,后面的章节会剖析.</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>bean懒加载</title>
    <url>/2019/02/16/bean%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<pre><code>Indicates whether or not this bean is to be lazily initialized.
If false, it will be instantiated on startup by bean factories
that perform eager initialization of singletons. The default is
&quot;false&quot;.
</code></pre><p>bean如果配置lazy-init=”true”时,则在容器初始化过程中不会执行依赖注入,而当使用时才会去初始化bean,真的是这样么?下面就是深入源码探究,会分析以下三种情况:</p>
<ol>
<li>bean A没有引用任何其他bean,且配置成懒加载</li>
<li>bean A引用了bean B,且bean A配置成懒加载</li>
<li>bean A引用了bean B,bean A没有配置为懒加载,bean B配置为懒加载<br>首先代码入口还是<code>AbstractApplicationContext#refresh</code>方法,其中在<code>AbstractApplicationContext#finishBeanFactoryInitialization</code>方法中会执行<code>DefaultListableBeanFactory#preInstantiateSingletons</code>:<pre><code>for (String beanName : beanNames) &#123;
         RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
         if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;
             if (isFactoryBean(beanName)) &#123;
                 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);
                 boolean isEagerInit;
                 if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;
                     isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;
                         @Override
                         public Boolean run() &#123;
                             return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();
                         &#125;
                     &#125;, getAccessControlContext());
                 &#125;
                 else &#123;
                     isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                             ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                 &#125;
                 if (isEagerInit) &#123;
                     getBean(beanName);
                 &#125;
             &#125;
             else &#123;
                 getBean(beanName);
             &#125;
         &#125;
     &#125;
</code></pre>关键代码是<code>!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()</code>,会判断bean是否为抽象类、单例、懒加载,如果不符合就不会执行if里的代码,其实第一、二中情况都不符合的,所以不会执行到if语句里的代码.关键是第三种情况,分析思路之前<a href="https://mp.weixin.qq.com/s/gduv_fAgB4-T13f6vsxkNw">这篇</a>(<a href="https://mp.weixin.qq.com/s/gduv_fAgB4-T13f6vsxkNw)分析是一样的,也就是在创建bean">https://mp.weixin.qq.com/s/gduv_fAgB4-T13f6vsxkNw)分析是一样的,也就是在创建bean</a> A的时候,在实例化其属性时,会创建bean B,有兴趣的朋友可以打断点调试,以下总结:</li>
<li>bean配置lazy-init=”true”时,在容器初始化时不会创建该bean</li>
<li>若一为单例且非懒加载的bean A引用了懒加载bean B时,在bean A被创建时,会创建bean B</li>
<li>非单例或为抽象类或配置lazy-init=”true”的bean,都不会在容器初始化时创建bean</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>bean</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>interface注入及报错分析</title>
    <url>/2019/02/16/interface%E6%B3%A8%E5%85%A5%E5%8F%8A%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfdaf58ac1dc8c2a883297003a4db402c?method=download&amp;shareKey=fffbd764872b91bae807de4755fb5bc7" alt="https://note.youdao.com/yws/api/personal/file/WEBfdaf58ac1dc8c2a883297003a4db402c?method=download&amp;shareKey=fffbd764872b91bae807de4755fb5bc7"></p>
<h3 id="一个小case"><a href="#一个小case" class="headerlink" title="一个小case"></a>一个小case</h3><p>上面错误原因我想大家开发中都遇到过,大致错误原因是注入bean时，spring找到2个实例userServiceImplTest、userServiceImpl，无法确认到底使用哪个。问题出在这，原因是什么呢，在说明前，看下面的代码：</p>
<pre><code>@RestController
public class OkController &#123;
@Autowired
UserService userService;
@ResponseBody
@GetMapping(value = &quot;/ok&quot;)
public String ok()&#123;
    UserInfoEntity userInfoEntity = userService.selectByTel(&quot;lioswang&quot;);
&#125;
//此时项目中UserService的实现类只有UserServiceImpl
@Service
public class UserServiceImpl implements UserService&#123;
    @Override
    public UserInfoEntity selectByTel(String tel) &#123;
        return  null;
    &#125;
&#125;
</code></pre><p>在OkController中为什么可以直接注入接口，当项目启动时，调用了UserServiceImpl类中的selectByTel方法,由于在OkController中引用了UserService，所以锁定在OkController初始化时Spring到底干了些什么，根据之前源码分析的经验，在<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code>方法中打上条件断点，首先看方法<code>org.springframework.beans.factory.support.AbstractBeanFactory#createBean</code>，调用了方法org.springframework.beans.factory.support.AbstractBeanFactory#createBean,继续跟进方法<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code>,<br>再跟进去方法<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</code>,继续跟进去<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues</code>，在方法中找到OkController注入的元数据UserService,调用了<code>org.springframework.beans.factory.annotation.InjectionMetadata#inject</code>,跟进去<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</code>，继续跟<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code>，其中代码片段：</p>
<pre><code>//获取接口的依赖
result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
</code></pre><p>调用了<br><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code>,该方法的代码片段</p>
<pre><code>Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
</code></pre><p>继续跟<br><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#findAutowireCandidates</code>,其中获取UserService所有的实现类:</p>
<pre><code>//获取到UserService的实现类
String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, requiredType, true, descriptor.isEager());
//获取到实现类后，并初始化，保存在Map&lt;String, Object&gt;
result.put(candidateName, getBean(candidateName));
</code></pre><p>再看<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code>方法中代码片段：</p>
<pre><code>Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
if (matchingBeans.isEmpty()) &#123;
    if (descriptor.isRequired()) &#123;
        raiseNoSuchBeanDefinitionException(type, &quot;&quot;, descriptor);
    &#125;
    return null;
&#125;
//获取匹配到的bean数大于1时的逻辑处理
if (matchingBeans.size() &gt; 1) &#123;
    String primaryBeanName = determineAutowireCandidate(matchingBeans, descriptor);
    if (primaryBeanName == null) &#123;
        throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());
    &#125;
    if (autowiredBeanNames != null) &#123;
        autowiredBeanNames.add(primaryBeanName);
    &#125;
    return matchingBeans.get(primaryBeanName);
&#125;
// We have exactly one match.
Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();
if (autowiredBeanNames != null) &#123;
    autowiredBeanNames.add(entry.getKey());
&#125;
return entry.getValue();
&#125;
</code></pre><p>由于目前项目中UserService的实现类只有UserServiceImpl，所以最终获取到的只有一个。<br>再回到<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</code>中，已经找到UserService的实现类，所以执行:</p>
<pre><code>ReflectionUtils.makeAccessible(field);
field.set(bean, value);
</code></pre><p>即把UserServiceImpl的实例设置到属性UserService中。<br>所以当再OkController中调用UserService的selectByTel方法，其实调用的是UserServiceImpl的selectByTel方法。</p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>上面分析那么多，其实就是为了说明我们注入接口时，为什么会调用实现类的方法。为了报错，很简单，再写一个类实现UserService接口即可，OkController中不需要修改，其实由上面的分析知道，报错的就是上面的这段代码：</p>
<pre><code>if (matchingBeans.size() &gt; 1) &#123;
    String primaryBeanName = determineAutowireCandidate(matchingBeans, descriptor);
    if (primaryBeanName == null) &#123;
        throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());
    &#125;
    if (autowiredBeanNames != null) &#123;
        autowiredBeanNames.add(primaryBeanName);
    &#125;
    return matchingBeans.get(primaryBeanName);
&#125;
</code></pre><p>也就是在UserService的实现类中找到多个bean实例，这个明显是错误的，</p>
<h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p>如何解决这个问题呢，很简单:</p>
<pre><code>@Autowired
@Qualifier(&quot;userServiceImpl&quot;)
UserService userService;
</code></pre><p>或</p>
<pre><code>@Resource(name = &quot;userServiceImpl&quot;)
UserService userService;
</code></pre><p>因为在<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#findAutowireCandidates</code>方法中的</p>
<pre><code>for (String candidateName : candidateNames) &#123;
    if (!isSelfReference(beanName, candidateName) &amp;&amp; isAutowireCandidate(candidateName, descriptor)) &#123;
        result.put(candidateName, getBean(candidateName));
    &#125;
&#125;
</code></pre><p>会根据注解过滤bean，所以加上上面的注解后会解决错误,具体代码就不分析了，感兴趣的同学可打断点调试。</p>
<h3 id="思考拓展"><a href="#思考拓展" class="headerlink" title="思考拓展"></a>思考拓展</h3><pre><code>@RestController
public class OkController &#123;
@Autowired
Map&lt;String,UserService&gt; userServiceMap;
@ResponseBody
@GetMapping(value = &quot;/ok&quot;)
public String ok()&#123;
   ...
&#125;
</code></pre><p>若OkController中代码修改如上，项目启动后，发现没有报错，而且userServiceMap中有两个key-value元素，无疑是UserServiceImpl、UserServiceImplTest,我想原因不难看出，<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#findAutowireCandidates</code>返回了Map&lt;String, Object&gt;，其值和userServiceMap相同，不难看出spring功能非常强大。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>javaConfig整合spring、redis</title>
    <url>/2019/02/16/javaConfig%E6%95%B4%E5%90%88spring%E3%80%81redis/</url>
    <content><![CDATA[<p>使用spring-data-redis的模版,客户端使用jedis,下面配置bean:</p>
<pre><code>@Configuration
public class RedisConfig &#123;
    @Autowired
    @Qualifier(&quot;jedisPoolConfig&quot;)
    JedisPoolConfig jedisPoolConfig;
    @Autowired
    @Qualifier(&quot;jedisConnectionFactory&quot;)
    JedisConnectionFactory jedisConnectionFactory;

    @Bean
    public JedisPoolConfig jedisPoolConfig() &#123;
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxIdle(6);
        jedisPoolConfig.setTestWhileIdle(true);
        jedisPoolConfig.setMinEvictableIdleTimeMillis(60000L);
        jedisPoolConfig.setTimeBetweenEvictionRunsMillis(30000L);
        jedisPoolConfig.setNumTestsPerEvictionRun(-1);
        return jedisPoolConfig;
    &#125;

    @Bean
    @ConditionalOnBean(JedisPoolConfig.class)
    public JedisConnectionFactory jedisConnectionFactory() &#123;
        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();
        jedisConnectionFactory.setPoolConfig(jedisPoolConfig);
        jedisConnectionFactory.setHostName(&quot;127.0.0.1&quot;);
        jedisConnectionFactory.setPort(6379);
        jedisConnectionFactory.setPassword(&quot;123456&quot;);
        jedisConnectionFactory.setTimeout(15000);
        jedisConnectionFactory.setUsePool(true);
        return jedisConnectionFactory;
    &#125;

    @Bean
    @ConditionalOnBean(JedisConnectionFactory.class)
    public RedisTemplate redisTemplate() &#123;
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(jedisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());
        redisTemplate.setHashKeySerializer(new JdkSerializationRedisSerializer());
        redisTemplate.setHashKeySerializer(new JdkSerializationRedisSerializer());
        return redisTemplate;
    &#125;
&#125;

</code></pre><p>下面是工具类使用:</p>
<pre><code>package com.lios.base.cache;
import org.springframework.data.redis.core.*;
import org.springframework.stereotype.Component;
import javax.annotation.Resource;
import java.util.*;
import java.util.concurrent.TimeUnit;
import static com.lios.base.cache.AbstractLiosRedisClient.deeplyAppendParameter;
import static com.lios.base.cache.AbstractLiosRedisClient.isDoubleEscaped;
import static com.lios.base.cache.AbstractLiosRedisClient.isEscapedDelimeter;

/**
 * @author LiosWong
 * @description
 * @date 2018/7/22 下午11:56
 */
@Component
public class LiosRedisClient &#123;
    /**
     * String操作
     */
    @Resource(name = &quot;redisTemplate&quot;)
    private ValueOperations&lt;String,Object&gt; valueOperations;

    /**
     * hash操作
     */
    @Resource(name = &quot;redisTemplate&quot;)
    private HashOperations&lt;String, String, String&gt; hashOperations;

    /**
     * set操作
     */
    @Resource(name = &quot;redisTemplate&quot;)
    private SetOperations&lt;String, String&gt; setOperations;

    /**
     * list操作
     */
    @Resource(name = &quot;redisTemplate&quot;)
    private ListOperations&lt;String,String&gt; listOperations;

    @Resource(name = &quot;redisTemplate&quot;)
    private RedisTemplate redisTemplate;

    /**********************************set操作*******************************************/

    /**
     *
     * @param keyFormat key格式
     * @param value     实际的值
     * @param keyValues key占位符的值
     */
    public void set(String keyFormat, Object value, String... keyValues) &#123;
        String key = format(keyFormat, keyValues);
        valueOperations.set(key, value);
    &#125;

    /**
     *
     * @param keyFormat key格式
     * @param value     实际的值
     * @param expireSeconds 失效时间
     * @param keyValues  key占位符的值
     */
    public void set(String keyFormat, Object value,long expireSeconds,String... keyValues)&#123;
        String key = format(keyFormat,keyValues);
        valueOperations.set(key,value,expireSeconds,TimeUnit.MILLISECONDS);
    &#125;

    /**
     *
     * @param keyFormat key格式
     * @param value     实际的值
     * @param keyValues key占位符的值
     * @return
     */
    public boolean setIfAbsent(String keyFormat, Object value, String... keyValues) &#123;
        String key = format(keyFormat, keyValues);
        return valueOperations.setIfAbsent(key, value);
    &#125;


    /**
     *
     * @param keyFormat key格式
     * @param keyValues key占位符值
     * @param &lt;T&gt;
     * @return
     */
    public &lt;T&gt; T get(String keyFormat, String... keyValues) &#123;
        String key = format(keyFormat, keyValues);
        Object o = valueOperations.get(key);
        if (!Objects.isNull(o)) &#123;
            return (T) o;
        &#125;
        return null;
    &#125;

    /**
     * 删除key值
     * @param keyFormat key格式
     * @param keyValues key占位符值
     */
    public void del(String keyFormat,String ... keyValues)&#123;
        String key = format(keyFormat,keyValues);
        redisTemplate.delete(key);
    &#125;

    /**
     * 自增计数器
     * @param keyFormat
     * @param value
     * @param keyValues
     * @return
     */
    public Long incrBy(String keyFormat, Long value, String... keyValues) &#123;
        String key = format(keyFormat, keyValues);
        return valueOperations.increment(key, value);
    &#125;


    /**********************************hash操作*******************************************/


    public String hGet(String keyFormat, String hashKey, String... keyValues) &#123;
        String key = format(keyFormat, keyValues);
        String result = hashOperations.get(key, hashKey);
        return result;
    &#125;

    public void hPut(String keyFormat, String hashKey, String value, String... keyValues) &#123;
        String key = format(keyFormat, keyValues);
        hashOperations.put(key, hashKey, value);
    &#125;




    /**********************************set操作*******************************************/

    /**
     * 添加元素
     * @param keyFormat
     * @param value
     * @param keyValues
     */
    public Long add(String keyFormat,String value,String ... keyValues)&#123;
        String key = format(keyFormat,keyValues);
        return setOperations.add(key,value);
    &#125;

    /**
     * 弹出某个key
     * @param keyFormat
     * @param keyValues
     * @param &lt;T&gt;
     * @return
     */
    public &lt;T&gt; T pop(String keyFormat,String ... keyValues)&#123;
        String key = format(keyFormat,keyValues);
        return (T) setOperations.pop(key);
    &#125;

    /**
     * 比较两个key
     * @param key1
     * @param key2
     * @return
     */
    public Set&lt;String&gt; difference(String key1,String key2)&#123;
        return setOperations.difference(key1,key2);
    &#125;




    /**********************************list操作*******************************************/


    /**
     *  左侧进入
     * @param keyFormat
     * @param value
     * @param keyValues
     */
    public void listLeftPush(String keyFormat,String value,String... keyValues) &#123;
        String key = format(keyFormat,keyValues);
        listOperations.leftPush(key,value);
    &#125;

    /**
     * 长度
     * @param keyFormat
     * @param keyValues
     * @return
     */
    public Long listSize(String keyFormat,String... keyValues) &#123;
        String key = format(keyFormat,keyValues);
        return listOperations.size(key);
    &#125;

    /**
     * 右侧进入
     * @param keyFormat
     * @param keyValues
     * @return
     */
    public String listRightPop(String keyFormat, String... keyValues) &#123;
        String key = format(keyFormat,keyValues);
        return listOperations.rightPop(key);
    &#125;

    /**
     * 取出队列中指定范围的元素
     * @param keyFormat
     * @param start
     * @param end
     * @param keyValues
     * @return
     */
    public List&lt;String&gt; listRange(String keyFormat, long start, long end, String... keyValues)&#123;
        String key = format(keyFormat,keyValues);
        return listOperations.range(key, start, end);
    &#125;

    public static final String format(String messagePattern, Object[] argArray) &#123;
        if(messagePattern == null) &#123;
            return messagePattern;
        &#125; else if(argArray == null) &#123;
            return messagePattern;
        &#125; else &#123;
            int i = 0;
            StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);

            for(int L = 0; L &lt; argArray.length; ++L) &#123;
                int j = messagePattern  .indexOf(&quot;&#123;&#125;&quot;, i);
                if(j == -1) &#123;
                    if(i == 0) &#123;
                        return messagePattern;
                    &#125;

                    sbuf.append(messagePattern, i, messagePattern.length());
                    return messagePattern;
                &#125;

                if(isEscapedDelimeter(messagePattern, j)) &#123;
                    if(!isDoubleEscaped(messagePattern, j)) &#123;
                        --L;
                        sbuf.append(messagePattern, i, j - 1);
                        sbuf.append(&#39;&#123;&#39;);
                        i = j + 1;
                    &#125; else &#123;
                        sbuf.append(messagePattern, i, j - 1);
                        deeplyAppendParameter(sbuf, argArray[L], new HashMap());
                        i = j + 2;
                    &#125;
                &#125; else &#123;
                    sbuf.append(messagePattern, i, j);
                    deeplyAppendParameter(sbuf, argArray[L], new HashMap());
                    i = j + 2;
                &#125;
            &#125;

            sbuf.append(messagePattern, i, messagePattern.length());
            return sbuf.toString();
        &#125;
    &#125;
&#125;

</code></pre><p>格式化key的方法使用的是slf4j中的方法.</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>python初试</title>
    <url>/2019/02/16/python%E5%88%9D%E8%AF%95/</url>
    <content><![CDATA[<p>最近使用python批量处理业务需求,大概是读取本地文件中的每一行订单号,然后发起http请求接口,处理具体的业务,由于实现起来很简单,所以使用python最适当不过了。<br>python代码:</p>
<pre><code># -*- coding: UTF-8 -*-
import time
import json
import requests

def doIndexratePost(orderNo):
  // body数据
  data = &#123;&#39;orderNo&#39;:orderNo,&#39;type&#39;:&#39;3&#39;&#125;
  # 设置请求头token
  headers = &#123;&#39;token&#39;:&#39;3eb44d33fdf59677fa97557c0e636463&#39;,&#39;Content-Type&#39;:&#39;application/json&#39;&#125;
  requestUrl = &quot;请求的URL&quot;
  // 使用requests库发起post请求
  r = requests.post(requestUrl, data=json.dumps(data), headers=headers)
  res = r.json()
  // 打印响应
  print(res)
  # 休眠1s
  time.sleep(1);

# 批量读取文件
f = open(&#39;/Users/wenchao.wang/LiosWang/sublimetext/dodataone.txt&#39;);
num = 0;
for i in f.readlines():
  orderNo = i.strip(&#39;\n&#39;)
  // 调用函数doIndexratePost处理业务
  doIndexratePost(orderNo);
  num = num + 1;
  print (num,&quot;已执行完&quot;)
</code></pre><p>在sublimetext3中执行如下:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB502765ba8f341236c351995291594655?method=download&amp;shareKey=6aefeeac4d18ea83d1e5ef974a66fb1d" alt="https://note.youdao.com/yws/api/personal/file/WEB502765ba8f341236c351995291594655?method=download&amp;shareKey=6aefeeac4d18ea83d1e5ef974a66fb1d"><br>上面简短的代码就实现批量处理业务需求,确实简单方便。我用的mac,用的brew安装python3.7,比自己下载源代码编译安装方便的多，而且很可能会在安装三方库时遇到一些蛋痛的问题,编辑器用的sublimetext3,集成插件用起来十分轻量快捷。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot、redis整合</title>
    <url>/2019/02/16/springboot%E3%80%81redis%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h4 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h4><ul>
<li>下载:sudo wget <a href="http://download.redis.io/releases/redis-3.2.6.tar.gz">http://download.redis.io/releases/redis-3.2.6.tar.gz</a><ul>
<li>解压 <code>sudo tar -zxvf redis-3.2.6.tar.gz</code></li>
<li>安装gcc <code>sudo apt-get install gcc</code></li>
<li>编译、安装 <pre><code>sudo make
sudo make install 
</code></pre></li>
</ul>
</li>
<li>redis-conf copy到/etc/redis目录,修改:<pre><code>       requirepass 123456
       #bind 127.0.0.1 注释该行
</code></pre><ul>
<li>启动redis服务<br>./redis-server /etc/redis/redis.conf<h4 id="springboot中整合"><a href="#springboot中整合" class="headerlink" title="springboot中整合"></a>springboot中整合</h4></li>
</ul>
</li>
</ul>
<ul>
<li><p>redis-client.xml</p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
      &lt;aop:aspectj-autoproxy/&gt;
      &lt;bean id=&quot;redisConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
          &lt;property name=&quot;maxIdle&quot; value=&quot;6&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;3&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;
          &lt;property name=&quot;poolConfig&quot; ref=&quot;redisConfig&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis.host&#125;&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;timeout&quot; value=&quot;15000&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;usePool&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;
          &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;keySerializer&quot;&gt;
              &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;
          &lt;/property&gt;
          &lt;property name=&quot;valueSerializer&quot;&gt;
              &lt;bean class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;/&gt;
          &lt;/property&gt;
          &lt;property name=&quot;hashKeySerializer&quot;&gt;
              &lt;bean class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;&gt;&lt;/bean&gt;
          &lt;/property&gt;
          &lt;property name=&quot;hashValueSerializer&quot;&gt;
              &lt;bean class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;&gt;&lt;/bean&gt;
          &lt;/property&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;shardedJedisPool&quot; class=&quot;redis.clients.jedis.ShardedJedisPool&quot; &gt;
          &lt;constructor-arg index=&quot;0&quot; ref=&quot;redisConfig&quot; /&gt;
          &lt;constructor-arg index=&quot;1&quot;&gt;
              &lt;list&gt;
                  &lt;bean class=&quot;redis.clients.jedis.JedisShardInfo&quot;&gt;
                      &lt;constructor-arg name=&quot;host&quot; value=&quot;$&#123;redis.host&#125;&quot; /&gt;
                      &lt;constructor-arg name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot; /&gt;
                     &lt;!-- &lt;constructor-arg name=&quot;timeout&quot; value=&quot;15000&quot; /&gt;
                      &lt;constructor-arg name=&quot;weight&quot; value=&quot;1&quot; /&gt;--&gt;
                      &lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot;&gt;&lt;/property&gt;
                  &lt;/bean&gt;
              &lt;/list&gt;
          &lt;/constructor-arg&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;valueOperations&quot; class=&quot;org.springframework.data.redis.core.DefaultValueOperations&quot;&gt;
          &lt;constructor-arg name=&quot;template&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;hashOperations&quot; class=&quot;org.springframework.data.redis.core.DefaultHashOperations&quot;&gt;
          &lt;constructor-arg name=&quot;template&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;setOperations&quot; class=&quot;org.springframework.data.redis.core.DefaultSetOperations&quot;&gt;
          &lt;constructor-arg name=&quot;template&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;zSetOperations&quot; class=&quot;org.springframework.data.redis.core.DefaultZSetOperations&quot;&gt;
          &lt;constructor-arg name=&quot;template&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;
      &lt;!-- 用String来做序列化的redis存储 --&gt;
      &lt;bean id=&quot;rawRedisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;
          &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;&gt;&lt;/property&gt;
          &lt;property name=&quot;KeySerializer&quot;&gt;
              &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;
          &lt;/property&gt;
          &lt;property name=&quot;defaultSerializer&quot;&gt;
              &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;
          &lt;/property&gt;
      &lt;/bean&gt;
      &lt;bean id=&quot;rawValueOperations&quot; class=&quot;org.springframework.data.redis.core.DefaultValueOperations&quot;&gt;
          &lt;constructor-arg name=&quot;template&quot; ref=&quot;rawRedisTemplate&quot;&gt;&lt;/constructor-arg&gt;
      &lt;/bean&gt;
  &lt;/beans&gt;
</code></pre></li>
<li>redis.properties<pre><code>  #redis
  redis.host=192.168.31.168
  redis.port=6379
  redis.password=123456
</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><code>`</code><br>@SpringBootApplication<br>@ImportResource({“classpath*:redis-client.xml”})<br>public class LiosBootApplication extends WebMvcConfigurerAdapter {<br>  public static void main(String[] args) {<pre><code>  SpringApplication.run(LiosBootApplication.class, args);
</code></pre> }<br>}</li>
</ul>
<p>@RestController<br>public class HelloController {<br>    @Autowired<br>    RedisClient redisClient;<br>    @PostMapping(value = “/lios/boot/ok”,produces = {“application/json;charset=utf-8”})<br>    public void ok(UserParam param){<br>        redisClient.set(“xxxxx”,”lios”);<br>        String a = redisClient.get(“xxxxx”);<br>    }<br>}<br><code>`</code></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring、mybatis整合源码简单分析</title>
    <url>/2019/02/16/spring%E3%80%81mybatis%E6%95%B4%E5%90%88%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>&lt;bean id=&quot;localDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.31.14:3366/lios?characterEncoding=utf8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
        ...
    &lt;/bean&gt;
    &lt;!-- 创建SqlSessionFactory，同时指定数据源--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;localDataSource&quot;/&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:sqlmap-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot;&gt;
            &lt;list&gt;
               &lt;value&gt;classpath*:com/lios/mybatis/mapper/*.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.lios.mybatis.dao&quot;/&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
    &lt;/bean&gt;
</code></pre><p><code>MapperScannerConfigurer</code>这个bean有什么作用呢,MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor接口，该接口可以让我们实现自定义并注册bean，具体可以参考关于BeanDefinitionRegistryPostProcessor接口<a href="https://mp.weixin.qq.com/s?__biz=MzIxNDE2MTE3MA==&amp;mid=2247483817&amp;idx=1&amp;sn=fd2be09dfaada65270ccb143bc0e491a&amp;chksm=97aa83d4a0dd0ac2cfa5981685998c7557b9c0d4318c7c612f7602da26aac20bdf139e8fab6c&amp;token=260922015&amp;lang=zh_CN#rd">使用的文章</a>,无疑分析入口还是从<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>方法开始.</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<h5 id="扫描basePackages-封装MapperFactoryBean-注册到spring容器"><a href="#扫描basePackages-封装MapperFactoryBean-注册到spring容器" class="headerlink" title="扫描basePackages,封装MapperFactoryBean,注册到spring容器"></a>扫描basePackages,封装MapperFactoryBean,注册到spring容器</h5></blockquote>
<p>在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法里,会调用：</p>
<pre><code>invokeBeanFactoryPostProcessors(beanFactory);
</code></pre><p>调用BeanFactory的后置处理器，向容器中注册自定义Bean,一直跟到<code>PostProcessorRegistrationDelegate</code>类的<code>invokeBeanFactoryPostProcessors</code>方法中这段代码:</p>
<pre><code>// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
boolean reiterate = true;
while (reiterate) &#123;
    reiterate = false;
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) &#123;
        if (!processedBeans.contains(ppName)) &#123;
            //getBean方法会初始化MapperScannerConfigurer
            BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);
            registryPostProcessors.add(pp);
            processedBeans.add(ppName);
            // 调用MapperScannerConfigurer的postProcessBeanDefinitionRegistry方法
            pp.postProcessBeanDefinitionRegistry(registry);
            reiterate = true;
        &#125;
    &#125;
&#125;
</code></pre><p>跟到MapperScannerConfigurer的postProcessBeanDefinitionRegistry方法中,关键代码:</p>
<pre><code>...
scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
</code></pre><p>这段代码用于扫描MapperScannerConfigurer中配置的basePackage路径下的文件.继续根进<code>ClassPathBeanDefinitionScanner</code>类的<code>scan</code>方法:</p>
<pre><code>// Register annotation config processors, if necessary.
if (this.includeAnnotationConfig) &#123;
    AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
&#125;
return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
</code></pre><p><code>doScan</code>方法会调用<code>ClassPathMapperScanner#doScan</code>类中的doScan方法:</p>
<pre><code>// 调用父类doScan方法,扫描basePackage下的mapper的接口文件,封装成Set&lt;BeanDefinitionHolder&gt;
doScan(basePackages);
Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);
if (beanDefinitions.isEmpty()) &#123;
  logger.warn(&quot;No MyBatis mapper was found in &#39;&quot; + Arrays.toString(basePackages) + &quot;&#39; package. Please check your configuration.&quot;);
&#125; else &#123;
  processBeanDefinitions(beanDefinitions);
&#125;
return beanDefinitions;
</code></pre><p><code>processBeanDefinitions</code>方法很重要:</p>
<pre><code>GenericBeanDefinition definition;
for (BeanDefinitionHolder holder : beanDefinitions) &#123;
  definition = (GenericBeanDefinition) holder.getBeanDefinition();
  // the mapper interface is the original class of the bean
  // but, the actual class of the bean is MapperFactoryBean
  definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59
  // 上面的注释其实说的很清楚了,mapper接口实际的实体为MapperFactoryBean
  definition.setBeanClass(this.mapperFactoryBean.getClass());
  // 设置MapperFactoryBean属性addToConfig元素
  definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);
  ...
  // 设置MapperFactoryBean属性sqlSessionTemplate元素
  definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);
&#125;
</code></pre><p>经过上面的流程，basePackages下的mapper接口已经注册到容器中.</p>
<h5 id="实例化MapperFactoryBean中SqlSessionFactory-解析xml配置文件"><a href="#实例化MapperFactoryBean中SqlSessionFactory-解析xml配置文件" class="headerlink" title="实例化MapperFactoryBean中SqlSessionFactory,解析xml配置文件"></a>实例化MapperFactoryBean中SqlSessionFactory,解析xml配置文件</h5><p>继续回到<code>AbstractApplicationContext</code>类中的<code>refresh</code>中,会在该方法中初始化所有单例且是懒加载的bean,如果在应用中注入使用mapper接口时:</p>
<pre><code>@Autowired
UserInfoDao userInfoDao;
</code></pre><p>就会初始化该mapper实例，其实就是初始化<code>MapperFactoryBean</code>,spring会检查该bean的属性是否为对象,依次初始化,由于<br>MapperFactoryBean中的属性SqlSessionTemplate、addToConfig，由于SqlSessionTemplate已经在配置文件配置,继而又会去初始化SqlSessionTemplate的属性<code>org.mybatis.spring.SqlSessionFactoryBean</code>,因为SqlSessionFactoryBean实现了<code>InitializingBean</code>接口，所以在初始化时会调用其<code>afterPropertiesSet</code>方法:</p>
<pre><code>@Override
public void afterPropertiesSet() throws Exception &#123;
notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);
notNull(sqlSessionFactoryBuilder, &quot;Property &#39;sqlSessionFactoryBuilder&#39; is required&quot;);
state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),
          &quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);
this.sqlSessionFactory = buildSqlSessionFactory();
&#125;
</code></pre><p><code>buildSqlSessionFactory</code>方法非常关键,用来解析mppaer xml文件,关键代码:</p>
<pre><code>XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),
configuration, mapperLocation.toString(), configuration.getSqlFragments());
xmlMapperBuilder.parse();
</code></pre><p>这里不作具体分析。</p>
<blockquote>
<h5 id="生成mapper接口动态代理类"><a href="#生成mapper接口动态代理类" class="headerlink" title="生成mapper接口动态代理类"></a>生成mapper接口动态代理类</h5></blockquote>
<p>当MapperFactoryBean中的属性初始化完后,则继续执行MapperFactoryBean的初始化流程,在<code>AbstractBeanFactory</code>类的<code>doGetBean</code>方法中：</p>
<pre><code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
</code></pre><p>调用了<code>AbstractBeanFactory</code>类的getObjectForBeanInstance方法：</p>
<pre><code>object = getObjectFromFactoryBean(factory, beanName, !synthetic);
</code></pre><p>因为MapperFactoryBean实现了FactoryBean接口，所以才可以向下执行代码,<br>继续调用了<code>FactoryBeanRegistrySupport</code>类的getObjectFromFactoryBean方法:</p>
<pre><code>Object object = doGetObjectFromFactoryBean(factory, beanName);
</code></pre><p>继续调用<code>FactoryBeanRegistrySupport</code>类中的doGetObjectFromFactoryBean方法:</p>
<pre><code>...
object = factory.getObject();
...
</code></pre><p>原来调用了FactoryBean的getObject方法,这时则断点执行到了<br><code>MapperFactoryBean</code>的getObject方法中:</p>
<pre><code>return getSqlSession().getMapper(this.mapperInterface);
</code></pre><p>继续执行到<code>org.apache.ibatis.session.Configuration</code>的getMapper方法：</p>
<pre><code>final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
if (mapperProxyFactory == null) &#123;
  throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
&#125;
try &#123;
  return mapperProxyFactory.newInstance(sqlSession);
&#125; catch (Exception e) &#123;
  throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
&#125;
</code></pre><p>上面代码是不是很熟悉，原来为mapper 接口创建了代理类<code>MapperProxy&lt;T&gt;</code>,当调用mapper接口中具体的方法操作数据库时，其实执行的的是<code>MapperProxy&lt;T&gt;</code>中的invoke方法:</p>
<pre><code>try &#123;
  if (Object.class.equals(method.getDeclaringClass())) &#123;
    return method.invoke(this, args);
  &#125; else if (isDefaultMethod(method)) &#123;
    return invokeDefaultMethod(proxy, method, args);
  &#125;
&#125; catch (Throwable t) &#123;
  throw ExceptionUtil.unwrapThrowable(t);
&#125;
final MapperMethod mapperMethod = cachedMapperMethod(method);
return mapperMethod.execute(sqlSession, args);
</code></pre><p>上面还有一个关键点就是，xml中解析的配置如何与spring容器中mapper bean相关联呢,其实通过<code>DaoSupport</code>类中的<code>checkDaoConfig</code>方法,在<code>DaoSupport</code>类的<code>afterPropertiesSet</code>方法中调用,具体看MapperFactoryBean中的checkDaoConfig实现:</p>
<pre><code>@Override
  protected void checkDaoConfig() &#123;
    super.checkDaoConfig();
    notNull(this.mapperInterface, &quot;Property &#39;mapperInterface&#39; is required&quot;);
    // mybatis中配置类
    Configuration configuration = getSqlSession().getConfiguration();
    if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123;
      try &#123;
        // 添加mapper关联
        configuration.addMapper(this.mapperInterface);
      &#125; catch (Exception e) &#123;
        logger.error(&quot;Error while adding the mapper &#39;&quot; + this.mapperInterface + &quot;&#39; to configuration.&quot;, e);
        throw new IllegalArgumentException(e);
      &#125; finally &#123;
        ErrorContext.instance().reset();
      &#125;
    &#125;
  &#125;
</code></pre><p>到此为止，已经分析完了mybatis与spring结合的源码简单说明，省略了大量的细节，以及mapper xml文件解析、sql执行流程没有分析，后续文章会做分析。由于作者水平有限，文章存在错误之处，肯请斧正，谢谢！</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全国家统计局划分代码爬取</title>
    <url>/2019/02/16/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E5%9B%BD%E5%AE%B6%E7%BB%9F%E8%AE%A1%E5%B1%80%E5%88%92%E5%88%86%E4%BB%A3%E7%A0%81%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p>由于工作中使用国家统计局划分的区域码,本文使用python爬取地方划分码,地址:<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/</a><br>本文爬取的是2018年发布的划分码,最新的划分码分为省、市、县、城镇、村庄.<br>代码:</p>
<pre><code># -*- coding: utf-8 -*-
import requests
import sys
import re
from bs4 import BeautifulSoup
headers = &#123;
&quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,
&quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,
&quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,
&quot;Cache-Control&quot;: &quot;max-age=0&quot;,
&quot;Connection&quot;: &quot;keep-alive&quot;,
&quot;Cookie&quot;: &quot;AD_RS_COOKIE=20081945; _trs_uv=jrhivtz7_6_jyyw&quot;,
&quot;Host&quot;: &quot;www.stats.gov.cn&quot;,
&quot;If-Modified-Since&quot;: &quot;Thu, 05 Jul 2018 00:43:11 GMT&quot;,
&quot;If-None-Match&quot;: &quot;17b5-57035d4e665c0-gzip&quot;,
&quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,
&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;
&#125;


def getItem(itemData, dataArray, parentRequestUrl, table, type):
    item = &#123;&#125;
    # 名称
    if(type == 5):
        item[&#39;name&#39;] = str(dataArray[2].get_text())
    else:
        item[&#39;name&#39;] = str(dataArray[1].get_text())
    # 下一级请求url
    href = re.findall(&#39;(.*)/&#39;, parentRequestUrl)
    if type != 5:
        item[&#39;url&#39;] = href[0] + &quot;/&quot; + dataArray[0].get(&#39;href&#39;)
    # 父级code
    item[&#39;parentCode&#39;] = itemData.get(&#39;code&#39;)
    # 类型
    item[&#39;type&#39;] = type
    # code码
    item[&#39;code&#39;] = str(dataArray[0].get_text())[0:12]
    # if type == 4:
    #     print(item.get(&#39;url&#39;))
    # 打印出sql语句
    print(&#39;insert into %s(name,code,type,parent_code) values (%s,%s,%s,%s)&#39; % (
        table, item[&#39;name&#39;], item[&#39;code&#39;], item[&#39;type&#39;], item[&#39;parentCode&#39;]) + &quot;;&quot;)
    return item

# 获取BeautifulSoup
def getSoup(requestUrl):
    htmls = requests.get(requestUrl, headers=headers)
    htmls.encoding = &#39;GBK&#39;
    soup = BeautifulSoup(htmls.text, &#39;html.parser&#39;, from_encoding=&#39;UTF-8&#39;)
    return soup

# 循环处理
def loopItem(label, labelClass, labelChild, item, requestUrl, type, tableName, lists):
    for link in soup.find_all(label, labelClass):
        array = link.find_all(labelChild, class_=&#39;&#39;)
        if not len(array):
            continue
        itemData = getItem(item, array, requestUrl, tableName, type)
        lists.append(itemData)

requestProviceUrl = &#39;http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2018/index.html&#39;
soup = getSoup(requestProviceUrl)
# 省列表
provinceList = []
for link in soup.find_all(&#39;a&#39;, class_=&#39;&#39;):
    requestCityUrl = re.findall(&#39;(.*)/&#39;, requestProviceUrl)
    item = &#123;&#125;
    # 名称
    item[&#39;name&#39;] = str(link.get_text())
    # 下一级请求url
    href = str(link.get(&#39;href&#39;))
    item[&#39;url&#39;] = requestCityUrl[0] + &quot;/&quot; + href
    # 父级code
    item[&#39;parentCode&#39;] = &#39;000000000000&#39;
    # 类型
    item[&#39;type&#39;] = 1
    # code码
    item[&#39;code&#39;] = (href.split(&#39;.&#39;))[0] + &#39;0000000000&#39;
    provinceList.append(item)
    # 打印出sql语句
    # print(&#39;====&gt;&#39;,types)
    print(&#39;insert into province(name,code,type,parent_code) values (%s,%s,%s,%s)&#39; % (
        (item[&#39;name&#39;] + &#39;&#39;), item[&#39;code&#39;], item[&#39;type&#39;], item[&#39;parentCode&#39;]) + &quot;;&quot;)

# 市列表
cityList = []
for item in provinceList:
    # 测试正常退出
    cityRequestUrl = str(item.get(&#39;url&#39;))
    soup = getSoup(item.get(&#39;url&#39;))
    loopItem(&#39;tr&#39;, &#39;citytr&#39;, &#39;a&#39;, item, cityRequestUrl, 2, &#39;city&#39;, cityList)

# 县列表
countyList = []
for item in cityList:
    # 测试正常退出
    countyRequestUrl = str(item.get(&#39;url&#39;))
    soup = getSoup(item.get(&#39;url&#39;))
    loopItem(&#39;tr&#39;, &#39;countytr&#39;, &#39;a&#39;, item,
     countyRequestUrl, 3, &#39;county&#39;, countyList)

# 城镇列表
townList = []
for item in countyList:
    # 测试正常退出
    townRequestUrl = str(item.get(&#39;url&#39;))
    soup = getSoup(item.get(&#39;url&#39;))
    loopItem(&#39;tr&#39;, &#39;towntr&#39;, &#39;a&#39;, item, townRequestUrl, 4, &#39;town&#39;, townList)

# 村庄列表
villageList = []
for item in townList:
    # 测试正常退出
    villageRequestUrl = str(item.get(&#39;url&#39;))
    soup = getSoup(item.get(&#39;url&#39;))
    loopItem(&#39;tr&#39;, &#39;villagetr&#39;, &#39;td&#39;, item,
     villageRequestUrl, 5, &#39;village&#39;, villageList)
</code></pre><p>解析html使用的是BeautifulSoup,十分简单方便,上文直接生成sql语句,输出到控制台即可.运行结果:<br><img src="https://img-blog.csdnimg.cn/20190210014859367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JBVF9vcw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数</title>
    <url>/2019/02/16/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin">回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应</a> –摘自百度百科–  </p>
</blockquote>
<p>什么是回调函数,上面的问题说的是不是很空洞,不是太形象,下面是知乎上的一位网友给的答案:<br><a href="https://www.zhihu.com/question/19801131"><img src="https://note.youdao.com/yws/api/personal/file/WEB9482fb6622b45a47425558c33394bfac?method=download&amp;shareKey=fe3423af3064a071b3c755ec509dc78b" alt=""></a><br>为了有更直观的体会,下面通过代码来实现上述过程,</p>
<pre><code>/**
 * @author LiosWong
 * @description 工具接口
 * @date 2018/6/23 上午1:03
 */
public interface Tools &#123;
    /**
     * 打电话
     * @param msg
     * @return
     */
    String getCallMsg(String msg);
&#125;

/**
 * @author LiosWong
 * @description 顾客类
 * @date 2018/6/23 上午1:01
 */
public class Customer implements Tools&#123;
    @Override
    public String getCallMsg(String msg) &#123;
        if(StringUtils.isNotEmpty(msg))&#123;
            System.out.println(msg);
            return &quot;已收到电话&quot;;
        &#125;
        return &quot;&quot;;
    &#125;
    public static void main(String[] args) &#123;
        Customer customer = new Customer();
        SalesPerson salesPerson = new SalesPerson();
        salesPerson.callCustomer(&quot;ok&quot;,customer);
    &#125;
&#125;

/**
 * @author LiosWong
 * @description 售货员
 * @date 2018/6/23 上午1:01
 */
public class SalesPerson &#123;
    public void callCustomer(String msg,Tools tools)&#123;
        if(&quot;ok&quot;.equals(msg))&#123;
            String response = tools.getMsg(&quot;已经到货啦,请前来购买～&quot;);
            System.out.println(response);
        &#125;
    &#125;
&#125;

</code></pre><p>首先新建一个抽象工具类,里面具体使用电话工具作为通讯方法(<strong><em>回调函数</em></strong>),然后顾客要有电话,所以实现了这个接口;售货员需要在有货时通知顾客,所以需要有个通知顾客的方法callCustomer,入参数中有Tools接口的引用(<strong><em>登记回调函数</em></strong>),然后在该方法中调用Tools的方法,通知顾客已经有货了(<strong><em>调用回调函数</em></strong>),顾客接受到电话通知(<strong><em>回调响应</em></strong>);然后在Customer类的main方法中,  callCustomer方法的入参,传入了Customer的实例.</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计思想</tag>
      </tags>
  </entry>
  <entry>
    <title>并行执行任务</title>
    <url>/2019/02/16/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4></blockquote>
<p>在app列表首页,展示多个item,并有分页;而每个item里后台都会调用一个http请求,判断当前item的状态</p>
<blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></blockquote>
<p>为了更好的用体验,无疑需要使用多线程并行处理http请求,而且还需要拿到每个线程的执行结果.<br>上面的分析,有两个问题需要解决:  </p>
<pre><code>1. 如何创建线程池  
2. 如何拿到所有线程的执行结果  
</code></pre><p>对于第一个问题,还是很好解决的,使用并发包(<code>java.util.concurrent</code>)下面的ThreadPoolExecutor类创建线程池,阿里巴巴Java开发手册上推荐使用该类创建线程池:<img src="https://note.youdao.com/yws/api/personal/file/WEB8ff09313c73335f1ad8ff8697dc18776?method=download&amp;shareKey=122bd8452d30e4d6e9097a3f63205a1e" alt="https://note.youdao.com/yws/api/personal/file/WEB8ff09313c73335f1ad8ff8697dc18776?method=download&amp;shareKey=122bd8452d30e4d6e9097a3f63205a1e">,根据统计,该首页的qps最大为3以及服务器的配置后,线程池创建如下:</p>
<pre><code> protected static class ThreadFactory &#123;
        static ThreadPoolExecutor executor = new ThreadPoolExecutor(ThreadNumEnum.CORE_POOL_SIZE.getNum(), ThreadNumEnum.MAX_IMUM_POOL_SIZE.getNum(), TimeOutEnum.FiveSecond.getSeconds(), TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(),new ThreadPoolExecutor.DiscardPolicy());
        private ThreadFactory() &#123;

        &#125;
        public static ExecutorService getThreadPool() &#123;
            return executor;
        &#125;
    &#125;
</code></pre><p>如何能拿到线程的执行结果呢,传统的Thread无法拿到执行结果,由于run方法无返回值,通过ThreadPoolExecutor类图发现:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB4ef3858d7f413c8ad003fff211386730?method=download&amp;shareKey=4b734c076ea0b02705e85df1a6be5d1b" alt="https://note.youdao.com/yws/api/personal/file/WEB4ef3858d7f413c8ad003fff211386730?method=download&amp;shareKey=4b734c076ea0b02705e85df1a6be5d1b">  继承了AbstractExecutorService、ExecutorService,对ExecutorService中的invokeAll方法产生极大的兴趣,仔细阅读注释,其实这个方法用来并行执行任务:</p>
<pre><code>/**
     * Executes the given tasks, returning a list of Futures holding
     * their status and results
     * when all complete or the timeout expires, whichever happens first.
     * &#123;@link Future#isDone&#125; is &#123;@code true&#125; for each
     * element of the returned list.
     * Upon return, tasks that have not completed are cancelled.
     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have
     * terminated either normally or by throwing an exception.
     * The results of this method are undefined if the given
     * collection is modified while this operation is in progress.
     *
     * @param tasks the collection of tasks
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @param &lt;T&gt; the type of the values returned from the tasks
     * @return a list of Futures representing the tasks, in the same
     *         sequential order as produced by the iterator for the
     *         given task list. If the operation did not time out,
     *         each task will have completed. If it did time out, some
     *         of these tasks will not have completed.
     * @throws InterruptedException if interrupted while waiting, in
     *         which case unfinished tasks are cancelled
     * @throws NullPointerException if tasks, any of its elements, or
     *         unit are &#123;@code null&#125;
     * @throws RejectedExecutionException if any task cannot be scheduled
     *         for execution
     */
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
</code></pre><p>到这里,第二个问题的解决思路已经有了.</p>
<blockquote>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4></blockquote>
<p>invokeAll方法的入参分别为任务列表list、超时时间、时间单位,所以首先我们需要创建任务列表:</p>
<pre><code> List&lt;BasicUserFilter&gt; list = new ArrayList&lt;&gt;();
</code></pre><p>超时时间为每个FutureTask执行超时时间,这里设置成3s,这里的3s超时时间是针对的所有tasks，而不是单个task的超时时间,如果超时，会取消没有执行完的所有任务，并抛出超时异常,源码如下:</p>
<pre><code>for (int i = 0; i &lt; size; i++) &#123;
                execute((Runnable)futures.get(i));
                nanos = deadline - System.nanoTime();
                if (nanos &lt;= 0L)
                    return futures;
            &#125;

            for (int i = 0; i &lt; size; i++) &#123;
                Future&lt;T&gt; f = futures.get(i);
                if (!f.isDone()) &#123;
                    if (nanos &lt;= 0L)
                        return futures;
                    try &#123;
                        f.get(nanos, TimeUnit.NANOSECONDS);
                    &#125; catch (CancellationException ignore) &#123;
                    &#125; catch (ExecutionException ignore) &#123;
                    &#125; catch (TimeoutException toe) &#123;
                        return futures;
                    &#125;
                    nanos = deadline - System.nanoTime();
                &#125;
            &#125;
</code></pre><p>BasicUserFilter需要实现Callable接口,因为在方法call里能拿到线程的执行结果,<br>下面就是并行执行任务了:</p>
<pre><code>        ExecutorService executor = ThreadFactory.getThreadPool();
        List&lt;XXX&gt; userFilterDtoList = new ArrayList&lt;&gt;();
        try &#123;
            List&lt;Future&lt;XXX&gt;&gt; futureList = executor.invokeAll(list, TimeOutEnum.FourSecond.getSeconds(), TimeUnit.MILLISECONDS);
            futureList.stream().forEach(p -&gt; &#123;
                try &#123;
                    Future&lt;XXX&gt; filterDtoFuture = p;
                   //拿到线程执行结果  
                   userFilterDtoList.add(filterDtoFuture.get());
                &#125; catch (InterruptedException e) &#123;
                    logger.error(e.getMessage(), e);
                &#125; catch (ExecutionException e) &#123;
                    logger.error(e.getMessage(), e);
                &#125; catch (Exception e) &#123;
                    logger.error(e.getMessage(), e);
                &#125;
            &#125;);
        &#125; catch (InterruptedException e) &#123;
            logger.error(e.getMessage(), e);
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage(), e);
        &#125;
</code></pre><p>关于多线程笔者还有很多需要去学习,上面是一个工作笔记,关于invokeAll的执行流程、神奇的Future模式,感兴趣的可以阅读源码就能找到答案.</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>并行任务</tag>
      </tags>
  </entry>
  <entry>
    <title>简话bean加载</title>
    <url>/2019/02/16/%E7%AE%80%E8%AF%9Dbean%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>首先看示例代码:</p>
<pre><code>&lt;!--no-lazy-init   scope=singleton--&gt;
&lt;bean class=&quot;com.lios.service.test.LiosTestA&quot; id=&quot;liosTestA&quot;/&gt;
&lt;bean class=&quot;com.lios.service.test.LiosTestB&quot; id=&quot;liosTestB&quot;/&gt;
&lt;bean class=&quot;com.lios.service.test.LiosServiceServiceImpl&quot; id=&quot;liosServiceService&quot;/&gt;

ClassPathXmlApplicationContext resource = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);
BeanFactory beanFactory = resource.getBeanFactory();
LiosServiceServiceImpl liosServiceService = (LiosServiceServiceImpl) beanFactory.getBean(&quot;liosServiceService&quot;);
liosServiceService.t();
</code></pre><p>LiosServiceServiceImpl:</p>
<pre><code>@Service
public class LiosServiceServiceImpl &#123;
    private int i = 1;
    @Autowired
    LiosTestA liosTestA;
    public void t()&#123;
        try &#123;
            liosTestA.testA();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;===========&gt;&quot;);
    &#125;
&#125;
</code></pre><p>LiosTestA:</p>
<pre><code>@Service
public class LiosTestA &#123;
    @Autowired
    LiosTestB liosTestB;
    public void testA()&#123;
        liosTestB.testB();
    &#125;
&#125;
</code></pre><p>以上代码就是LiosServiceServiceImpl类中引用了LiosTestA,LiosTestA类中引用了LiosTestB,今天的问题是LiosServiceServiceImpl如何引用LiosTestA,LiosTestA如何引用LiosTestB?<br>看过源码的同学肯定知道,<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>是spring解析xml、初始化bean的入口,该方法里会调用:</p>
<pre><code>// Instantiate all remaining (non-lazy-init) singletons.
finishBeanFactoryInitialization(beanFactory);
</code></pre><p>这个方法会实例化所有的non-lazy-init单例的bean,毫无疑问,这个方法是分析问题的入口,紧跟进去:</p>
<pre><code>// Instantiate all remaining (non-lazy-init) singletons.
beanFactory.preInstantiateSingletons();
</code></pre><p>再跟进去,调用了<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>方法,再跟进去<code>getBean(beanName);</code>方法,调用了<br><code>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</code>方法:</p>
<pre><code>@Override
public Object getBean(String name) throws BeansException &#123;
    return doGetBean(name, null, null, false);
&#125;
</code></pre><p>进入doGetBean方法中,绕了那么多,这个方法才是会真正干事:</p>
<pre><code>//获取beanName
final String beanName = transformedBeanName(name);
//从缓存里获取bean,第一次时毫无疑问,sharedInstance为null
Object sharedInstance = getSingleton(beanName);
//获取RootBeanDefinition,其实用BeanDefinition初始化
final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
创建bean
createBean(beanName, mbd, args)
</code></pre><p>下面分析<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.Class&lt;T&gt;)</code>方法,明显这是把具体实现委托给子类实现了,继续跟:<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code>,该方法里有一段这样的代码:</p>
<pre><code>instanceWrapper = createBeanInstance(beanName, mbd, args);
</code></pre><p>继续跟:</p>
<pre><code>// Make sure bean class is actually resolved at this point.
Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);
//.... 后面省略
</code></pre><p>继续跟<code>resolveBeanClass()</code>方法,其实该方法里利用反射创建了bean实例,createBeanInstance()方法主要是返回BeanWrapper对象,该对象用bean实例初始化,getWrappedInstance()即可返回bean对象:</p>
<pre><code>/**
 * Return the bean instance wrapped by this object, if any.
 * @return the bean instance, or &#123;@code null&#125; if none set
 */
Object getWrappedInstance();
</code></pre><p>所以上面的LiosServiceServiceImpl、LiosTestA、LiosTestB都是通过resolveBeanClass()方法创建实例,但是里面的引用的属性如何创建呢,那回到<code>doCreateBean()</code>方法,继续看下面的代码:</p>
<pre><code>// Initialize the bean instance.
Object exposedObject = bean;
try &#123;
    //初始化bean属性的值
    populateBean(beanName, mbd, instanceWrapper);
    if (exposedObject != null) &#123;
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    &#125;
&#125;
</code></pre><p>首先分析<code>populateBean(beanName, mbd, instanceWrapper)</code>,为了直接点,直接看后置处理器BeanPostProcessor:</p>
<pre><code>for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;
if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;
    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
    if (pvs == null) &#123;
        return;
    &#125;
  &#125;
&#125;
</code></pre><p>再看InstantiationAwareBeanPostProcessor的实现类,<code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#postProcessPropertyValues</code>:</p>
<pre><code>InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);
metadata.inject(bean, beanName, pvs);
</code></pre><p>一直跟进去到<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</code>:</p>
<pre><code>value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
</code></pre><p>再跟进去:</p>
<pre><code>result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
</code></pre><p>继续跟进去:</p>
<pre><code>Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
</code></pre><p>doResolveDependency方法会根据属性的属性类型去获取引用,继续跟,可以看到<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#findAutowireCandidates</code>方法里的这段代码:</p>
<pre><code>result.put(candidateName, getBean(candidateName));
</code></pre><p>getBean(candidateName)这个不是调用<code>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</code>么,没错,是的!<br>回到<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</code>中:</p>
<pre><code>if (value != null) &#123;
ReflectionUtils.makeAccessible(field);
field.set(bean, value);
&#125;
</code></pre><p>这段代码会设置bean中的属性的值,一个真正的bean已经完成了.<br>再回到<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code>方法中,看这句代码:</p>
<pre><code>initializeBean(beanName, exposedObject, mbd);
</code></pre><p>跟进后再进入<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods</code>方法:</p>
<pre><code>boolean isInitializingBean = (bean instanceof InitializingBean);
        if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);
            &#125;
            if (System.getSecurityManager() != null) &#123;
                try &#123;
                    AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;
                        @Override
                        public Object run() throws Exception &#123;
                            ((InitializingBean) bean).afterPropertiesSet();
                            return null;
                        &#125;
                    &#125;, getAccessControlContext());
                &#125;
                catch (PrivilegedActionException pae) &#123;
                    throw pae.getException();
                &#125;
            &#125;
            else &#123;
                ((InitializingBean) bean).afterPropertiesSet();
            &#125;
        &#125;
</code></pre><p>看到InitializingBean、afterPropertiesSet()是否会想起什么呢,如果一个bean实现了InitializingBean接口后,在bean被容器加载时,自动调用afterPropertiesSet()方法,现在明白是咋回事了吧.<br>说了那么多,总结下LiosServiceServiceImpl类的加载过程,首先容器会加载LiosServiceServiceImpl或者LiosTestA或者LiosTestB,默认是没有明确顺序之分,如果按照先加载LiosTestA的话,会先创建LiosTestA实例,里面的属性LiosTestB值还是为空,然后设置其属性的值,其实就是调用getBean方法,完成LiosTestA的实例创建后,创建LiosServiceServiceImpl套路完全一样,其属性LiosTestA已经在缓存有了,直接获取即可.<br>最后,bean的加载远远不止这么复杂,文中有错误之处,麻烦指正!</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>clone</title>
    <url>/2019/02/16/clone/</url>
    <content><![CDATA[<blockquote>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4></blockquote>
<p>实现Cloneable接口的类才可以被克隆,如果不实现该接口,调用Object clone方法会报<code>CloneNotSupportedException</code>:</p>
<pre><code> &lt;p&gt;
 * Invoking Object&#39;s clone method on an instance that does not implement the
 * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception
 * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.
 &lt;p&gt;
</code></pre><blockquote>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4></blockquote>
<ol>
<li>浅克隆<br>指拷贝对象时仅拷贝对象本身中的基本变量,而不拷贝对象包含的引用指向的对象</li>
<li>深克隆<br>不仅拷贝对象本身中的基本变量，而且还拷贝对象中包含的引用指向的所有对象</li>
</ol>
<blockquote>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4></blockquote>
<pre><code>package com.lios.clone;

/**
 * @author LiosWong
 * @description
 * @date 2018/6/25 上午4:11
 */
public class Person implements Cloneable &#123;
    private String name;

    private Worker worker;

    public Person(String name, Worker worker) &#123;
        this.name = name;
        this.worker = worker;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public Person setName(String name) &#123;
        this.name = name;
        return this;
    &#125;

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;

    public static void main(String[] args) &#123;
        Person p = new Person(&quot;lios&quot;, new Worker(&quot;worker&quot;, 25));
        Person p1 = p;
        System.out.println(&quot;p:toString:&quot; + p + &quot;,hashCode:&quot; + p.hashCode() + &quot;,Worker:&quot; + p.getWorker().hashCode() + &quot;,name=&quot; + p.getName().hashCode());
        System.out.println(&quot;p1:toString:&quot; + p1 + &quot;,hashCode:&quot; + p1.hashCode() + &quot;,Worker:&quot; + p1.getWorker().hashCode() + &quot;,name=&quot; + p1.getName().hashCode());
        System.out.println(p1);


        System.out.println(&quot;=====================&quot;);

        try &#123;
            Person p2 = (Person) p.clone();
            System.out.println(&quot;p:Worker:name:&quot;+p.getWorker().getName());
            System.out.println(&quot;p1:Worker:name:&quot;+p1.getWorker().getName());
            System.out.println(&quot;p2:Worker:name:&quot;+p2.getWorker().getName());


            System.out.println(&quot;p2:toString:&quot; + p2 + &quot;,hashCode:&quot; + p2.hashCode() + &quot;,Worker:&quot; + p2.getWorker().hashCode() + &quot;,name=&quot; + p2.getName().hashCode());
            p.getWorker().setName(&quot;workp&quot;);
            p.setName(&quot;cc&quot;);
            System.out.println(&quot;p2:toString:&quot; + p2 + &quot;,hashCode:&quot; + p2.hashCode() + &quot;,Worker:&quot; + p2.getWorker().hashCode() + &quot;,name=&quot; + p2.getName().hashCode());
            System.out.println(&quot;p:Worker:name:&quot;+p.getWorker().getName());
            System.out.println(&quot;p1:Worker:name:&quot;+p1.getWorker().getName());
            System.out.println(&quot;p2:Worker:name:&quot;+p2.getWorker().getName());
            System.out.println(&quot;p:&quot;+p.getName());
            System.out.println(&quot;p1:&quot;+p1.getName());
            System.out.println(&quot;p2:&quot;+p2.getName());
        &#125; catch (CloneNotSupportedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public Worker getWorker() &#123;
        return worker;
    &#125;

    public Person setWorker(Worker worker) &#123;
        this.worker = worker;
        return this;
    &#125;

    public static class Worker implements Cloneable &#123;
        private String name;
        private Integer age;

        public Worker(String name, Integer age) &#123;
            this.name = name;
            this.age = age;
        &#125;

        @Override
        protected Object clone() throws CloneNotSupportedException &#123;
            return super.clone();
        &#125;

        public String getName() &#123;
            return name;
        &#125;

        public Worker setName(String name) &#123;
            this.name = name;
            return this;
        &#125;

        public Integer getAge() &#123;
            return age;
        &#125;

        public Worker setAge(Integer age) &#123;
            this.age = age;
            return this;
        &#125;
    &#125;
&#125;
</code></pre><p>执行结果为:</p>
<pre><code>p:toString:com.lios.clone.Person@2401f4c3,hashCode:604107971,Worker:123961122,name=3321889
p1:toString:com.lios.clone.Person@2401f4c3,hashCode:604107971,Worker:123961122,name=3321889
com.lios.clone.Person@2401f4c3
=====================
p:Worker:name:worker
p1:Worker:name:worker
p2:Worker:name:worker
p2:toString:com.lios.clone.Person@4926097b,hashCode:1227229563,Worker:123961122,name=3321889
p2:toString:com.lios.clone.Person@4926097b,hashCode:1227229563,Worker:123961122,name=3321889
p:Worker:name:workp
p1:Worker:name:workp
p2:Worker:name:workp
p:cc
p1:cc
p2:lios
</code></pre><p>发现p,p1所有的值都是一致的,当对象p中重置name属性的值、Worker属性中name的值后,p、p1、p2中属性Worker中name属性值都改变了且值相同,但是p2中的name属性值没有变化,下面用图描述:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBc3012c388ab80da868f67a461b7023d5?method=download&amp;shareKey=84a8b2485e2356be6e6fa18a91b6797f" alt="https://note.youdao.com/yws/api/personal/file/WEBc3012c388ab80da868f67a461b7023d5?method=download&amp;shareKey=84a8b2485e2356be6e6fa18a91b6797f"><br>p1与p指向堆中的同一块内存区域,p2虽然与p、p1不是指向同一块内存区域,但是它们中的Worker属性都引用同一块内存区域,其实这就是<font color=#FF6347 size=3>浅克隆</font>,修改上面clone方法:</p>
<pre><code> @Override
    protected Object clone() throws CloneNotSupportedException &#123;
         Person p = (Person) super.clone();
         p.worker = (Worker) p.getWorker().clone();
         return p;
    &#125;
</code></pre><p>再执行,结果如下:</p>
<pre><code>p:toString:com.lios.clone.Person@2401f4c3,hashCode:604107971,Worker:123961122,name=3321889
p1:toString:com.lios.clone.Person@2401f4c3,hashCode:604107971,Worker:123961122,name=3321889
com.lios.clone.Person@2401f4c3
=====================
p:Worker:name:worker
p1:Worker:name:worker
p2:Worker:name:worker
p2:toString:com.lios.clone.Person@4926097b,hashCode:1227229563,Worker:1982791261,name=3321889
p2:toString:com.lios.clone.Person@4926097b,hashCode:1227229563,Worker:1982791261,name=3321889
p:Worker:name:workp
p1:Worker:name:workp
p2:Worker:name:worker
p:cc
p1:cc
p2:lios
</code></pre><p>发现此时p2中属性Worker中的name属性值没有改变,仅仅p、p1中属性Worker中的name属性值改变了,图示:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBe26613ea80dae7acc685ad9312704f38?method=download&amp;shareKey=3e6af8ebb6ae3a40892d823c43ffc524" alt="https://note.youdao.com/yws/api/personal/file/WEBe26613ea80dae7acc685ad9312704f38?method=download&amp;shareKey=3e6af8ebb6ae3a40892d823c43ffc524"><br>上面就是<font color=#FF6347 size=3>深克隆</font></p>
<blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote>
<ol>
<li>对象被clone必须实现Cloneable接口</li>
<li>深克隆需拷贝对象中包含的引用指向的所有对象</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义钉钉机器人报警</title>
    <url>/2019/02/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%A5%E8%AD%A6/</url>
    <content><![CDATA[<p>为了埋点实时监控业务,简单的实现了钉钉机器人报警,钉钉开发官方文档<a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&amp;treeId=257&amp;articleId=105735&amp;docType=1">点击</a></p>
<pre><code>public interface AlarmService &#123;

    Response&lt;Boolean&gt; orderSuccessAlarm(CompanyAppIdEnum companyAppIdEnum, String orderNo, OrderStatusEnum orderStatusEnum);

    Response&lt;Boolean&gt; orderFilterAlarm(CompanyAppIdEnum companyAppIdEnum,Long userId);

&#125;

public class AlarmServcieImpl implements AlarmService &#123;
    @Autowired
    RedisClient RedisClient;

    @Autowired
    ConfigUtil configUtil;

    private static final Log logger = LogFactory.getLog(AlarmServcieImpl.class);

    private static final Long expireTime = 24 * 60 * 60L;

    //创建机器人可获取
    private static final String requestUrl = &quot;https://oapi.dingtalk.com/robot/send?access_token=xxxx&quot;;

    @Override
    public Response&lt;Boolean&gt; orderSuccessAlarm(CompanyAppIdEnum companyAppIdEnum, String orderNo, OrderStatusEnum orderStatusEnum) &#123;
        try &#123;
            if (configUtil.isServerTest()) &#123;
                return new Response&lt;&gt;(Boolean.FALSE);
            &#125;
            String count = RedisClient.getString(SystemConstants.ORDER_STATUS_ALARM_ROBOT, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date()));
            if (Objects.isNull(count)) &#123;
                RedisClient.setString(SystemConstants.ORDER_STATUS_ALARM_ROBOT, &quot;0&quot;, expireTime, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date()));
            &#125;
            dispatcher(companyAppIdEnum, Number.getNumber(Long.valueOf(RedisClient.getString(SystemConstants.ORDER_STATUS_ALARM_ROBOT, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date())))), AlarmTypeEnum.ORDER_ALARM);
            RedisClient.incrBy(SystemConstants.ORDER_STATUS_ALARM_ROBOT, 1L, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date()));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            logger.error(e.getMessage(), e);
        &#125;
        return new Response&lt;&gt;(Boolean.TRUE);
    &#125;

    @Override
    public Response&lt;Boolean&gt; orderFilterAlarm(CompanyAppIdEnum companyAppIdEnum,Long userId) &#123;
        try &#123;
            if (configUtil.isServerTest()) &#123;
                return new Response&lt;&gt;(Boolean.FALSE);
            &#125;
            String count = RedisClient.getString(SystemConstants.ORDER_FILTER_USER_ALARM_ROBOT, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date()));
            if (Objects.isNull(count)) &#123;
                RedisClient.setString(SystemConstants.ORDER_FILTER_USER_ALARM_ROBOT, &quot;0&quot;, expireTime, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date()));
            &#125;
            dispatcher(companyAppIdEnum, Number.getNumber(Long.valueOf(RedisClient.getString(SystemConstants.ORDER_STATUS_ALARM_ROBOT, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date())))), AlarmTypeEnum.ORDER_USER_FILTER);
            RedisClient.incrBy(SystemConstants.ORDER_STATUS_ALARM_ROBOT, 1L, companyAppIdEnum.getCompanyId().toString(), DateUtils.getDateStr(new Date()));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            logger.error(e.getMessage(), e);
        &#125;
        return new Response&lt;&gt;(Boolean.TRUE);
    &#125;

    protected void dispatcher(CompanyAppIdEnum companyAppIdEnum, Number number, AlarmTypeEnum alarmTypeEnum) &#123;
        Arrays.asList(Number.values()).forEach(
                p -&gt; &#123;
                    if (p.equals(number) &amp;&amp; !Number.INIT_NUMBER.equals(number)) &#123;
                        try &#123;
                            sendNotice(companyAppIdEnum, number, alarmTypeEnum);
                        &#125; catch (IOException e) &#123;
                            e.printStackTrace();
                            logger.error(e.getMessage(), e);
                        &#125;
                        return;
                    &#125;
                &#125;
        );
    &#125;

    public static void main(String[] args) throws IOException &#123;
        sendNotice(CompanyAppIdEnum.WAN_KA, Number.PRELIMINARY_WARNING, AlarmTypeEnum.ORDER_ALARM);
    &#125;

    private static void sendNotice(CompanyAppIdEnum companyAppIdEnum, Number number, AlarmTypeEnum alarmTypeEnum) throws IOException &#123;
        HttpClient httpclient = HttpClients.createDefault();
        HttpPost httppost = new HttpPost(requestUrl);
        httppost.addHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);
        String textMsg = getNotice(number, companyAppIdEnum, alarmTypeEnum);
        StringEntity se = new StringEntity(textMsg, &quot;utf-8&quot;);
        httppost.setEntity(se);
        HttpResponse response = httpclient.execute(httppost);
        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;
            String result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
            logger.info(&quot;报警已经成功发送,机构为:&#123;&#125;,响应消息为:&#123;&#125;&quot;, companyAppIdEnum.getDesc(), result);
        &#125;
    &#125;

    private static String getNotice(Number number, CompanyAppIdEnum companyAppIdEnum, AlarmTypeEnum alarmTypeEnum) &#123;
        switch (alarmTypeEnum) &#123;
            case ORDER_ALARM:
                return &quot;&#123;\n&quot; +
                        &quot;     \&quot;msgtype\&quot;: \&quot;markdown\&quot;,\n&quot; +
                        &quot;     \&quot;markdown\&quot;: &#123;\&quot;title\&quot;:\&quot;推单失败报警\&quot;,\n&quot; +
                        &quot;\&quot;text\&quot;:\&quot;#### 推单失败报警  \\n &quot; + companyAppIdEnum.getDesc() + &quot;推单失败已超过&quot; + number.getCount() + &quot;单&quot; + &quot;\\n &gt; ![screenshot](https://note.youdao.com/yws/api/personal/file/WEB77f35c865dbd286c3baed15670e8892f?method=download&amp;shareKey=dfdd0302d114373146480ae3d4330af1)\\n  &gt; ######&quot; + new Date() + &quot;发布 [警告]() \&quot;\n&quot; +
                        &quot;     &#125;,\n&quot; +
                        &quot;    \&quot;at\&quot;: &#123;\n&quot; +
                        &quot;        \&quot;atMobiles\&quot;: [\n&quot; +
                        &quot;            \&quot;15168426462\&quot;&quot; +
                        &quot;        ], \n&quot; +
                        &quot;        \&quot;isAtAll\&quot;: false\n&quot; +
                        &quot;    &#125;\n&quot; +
                        &quot; &#125;&quot;;
            case ORDER_USER_FILTER:
                return &quot;&#123;\n&quot; +
                        &quot;     \&quot;msgtype\&quot;: \&quot;markdown\&quot;,\n&quot; +
                        &quot;     \&quot;markdown\&quot;: &#123;\&quot;title\&quot;:\&quot;机构过滤报警\&quot;,\n&quot; +
                        &quot;\&quot;text\&quot;:\&quot;#### 机构过滤报警  \\n &quot; + companyAppIdEnum.getDesc() + &quot;过滤失败已超过&quot; + number.getCount() + &quot;单&quot; + &quot;\\n &gt; ![screenshot](https://note.youdao.com/yws/api/personal/file/WEB77f35c865dbd286c3baed15670e8892f?method=download&amp;shareKey=dfdd0302d114373146480ae3d4330af1)\\n  &gt; ######&quot; + new Date() + &quot;发布 [警告]() \&quot;\n&quot; +
                        &quot;     &#125;,\n&quot; +
                        &quot;    \&quot;at\&quot;: &#123;\n&quot; +
                        &quot;        \&quot;atMobiles\&quot;: [\n&quot; +
                        &quot;            \&quot;15168426462\&quot;&quot; +
                        &quot;        ], \n&quot; +
                        &quot;        \&quot;isAtAll\&quot;: false\n&quot; +
                        &quot;    &#125;\n&quot; +
                        &quot; &#125;&quot;;
            default:
                break;
        &#125;
        return &quot;&quot;;
    &#125;

    public enum Number &#123;

        INIT_NUMBER(0L, &quot;初始&quot;),

        PRELIMINARY_WARNING(50L, &quot;初步警告&quot;),

        PRELIMINARY_WARNING_PLUS(55L, &quot;初步警告&quot;),

        INTERMEDIATE_WARNING(100L, &quot;中级警告&quot;),

        INTERMEDIATE_WARNING_PLUS(105L, &quot;中级警告&quot;),

        INTERMEDIATE_WARNING_PLUS_PLUS(200L, &quot;中级++警告&quot;),

        INTERMEDIATE_WARNING_PLUS_PLUS_PLUS(205L, &quot;中级++警告&quot;),

        SERIOUS_WARNING(300L, &quot;严重警告&quot;),

        SERIOUS_WARNING_PLUS(305L, &quot;严重警告&quot;),

        SERIOUS_WARNING_PLUS_PLUS(350L, &quot;严重警告&quot;),

        SERIOUS_WARNING_PLUS_PLUS_PLUS(400L, &quot;严重警告&quot;),

        SERIOUS_WARNING_PLUS_PLUS_PLUS_PLUS(500L, &quot;严重警告&quot;);

        private Long count;

        private String desc;

        Number(Long count, String desc) &#123;
            this.count = count;
            this.desc = desc;
        &#125;

        public Long getCount() &#123;
            return count;
        &#125;

        public Number setCount(Long count) &#123;
            this.count = count;
            return this;
        &#125;

        public String getDesc() &#123;
            return desc;
        &#125;

        public Number setDesc(String desc) &#123;
            this.desc = desc;
            return this;
        &#125;

        public static Number getNumber(Long count) &#123;
            Number[] number = &#123;INIT_NUMBER&#125;;
            Arrays.asList(Number.values()).forEach(
                    p -&gt; &#123;
                        if (p.getCount().equals(count)) &#123;
                            number[0] = p;
                            return;
                        &#125;
                    &#125;
            );
            return number[0];
        &#125;
    &#125;

    public enum AlarmTypeEnum &#123;
        ORDER_ALARM,
        ORDER_USER_FILTER;
    &#125;
&#125;
</code></pre><p>按照钉钉的文档来开发,创建机器人后,即可获取Webhook地址,整个过程还是很简单的,以上只是提供了一个思路.</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>钉钉报警</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2019/02/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>代理模式是Java的一种设计模式,开发中可能会有一种场景,某个类的方法需要补充,但是由于不想在原有的类基础上改动,该如何做呢,如下:</p>
<pre><code>接口:
public interface ProxyUserService&#123;
    String getUserMobile(String name);
&#125;
public class ProxyUserServiceImpl implements ProxyUserService&#123;
    @Override
    public String getUserMobile(String name) &#123;
        return name;
    &#125;

&#125;
public class ProxyUserServiceStaticImpl implements ProxyUserService&#123;
    private ProxyUserService proxyUserService;

    public ProxyUserServiceStaticImpl(ProxyUserService proxyUserService) &#123;
        this.proxyUserService = proxyUserService;
    &#125;

    @Override
    public String getUserMobile(String name) &#123;
        //before
        String result = roxyUserService.getUserMobile(name);
        //after
        return result;
    &#125;

&#125;
</code></pre><p>上面可以看出,ProxyUserServiceStaticImpl实现了ProxyUserService接口,构造方法中用ProxyUserService子类初始化,在创建ProxyUserServiceStaticImpl对象时,构造方法中传入ProxyUserServiceImpl实例即可,它的getUserMobile方法其实是对ProxyUserServiceImpl类的一种功能增强.Java中有木有其他方法来帮助我们实现这一功能呢?下面就来谈谈jdk动态代理、cglib动态代理.</p>
<h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><pre><code>public class ProxyUserServiceProxy implements InvocationHandler&#123;
    /**
     * 被代理对象
     */
    private Object target;
    private static final Logger logger = LoggerFactory.getLogger(ProxyUserServiceProxy.class);

    public ProxyUserServiceProxy(Object target) &#123;
        this.target = target;
    &#125;

    /**
     *
     * @param proxy 代理对象
     * @param method 被调用的方法
     * @param args 方法的参数
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        //执行前预处理
        Object result = method.invoke(target,args);//调用被代理类中的方法
        //执行后处理
        return result;
    &#125;

    public static void main(String[] args) &#123;
        ProxyUserServiceImpl  proxyUserServiceImpl= new ProxyUserServiceImpl();
        ProxyUserServiceProxy proxyUserServiceProxy = new ProxyUserServiceProxy(proxyUserServiceImpl);
        ProxyUserService proxyUserService = (ProxyUserService)Proxy.newProxyInstance(proxyUserServiceImpl.getClass().getClassLoader(),proxyUserServiceImpl.getClass().getInterfaces(),proxyUserServiceProxy);
        logger.info(proxyUserService.getUserMobile(&quot;18883845677&quot;));
    &#125;
&#125;
</code></pre><p>ProxyUserServiceProxy代理类实现了InvocationHandler接口,重写invoke方法,在调用被代理类方法前后可以实现需要的逻辑.</p>
<h4 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h4><pre><code>public class ProxyUserServiceCgLib implements MethodInterceptor&#123;
    private static final Logger logger = LoggerFactory.getLogger(ProxyUserServiceCgLib.class);
    //回调方法
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        //执行前预处理
        Object returnObj = methodProxy.invokeSuper(o,objects);
        //执行完处理
        return returnObj;
    &#125;

    public static void main(String[] args) &#123;
        ProxyUserServiceCgLib proxyUserServiceCgLib = new ProxyUserServiceCgLib();
        Enhancer enhancer = new Enhancer();
        //对目标对象创建子类对象
        enhancer.setSuperclass(ProxyUserServiceImpl.class);
        //设置回调
        enhancer.setCallback(proxyUserServiceCgLib);
        ProxyUserService proxyUserService = (ProxyUserService) enhancer.create();
       logger.info(proxyUserService.getUserMobile(&quot;18888488585&quot;));

    &#125;
&#125;
</code></pre><p>ProxyUserServiceCgLib实现了MethodInterceptor接口,重写intercept方法,在其中实现具体逻辑.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>jdk代理的目标对象必须实现接口</li>
<li>cglib代理的目标对象可以不实现接口</li>
<li>如果目标对象没有实现接口,使用cglib</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>hashCode、equals的使用</title>
    <url>/2019/02/16/hashCode%E3%80%81equals%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这篇文章由之前的<a href="">并行执行任务</a>发展而来,如何生成task,在之前的文章中,生成task方式如下:</p>
<pre><code>Abstract Task: 
public abstract class BasicUserFilter implements Callable&lt;UserFilterDto&gt; &#123;
private static final Log logger = LogFactory.getLog(BasicUserFilter.class);
@Autowired
UserService userService;
public Long companyId;
public Long userId;
@Override
public UserFilterDto call() throws Exception &#123;
    try &#123;
        //每个执行任务调用同一个方法,只是入参不同
        Response&lt;Boolean&gt; response = userService.filter(getUserId(), getCompanyId());
        if (response.isSuccess() &amp;&amp; response.getResult()) &#123;
            return new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.TRUE);
        &#125;
    &#125; catch (Exception e) &#123;
        logger.error(e.getMessage(), e);
    &#125;
    return new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.FALSE);
&#125;
@PostConstruct
abstract void init();
// ... 篇幅关系,省略属性setter、getter方法
&#125;
&#125;

Task1:
public class Task1 extends BasicUserFilter&#123;
    @Override
    public void init() &#123;
        FilterConfigManager.register(CompanyAppIdEnum.GEI_NI_HUA.getCompanyId(),this);
    &#125;
    @Override
    public UserFilterDto call() throws Exception &#123;
        return super.call();
    &#125;
&#125;
</code></pre><p>上面生成任务类时，使用了策略模式,添加每一个任务都必须新增一个实体类,且实现BasicUserFilter或者重写自己的<code>call</code>方法,有木有比较好的方法解决这种繁琐的任务类构建呢。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>解决切入点，就是所有的任务类都执行了相同的逻辑，且调用了入参不同的方法而已，无疑使用代理模式去动态生成任务类,思路有了，代码实现也边的简单起来。下面使用java InvocationHandler创建动态代理类.</p>
<pre><code>ProxyHandler：
/**
 * @author LiosWong
 * @description
 * @date 2018/10/27 上午1:10
 */
public class ProxyHandler&lt;T&gt; implements InvocationHandler, Serializable &#123;
    private static final long serialVersionUID = -6424540398559729838L;
    private final ProxyInterface&lt;T&gt; proxyInterface;

    public ProxyHandler(ProxyInterface&lt;T&gt; proxyInterface) &#123;
        this.proxyInterface = proxyInterface;
    &#125;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        // 根据方法名,执行不同逻辑
        if (&quot;call&quot;.equals(method.getName())) &#123;
            return proxyInterface.call();
        &#125;
        return null;
    &#125;
&#125;
ProxyInterface：为了使代理模版通用,添加接口约束
/** 
 * @author LiosWong
 * @description 可扩展代理接入点
 * @date 2018/10/27 上午1:11
 */
public interface ProxyInterface&lt;T&gt; extends Callable&lt;T&gt; &#123;

&#125;
ProxyFactory：代理工厂
public class ProxyFactory&lt;T&gt; &#123;
private final Class&lt;T&gt; mapperInterface;

public ProxyFactory(Class&lt;T&gt; mapperInterface) &#123;
    this.mapperInterface = mapperInterface;
&#125;
public Class&lt;T&gt; getMapperInterface() &#123;
    return mapperInterface;
&#125;
@SuppressWarnings(&quot;unchecked&quot;)
protected T newInstance(ProxyHandler&lt;T&gt; mapperProxy) &#123;
    return (T) java.lang.reflect.Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]&#123;mapperInterface&#125;, mapperProxy);
&#125;
public T newInstance(ProxyInterface proxyInterface) &#123;
    final ProxyHandler&lt;T&gt; mapperProxy = new ProxyHandler&lt;T&gt;(proxyInterface);
    return newInstance(mapperProxy);
&#125;
&#125;
</code></pre><p>完成了上面的动态代理类构建，下面就是在业务代码中使用:</p>
<pre><code> ProxyFactory proxyFactory = new ProxyFactory&lt;Callable&gt;(Callable.class);
        List&lt;Callable&lt;UserFilterDto&gt;&gt; callableList = new ArrayList&lt;&gt;();
        List&lt;UserFilterDto&gt; filterDtosResult = new ArrayList&lt;&gt;();
        // 动态生成代理类
        list.forEach(p -&gt; &#123;
            Callable&lt;UserFilterDto&gt; callable = null;
            // 复用代理模版
            switch (concurrencyType) &#123;
                case FILTER:
                    callable = (Callable&lt;UserFilterDto&gt;) proxyFactory.newInstance(new ProxyFilterCallable(xjUserService, userId, p.getCompanyId()));
                    break;
                case SATISFY:
                    callable = (Callable&lt;UserFilterDto&gt;) proxyFactory.newInstance(new ProxySatisfyCallable(companyUserGroupService, userId, p.getCompanyId()));
                    break;
                default:
                    break;
            &#125;
            callableList.add(callable);
        &#125;);
</code></pre><p>ProxyFilterCallable:</p>
<pre><code>public class ProxyFilterCallable&lt;T&gt; implements ProxyInterface&lt;T&gt; &#123;
    private static final Log logger = LogFactory.getLog(ProxyFilterCallable.class);
    private UserService userService;
    private Long userId;
    private Long companyId;

    public ProxyFilterCallable(XjUserService xjUserService, Long userId, Long companyId) &#123;
        this.xjUserService = xjUserService;
        this.userId = userId;
        this.companyId = companyId;
    &#125;
    @Override
    public T call() throws Exception &#123;
        try &#123;
            Response&lt;Boolean&gt; response = userService.filter(getUserId(), getCompanyId());
            if (response.isSuccess() &amp;&amp; response.getResult()) &#123;
                return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.TRUE);
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage(), e);
        &#125;
        return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.FALSE);
    &#125;
    // ...
&#125;
</code></pre><p>ProxySatisfyCallable：</p>
<pre><code>public class ProxySatisfyCallable&lt;T&gt; implements ProxyInterface&lt;T&gt; &#123;
    private static final Log logger = LogFactory.getLog(ProxyFilterCallable.class);
    private CompanyUserGroupService companyUserGroupService;
    private Long userId;
    private Long companyId;

    public ProxySatisfyCallable(CompanyUserGroupService companyUserGroupService, Long userId, Long companyId) &#123;
        this.companyUserGroupService = companyUserGroupService;
        this.userId = userId;
        this.companyId = companyId;
    &#125;

    @Override
    public T call() throws Exception &#123;
        try &#123;
            XjFilterUserResultVo xjFilterUserResultVo = companyUserGroupService.checkUserInfoIsSatisfyCompany(getUserId(), getCompanyId());
            if (Objects.nonNull(xjFilterUserResultVo) &amp;&amp; xjFilterUserResultVo.getResult()) &#123;
                return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.TRUE);
            &#125;
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage(), e);
        &#125;
        return (T) new UserFilterDto().setCompanyId(getCompanyId()).setUserId(getUserId()).setFilterResultEnum(FilterResultEnum.FALSE);
    &#125;
    // ...
&#125;

</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hashCode</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title>python小白爬取某东bra数据分析</title>
    <url>/2019/02/15/python%E5%B0%8F%E7%99%BD%E7%88%AC%E5%8F%96%E6%9F%90%E4%B8%9Cbra%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近用python爬取了某东上的x款bra的用户评论,然后进行了size、color分析,直接上图:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB4ca739a6d1f980eb0abd34b663486565?method=download&amp;shareKey=bc493e1e2c90cbb1199cf42326cd1aea" alt="https://note.youdao.com/yws/api/personal/file/WEB4ca739a6d1f980eb0abd34b663486565?method=download&amp;shareKey=bc493e1e2c90cbb1199cf42326cd1aea"><br>从图表上分析初步得出该款bra黑色较受欢迎，购买的小姐姐size 75B最多～<br>下面通过数据爬取、数据解析、图表分析三方面分析。</p>
<h3 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h3><pre><code>def doPullData():
    # 设置请求头
    headers = &#123;
        &quot;:authority&quot;: &quot;sclub.jd.com&quot;,
        &quot;:method&quot;: &quot;GET&quot;,
        &quot;:path&quot;: &quot;/comment/productPageComments.action?callback=fetchJSON_comment98vv1980&amp;productId=10124144495&amp;score=0&amp;sortType=5&amp;page=0&amp;pageSize=10&amp;isShadowSku=0&amp;fold=1&quot;,
        &quot;:scheme&quot;: &quot;https&quot;,
        &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,
        &quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;,
        &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,
        &quot;cookie&quot;: &quot;shshshfpb=086b12d4e13b64d2ab454c0592b747059858aa0b2c965c7b25b1fef00d; shshshfpa=a9bc80bb-8fae-00ea-d688-7c060b026654-1545813312; ipLoc-djd=1-72-2799-0; user-key=a45a7f32-8d02-45c7-acdb-80586f8a75f4; cn=0; PCSYCityID=1213; __jdc=122270672; __jda=122270672.1960352535.1545662675.1547021613.1547045550.6; __jdu=1960352535; unpl=V2_ZzNtbRFRSkdwWBMBL0kLVWIFGwkSUkcVfQ5GUXNNCwZmVhcJclRCFX0UR1RnGFQUZAEZXkNcQx1FCEdkeBBVAWMDE1VGZxBFLV0CFSNGF1wjU00zQwBBQHcJFF0uSgwDYgcaDhFTQEJ2XBVQL0oMDDdRFAhyZ0AVRQhHZHsRWwRlBxFZQFNzJXI4dmRyHl8GZAoiXHJWc1chVEBQexlcBCoDGlpDVUcWcQpCZHopXw%3d%3d; shshshfp=b4d288e3959f3d57333ec63b277d246e; TrackID=1mqY28YiCc_QIPlhdl_yB-5MJfQNbi0MmMLJXAlsLuDy5vAImaiIuUujo18CehAJ9sVAmWOgexcWY8CXjfL-G1ydikjVAdUOf1Du5k2JHxrE0qBQ4fKPSSkYIW3etZQJO; thor=5FE438B5588118B03FF72C53690F219FECC569A54F2BBE0E20BDA38248047F07675EEEC90BBB86067FB102D042F95B66557CD207D7FC8F1CA2B9E1EA1BEA7BE1E9DE225C763524E7C65C35DF6062795323C8A69734796F1C721F9F5E1BACFC10864AAB9B51D5144D6FCE4ADF69D90AD86191A738C9E7C25A0BDD20B1F81B1170C2E9EE80E214E9A1A6A6C64DD7AD6AEC; pinId=kYCBFA88kKZe4tdMoc03gA; pin=2265532975_m; unick=diy_os; ceshi3.com=103; _tp=Oh5iHgb0BZF3J4ODGsToig%3D%3D; _pst=2265532975_m; __jdb=122270672.8.1960352535|6.1547045550; __jdv=122270672|baidu-pinzhuan|t_288551095_baidupinzhuan|cpc|0f3d30c8dba7459bb52f2eb5eba8ac7d_0_b78c4addeafa478ea45197149ef20d4e|1547047238917; shshshsID=f0c8a36bfc34b9d362a3827dcaed3cac_6_1547047239476; JSESSIONID=971C3D798C75A96132DA343FCB0EAB0C.s1&quot;,
        &quot;referer&quot;: &quot;https://item.jd.com/10124144495.html&quot;,
        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Mobile Safari/537.36&quot;
    &#125;
    # 请求URL,通过某东网站抓包即可获取
    request_url = &quot;https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv1980&amp;productId=10124144495&amp;score=0&amp;sortType=5&amp;pageSize=30&amp;isShadowSku=0&amp;rid=0&amp;fold=1&amp;page=%d&quot;
    file = None
    for page in range(1, 5000):
        url = request_url % page
        r = requests.get(url, headers)
        time.sleep(2);
        try:
             # 正则获取所需数据
             rex = re.findall(r&quot;fetchJSON_comment98vv1980\((.*)\);&quot;, r.text);
             comment = json.loads(rex[0]);
             comments = comment[&#39;comments&#39;]
        except Exception as e:
             print(e);
             continue;
        for comment in comments:
            item = &#123;&#125;
            item[&#39;content&#39;] = comment[&#39;content&#39;]  # 评论正文
            item[&#39;guid&#39;] = comment[&#39;guid&#39;]
            item[&#39;color&#39;] = comment[&#39;productColor&#39;]  # 商品颜色
            item[&#39;size&#39;] = comment[&#39;productSize&#39;]
            item[&#39;userClientShow&#39;] = comment[&#39;userClientShow&#39;]  # 购物渠道
            file = open(
                &#39;/Users/wenchao.wang/LiosWang/sublimetext/bra_jindong.json&#39;, mode=&#39;a+&#39;)
            # 换行写入文件
            # 写入json到本地磁盘,注意中文乱码处理
            file.write(json.dumps(item, ensure_ascii=False) + &quot;,\n&quot;)
            print(json.dumps(item, ensure_ascii=False), &quot;,&quot;)
        file.close()
</code></pre><p>由于调用request_url获取的数据不是json格式，所以上面使用了正则截取需要的json文本，然后把得的数据写入本地磁盘文件,在sublimetext3中打开bra_jindong.json文本,由于写入的文本有一定的格式，所以稍作处理就是一个格式规范的json啦</p>
<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><p>以上已经得到数据，但是需要对bra的size、color进行统计，所以不得不对数据进行处理了，下面直接通过代码分析:</p>
<pre><code>def parsingJSON():
    textJSON = None
    # 打开文件
    with open(&#39;/Users/wenchao.wang/LiosWang/sublimetext/bra_jindong.json&#39;, encoding=&#39;utf-8&#39;) as f:
        # print(f.read());
        textJSON = json.load(f)
        dataArray = textJSON[&#39;data&#39;]
        dataArray.sort(key=itemgetter(&#39;size&#39;))
        sortDataArray = groupby(dataArray, itemgetter(&#39;size&#39;))
        # dataArray.sort(key=itemgetter(&#39;color&#39;))
        # sortDataArray = groupby(dataArray, itemgetter(&#39;color&#39;))
        # 按照size或color统计
        sizeInfo = dict([(key, len(list(group)))
                         for key, group in sortDataArray])
        print(json.dumps(sizeInfo, ensure_ascii=False))
        # 打印出所有分组明细
        #for key, group in sortDataArray:
            #for g in group:
                #pass
               # print(key,g);
        # print(textJSON[&#39;data&#39;][0]);
</code></pre><p>使用python内置模块operator、itertools可以很好的对数据进行分组统计,以上对大小、颜色统计的输出结果分别为:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBa829f9231f752c33bfe4f8cf2c33a10c?method=download&amp;shareKey=5cd08578de074cc96a315b8c3535e90c" alt="https://note.youdao.com/yws/api/personal/file/WEBa829f9231f752c33bfe4f8cf2c33a10c?method=download&amp;shareKey=5cd08578de074cc96a315b8c3535e90c"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB75feae340a12247cd8d3d993ebdcde23?method=download&amp;shareKey=cd58ad7fcff8f61989414e8b6a7472b1" alt="https://note.youdao.com/yws/api/personal/file/WEB75feae340a12247cd8d3d993ebdcde23?method=download&amp;shareKey=cd58ad7fcff8f61989414e8b6a7472b1"></p>
<h3 id="图表分析"><a href="#图表分析" class="headerlink" title="图表分析"></a>图表分析</h3><p>以上已经得到具体数据，下面使用echarts通过图片的方式直观的展示。使用echarts也非常简单，到其官网上下载js文件引入即可。具体代码如下:</p>
<pre><code>&lt;!DOCTYPE html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ECharts&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;
    &lt;div id=&quot;bra_size&quot; style=&quot;height:400px&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;bra_color&quot; style=&quot;height:400px&quot;&gt;&lt;/div&gt;
    &lt;!-- ECharts单文件引入 --&gt;
    &lt;!--script src=&quot;http://echarts.baidu.com/build/dist/echarts.js&quot;&gt;&lt;/script--&gt;
    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;esl.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    var myChartSize = echarts.init(document.getElementById(&#39;bra_size&#39;));
    var myChartColor = echarts.init(document.getElementById(&#39;bra_color&#39;));
    // 显示标题，图例和空的坐标轴
    option = &#123;
        title: &#123;
            text: &#39;某东x款bra size统计&#39;,
            subtext: &#39;from LiosWong&#39;,
            x: &#39;center&#39;
        &#125;,
        tooltip: &#123;
            trigger: &#39;item&#39;,
            formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot;
        &#125;,
        legend: &#123;
            orient: &#39;vertical&#39;,
            left: &#39;left&#39;,
            data: [&#39;70A&#39;,
                &#39;70B&#39;,
                &#39;75A&#39;,
                &#39;75B&#39;,
                &#39;75C&#39;,
                &#39;80A&#39;,
                &#39;80B&#39;,
                &#39;80C&#39;,
                &#39;85B&#39;,
                &#39;85C&#39;
            ]
        &#125;,
        series: [&#123;
            name: &#39;访问来源&#39;,
            type: &#39;pie&#39;,
            radius: &#39;55%&#39;,
            center: [&#39;50%&#39;, &#39;60%&#39;],
            data: [
                &#123; name: &#39;70A&#39;, value: 16 &#125;,
                &#123; name: &#39;70B&#39;, value: 20 &#125;,
                &#123; name: &#39;75A&#39;, value: 55 &#125;,
                &#123; name: &#39;75B&#39;, value: 123 &#125;,
                &#123; name: &#39;75C&#39;, value: 9 &#125;,
                &#123; name: &#39;80A&#39;, value: 47 &#125;,
                &#123; name: &#39;80B&#39;, value: 85 &#125;,
                &#123; name: &#39;80C&#39;, value: 31 &#125;,
                &#123; name: &#39;85B&#39;, value: 60 &#125;,
                &#123; name: &#39;85C&#39;, value: 44 &#125;
            ],
            itemStyle: &#123;
                emphasis: &#123;
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: &#39;rgba(0, 0, 0, 0.5)&#39;
                &#125;
            &#125;
        &#125;]
    &#125;;

    option1 = &#123;
        title: &#123;
            text: &#39;某东x款bra 颜色统计&#39;,
            subtext: &#39;from LiosWong&#39;,
            x: &#39;center&#39;
        &#125;,
        tooltip: &#123;
            trigger: &#39;item&#39;,
            formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot;
        &#125;,
        legend: &#123;
            orient: &#39;vertical&#39;,
            left: &#39;left&#39;,
            data: [&#39;大红&#39;, &#39;浅粉&#39;, &#39;浅黄&#39;, &#39;肤色&#39;, &#39;黑色&#39;]
        &#125;,
        series: [&#123;
            name: &#39;访问来源&#39;,
            type: &#39;pie&#39;,
            radius: &#39;55%&#39;,
            center: [&#39;50%&#39;, &#39;60%&#39;],
            data: [
                &#123; name: &#39;大红&#39;, value: 105 &#125;,
                &#123; name: &#39;浅粉&#39;, value: 47 &#125;, &#123; name: &#39;浅黄&#39;, value: 29 &#125;,
                &#123; name: &#39;肤色&#39;, value: 109 &#125;,
                &#123; name: &#39;黑色&#39;, value: 200 &#125;
            ],
            itemStyle: &#123;
                emphasis: &#123;
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: &#39;rgba(0, 0, 0, 0.5)&#39;
                &#125;
            &#125;
        &#125;]
    &#125;;
    myChartSize.setOption(option);
    myChartColor.setOption(option1);
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>为了方便使用,利用nginx搭建了web服务指向本地html、js静态资源,在浏览器中输入<code>http://localhost:8088/echarts_bra.html</code>即可得出文章开始的图表。笔者是一名python小白，有任何问题和建议欢迎随时交流，下面是我的wechat</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc7c871f0e0cbc535314b9301cd39a1ef?method=download&amp;shareKey=be641961ad14870b805fb689bcdec557" alt="https://note.youdao.com/yws/api/personal/file/WEBc7c871f0e0cbc535314b9301cd39a1ef?method=download&amp;shareKey=be641961ad14870b805fb689bcdec557"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK、Filebeat环境搭建</title>
    <url>/2018/08/02/ELK%E3%80%81Filebeat%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4></blockquote>
<p>ELK为Elasticsearch、Logstash、Kibana简称,Filebeat为日志传输工具  </p>
<ol>
<li>Elasticsearch<br>The Heart of the Elastic Stack,Elasticsearch是一个基于分布式RESTful风格的搜索和分析引擎，能够解决越来越多的用例,作为Elastic Stack的核心，它集中存储数据，以便预期发现意外情况  </li>
<li>Logstash<br>Logstash是一个开源的服务器端数据处理管道，它可以同时从多个源中提取数据，对其进行转换，然后将其发送到您最喜欢的”存储”  </li>
<li>Kibana<br>Your Window into the Elastic Stack,Kibana用来可视化Elasticsearch数据  </li>
<li>Filebeat<br>轻量级的日志、文件传输工具,filebeat会使用一个反压力敏感(backpressure-sensitive)的协议来解释高负荷的数据量,当数据处理繁忙时，Filebeat放慢它的读取速度.一旦压力解除,将恢复到原来的速度,继续传输数据<br>简单的来说,Filebeat用来检测数据,把数据发送给Logstash,Logstash是具备实时传输数据的管道,将数据从管道的输入端传输到输出端,而且可以根据需要过滤、处理数据,Elasticsearch 是一个分布式搜索引擎,负责数据的存储、检索、分析,Kibana提供了可视化的界面,用于数据的可视化操作.</li>
</ol>
<blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4></blockquote>
<p>从<a href="https://www.elastic.co/products">https://www.elastic.co/products</a>官网上下载最新的安装包,<br> <strong>1.配置Elasticsearch</strong><br> 修改文件/elasticsearch-6.3.2/config/elasticsearch.yml:</p>
<pre><code>cluster.name: lios-boot-rest
node.name: lios-boot
path.data: /Users/wenchao.wang/dev/elk/logs
path.logs: /Users/wenchao.wang/dev/elk/logs
network.host: 127.0.0.1
http.port: 9200
</code></pre><p>启动服务:</p>
<pre><code>./elasticsearch-6.3.2/bin/elasticsearch
</code></pre><p><strong>2.配置Logstash</strong><br>在/logstash-6.3.2/config目录下新建配置文件filebeat-to-es.conf:</p>
<pre><code>     input &#123;
     beats&#123;
     type =&gt; &quot;lios-boot-rest&quot;
     host =&gt; &quot;127.0.0.1&quot;
     port =&gt; 5044
 &#125;
&#125;
output &#123;
elasticsearch&#123;
hosts =&gt; [&quot;127.0.0.1:9200&quot;]
index =&gt; &quot;lios-boot-rest-%&#123;+YYYY.MM.dd&#125;&quot;
&#125;
&#125;
</code></pre><p>启动服务:</p>
<pre><code>./logstash-6.3.2/bin/logstash -f ./filebeat-to-es.conf 
</code></pre><p><strong>3.配置kibana</strong></p>
<pre><code>server.port: 5601
server.host: &quot;127.0.0.1&quot;
elasticsearch.url: &quot;http://127.0.0.1:9200&quot;
kibana.index: &quot;.kibana&quot;
</code></pre><p>启动服务:</p>
<pre><code>./kibana-6.3.2-darwin-x86_64/bin kibana
</code></pre><p><strong>4. 配置filebeat</strong></p>
<pre><code>filebeat.inputs:
    - type: log
      # Change to true to enable this input configuration.
      enabled: true
      # Paths that should be crawled and fetched. Glob based paths.
      paths:
      - /data/lios/logs/apps/lios-boot-rest/*.log
      tags: [&quot;lios-boor-rest-log&quot;]
      document_type: lios-boot-rest
      spool_size: 1024
      idle_timeout: &quot;3s&quot;
    filebeat.config.modules:
      path: $&#123;path.config&#125;/modules.d/*.yml
      reload.enabled: false
      # Period on which files under path should be checked for changes
      #reload.period: 10s
    setup.template.settings:
      index.number_of_shards: 3
    #----------------------------- Logstash output --------------------------------
    output.logstash:
      # The Logstash hosts
      hosts: [&quot;127.0.0.1:5044&quot;]
</code></pre><p>启动filebeat服务</p>
<pre><code>mac上启动方式
sudo chown root filebeat.yml
sudo ./filebeat -e -c filebeat.yml -d &quot;publish&quot;
</code></pre><p>发现filebeat已经向logstash发送数据了:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9d0e71c88ccb436a312e6747ac1c2e46?method=download&amp;shareKey=47897f4682f9c75b134a928ad976766f" alt="https://note.youdao.com/yws/api/personal/file/WEB9d0e71c88ccb436a312e6747ac1c2e46?method=download&amp;shareKey=47897f4682f9c75b134a928ad976766f"></p>
<blockquote>
<h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4></blockquote>
<p>网址中输入<code>http://localhost:5601/</code><br><img src="https://note.youdao.com/yws/api/personal/file/WEB67fc37afa7f12be50de95ae2d447afcb?method=download&amp;shareKey=c0db3c5afcfaf14869ee68a7eb2f7b17" alt="https://note.youdao.com/yws/api/personal/file/WEB67fc37afa7f12be50de95ae2d447afcb?method=download&amp;shareKey=c0db3c5afcfaf14869ee68a7eb2f7b17"><br>创建索引:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB4e269f40a4710edd267c3bddb0874a14?method=download&amp;shareKey=7c241b06a656228479904e8e7cabea63" alt="https://note.youdao.com/yws/api/personal/file/WEB4e269f40a4710edd267c3bddb0874a14?method=download&amp;shareKey=7c241b06a656228479904e8e7cabea63"><br>创建索引成功后,发现已经可以看到数据了:<br><img src="https://note.youdao.com/yws/api/personal/file/WEBf032714873aecd77a05398651e621b24?method=download&amp;shareKey=b508852230494de3f0943d32ed10b4e8" alt="https://note.youdao.com/yws/api/personal/file/WEBf032714873aecd77a05398651e621b24?method=download&amp;shareKey=b508852230494de3f0943d32ed10b4e8"></p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>elk</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
        <tag>Filebeat</tag>
      </tags>
  </entry>
</search>
