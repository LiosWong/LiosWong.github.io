---
title: 模版方法模式
date: 2019-03-04 23:36:15
tags:
- 设计模式
- 模版方法模式
categories:
- 设计模式  
copyright: true #版权声明开启   
---

##### **定义**
模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，重新定义算法中的某些步骤.在软件工程中，它是一种软件设计模式，和C++模板没有关连.--[维基百科](https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95)
##### 案例
首先看一个最常见的模版方法,Spring中的``org.springframework.context.support.AbstractApplicationContext#refresh``方法,它是IOC容器的入口,定义了初始化流程,其中公共的执行逻辑,在父类中实现,对于不同的实现,在子类中去实现即可,Spring中几乎所有的扩展都运用了模版方法.  
麦子、水稻是人类主要的作物,它们大致的一生为``播种 --》灌溉 --》施肥 --》除草 --》收割 --》加工 --》食用``,其中播种、灌溉、加工、食用两者相差非常大,而施肥、除草、收割几乎相同,下面用代码说明,
首选定义FooldLife:
```
public abstract class FooldLife {
    public void fooldLife() {
        sowing();
        irrigation();
        fertilization();
        weeding();
        harvest();
        machining();
        harvest();
        edible();
    }

    // 播种
    protected void sowing() {
        // 空方法,具体逻辑由子类实现
    }

    // 灌溉
    protected void irrigation() {
        // 空方法,具体逻辑由子类实现
    }

    // 施肥 公共实现
    protected void fertilization() {
        // ... 具体实现
        System.out.println("施肥---");
    }

    // 除草 公共实现
    protected void weeding() {
        // ... 具体实现
        System.out.println("除草---");
    }

    // 收割 公共实现
    protected void harvest() {
        // ... 具体实现
        System.out.println("收割---");
    }

    // 加工
    protected void machining() {
        // 空方法,具体逻辑由子类实现
    }

    // 食用
    protected void edible() {
        // 空方法,具体逻辑由子类实现
    }

}
```
子类RiceLife:
```
public class RiceLife extends FooldLife {
    @Override
    protected void sowing() {
        // 具体实现
        System.out.println("播种---");
    }

    @Override
    protected void irrigation() {
        // 具体实现
        System.out.println("灌溉---");
    }

    @Override
    protected void machining() {
        // 具体实现
        System.out.println("加工---");
    }

    @Override
    protected void edible() {
        // 具体实现
        System.out.println("食用---");
    }
}
```
子类WheatLife:
```
public class WheatLife extends FooldLife {
    @Override
    protected void sowing() {
        // 具体实现
        System.out.println("播种---");
    }

    @Override
    protected void irrigation() {
        // 具体实现
        System.out.println("灌溉---");
    }

    @Override
    protected void machining() {
        // 具体实现
        System.out.println("加工---");
    }

    @Override
    protected void edible() {
        // 具体实现
        System.out.println("食用---");
    }
}
```
FooldLife中的fooldLife方法描述了作物的一生,```fertilization```、```weeding```、```harvest```方法为公共方法;而其他方法需求子类去重写,也就是空方法(钩子),子类可以由该方法控制父类,通过以上总结下模版方法模式:
1. 代码复用性  
公共代码由父类实现,子类复用
2. 可扩展性  
子类可以对父类方法扩展、功能加强

> 参考 

1. [https://blog.csdn.net/z69183787/article/details/65628166](https://blog.csdn.net/z69183787/article/details/65628166)  
2. [https://zh.wikipedia.org/wiki/%E9%92%A9%E5%AD%90%E7%BC%96%E7%A8%8B](https://zh.wikipedia.org/wiki/%E9%92%A9%E5%AD%90%E7%BC%96%E7%A8%8B)
