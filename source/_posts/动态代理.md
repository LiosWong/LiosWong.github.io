---
title: 动态代理
date: 2019-02-16 01:41:26
tags:
- 动态代理
- java
categories:
- java   
copyright: true #版权声明开启        
---
代理模式是Java的一种设计模式,开发中可能会有一种场景,某个类的方法需要补充,但是由于不想在原有的类基础上改动,该如何做呢,如下:
```
接口:
public interface ProxyUserService{
    String getUserMobile(String name);
}
public class ProxyUserServiceImpl implements ProxyUserService{
    @Override
    public String getUserMobile(String name) {
        return name;
    }
    
}
public class ProxyUserServiceStaticImpl implements ProxyUserService{
    private ProxyUserService proxyUserService;

    public ProxyUserServiceStaticImpl(ProxyUserService proxyUserService) {
        this.proxyUserService = proxyUserService;
    }

    @Override
    public String getUserMobile(String name) {
        //before
        String result = roxyUserService.getUserMobile(name);
        //after
        return result;
    }

}
```
上面可以看出,ProxyUserServiceStaticImpl实现了ProxyUserService接口,构造方法中用ProxyUserService子类初始化,在创建ProxyUserServiceStaticImpl对象时,构造方法中传入ProxyUserServiceImpl实例即可,它的getUserMobile方法其实是对ProxyUserServiceImpl类的一种功能增强.Java中有木有其他方法来帮助我们实现这一功能呢?下面就来谈谈jdk动态代理、cglib动态代理.
#### jdk动态代理
```
public class ProxyUserServiceProxy implements InvocationHandler{
    /**
     * 被代理对象
     */
    private Object target;
    private static final Logger logger = LoggerFactory.getLogger(ProxyUserServiceProxy.class);

    public ProxyUserServiceProxy(Object target) {
        this.target = target;
    }

    /**
     *
     * @param proxy 代理对象
     * @param method 被调用的方法
     * @param args 方法的参数
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //执行前预处理
        Object result = method.invoke(target,args);//调用被代理类中的方法
        //执行后处理
        return result;
    }

    public static void main(String[] args) {
        ProxyUserServiceImpl  proxyUserServiceImpl= new ProxyUserServiceImpl();
        ProxyUserServiceProxy proxyUserServiceProxy = new ProxyUserServiceProxy(proxyUserServiceImpl);
        ProxyUserService proxyUserService = (ProxyUserService)Proxy.newProxyInstance(proxyUserServiceImpl.getClass().getClassLoader(),proxyUserServiceImpl.getClass().getInterfaces(),proxyUserServiceProxy);
        logger.info(proxyUserService.getUserMobile("18883845677"));
    }
}
```
ProxyUserServiceProxy代理类实现了InvocationHandler接口,重写invoke方法,在调用被代理类方法前后可以实现需要的逻辑.
#### cglib动态代理
```
public class ProxyUserServiceCgLib implements MethodInterceptor{
    private static final Logger logger = LoggerFactory.getLogger(ProxyUserServiceCgLib.class);
    //回调方法
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        //执行前预处理
        Object returnObj = methodProxy.invokeSuper(o,objects);
        //执行完处理
        return returnObj;
    }

    public static void main(String[] args) {
        ProxyUserServiceCgLib proxyUserServiceCgLib = new ProxyUserServiceCgLib();
        Enhancer enhancer = new Enhancer();
        //对目标对象创建子类对象
        enhancer.setSuperclass(ProxyUserServiceImpl.class);
        //设置回调
        enhancer.setCallback(proxyUserServiceCgLib);
        ProxyUserService proxyUserService = (ProxyUserService) enhancer.create();
       logger.info(proxyUserService.getUserMobile("18888488585"));

    }
}
```
ProxyUserServiceCgLib实现了MethodInterceptor接口,重写intercept方法,在其中实现具体逻辑.

#### 总结
1. jdk代理的目标对象必须实现接口
2. cglib代理的目标对象可以不实现接口
3. 如果目标对象没有实现接口,使用cglib
